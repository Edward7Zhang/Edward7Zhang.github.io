<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[论：线程、多线程和线程池]]></title>
    <url>%2F2019%2F03%2F06%2F%E8%AE%BA%EF%BC%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原 理、⑨ReentranLock源码，设计原理，整体过程 等等问题。 开启线程的三种方式？ 继承 Thread 类，重写 run()方法，在 run()方法中编写要完成的任务 1new Thread().start(); 实现 Runnable 接口，实现 run()方法 1new Thread(new MyRunnable()).start(); 实现 Callable 接口 MyCallable 类，实现 call()方法，使用 FutureTask 类来包装 Callable 对象，使用 FutureTask 对象作为 Thread 对象的 target 创建并启动线程；调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 12FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(new MyCallable());new Thread(ft).start(); run() 和 start() 方法的区别run()方法只是线程的主方法体，和普通方法一样，不会创建新的线程。只有调用 start()方法，才会启动一个新的线程，新线程才会调用 run()方法，线程才会开始执行。 如何控制某个方法允许并发访问的线程数？创建 Semaphore 变量，1Semaphore semaphore = new Semaphore(5, true); 当方法进入时，请求一个信号，如果信号被用完则等待，方法运行完，释放一个信号，释放的信号新的线程就可以使用。 在 Java 中 wait 和 sleep 方法的不同 wait()方法属于 Object 类，调用该方法时，线程会放弃对象锁，只有该对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 sleep()方法属于 Thread 类，sleep 导致程序暂停执行指定的时间，让出 CPU，但他的监控状态依然保存着，当指定时间到了又会回到运行状态，sleep()方法中线程不会释放对象锁。谈谈 wait()/notfiy() 方法的理解 notify()：唤醒在此对象监视器上等待的单个线程 notifyAll()：通知所有等待竞争该资源的线程 wait()：释放 obj 的锁，导致当前的线程等待，直接其他线程调用此对象的 notify()或 notifyAll(); 当要调用 wait()或 notify()/notifyAll()方法时，一定要对竞争资源进行加锁，一般放到 synchronized(obj)代码中。当调用 obj.notify/notifyAll 后，调用线程依旧持有 obj 锁，因此等待线程虽被唤醒，但仍无法获得 obj 锁，知道调用线程退出 synchronized 块，释放 obj 锁后，其他等待线程才有机会获得锁继续执行。什么导致线程阻塞？ 线程执行了 Thread.sleep(int millsecond)方法，放弃 CPU，睡眠一段时间，一段时间过后恢复执行； 线程执行一段同步代码，但无法获得相关的同步锁，只能进入阻塞状态，等到获取同步锁，才能恢复执行； 线程执行了一个对象的 wait()方法，直接进入阻塞态，等待其他线程执行 notify()/notifyAll()操作； 线程执行某些 IO 操作，因为等待相关资源而进入了阻塞态，如 System.in，但没有收到键盘的输入，则进入阻塞态。 线程礼让，Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程，但并不会使线程进入阻塞态，线程仍处于可执行态，随时可能再次分得 CPU 时间。线程自闭，join()方法，在当前线程调用另一个线程的 join()方法，则当前线程进入阻塞态，直到另一个线程运行结束，当前线程再由阻塞转为就绪态。 线程执行 suspend()使线程进入阻塞态，必须 resume()方法被调用，才能使线程重新进入可执行状态。线程如何关闭？ 使用标志位 使用 stop() 方法，但该方法就像关掉电脑电源一样，可能会发生预料不到的问题 使用中断 interrupt()12345678public class Thread&#123; //中断当前线程 public void interrupt(); //判断当前线程是否被中断 public boolean isInterrupt(); //清除当前线程的中断状态，并返回之前的值 public static boolen interrupted();&#125; 但调用 interrupt()方法只是传递中断请求消息，并不代表要立马停止目标线程 讲一下 Java 中的同步的方法之所以需要同步，因为在多线程并发控制，当多个线程同时操作一个可共享的资源时，如果没有采取同步机制，将会导致数据不准确，因此需要加入同步锁，确保在该线程没有完成操作前被其他线程调用，从而保证该变量的唯一性和准确性。 synchronized 修饰同步代码块或方法由于 Java 的每个对象都有一个内置锁，用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需获得内置锁，否则就处于阻塞状态 volatile 修饰变量保证变量在线程间的可见性每次线程要访问 volatile 修饰的变量时都从主存中读取，而不是缓存中，这样每个线程访问到的变量都是一样的。且使用内存屏障。 ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例lock()获得锁 unlock()释放锁 使用局部变量 ThreadLocal 实现线程同步每个线程都会保存一份该变量的副本，副本之间相互独立，这样每个线程都可以随意修改自己的副本，而不影响其他线程。常用方法： ThreadLocal()创建一个线程本地变量； get()返回此线程就不懂当前线程副本变量； initialValue()返回次线程局部变量的当前线程的出事值； set(T value)将此线程变量的当前线程副本中的值设置为 value使用原子变量如 AtomicInteger常用方法： AtomicInteger(int value)创建个有给定初试值的 AtomicInteger 整数； addAndGet(int data)以原子方式将给定值与当前值相加使用阻塞队列实现线程同步LinkedBlockingQueue 如何保证线程安全？线程安全性体现的三方法： 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作。JDK 中提供了很多 atomic 类，如 AtomicInteger\AtomicBoolean\AtomicLong，它们是通过 CAS 完成原子性。JDK 提供锁分为两种：synchronized 依赖 JVM 实现锁，该关键字对对象的作用范围内同一时刻只能有一个线程进行操作。另一种是 LOCK，是 JDK 提供的代码层面的锁，依赖 CPU 指令，代表性是 ReentrantLock。 可见性：一个线程对主内存的修改及时被其他线程看到。JVM 提供了 synchronized 和 volatile，volatile 的可见性是通过内存屏障和禁止重排序实现的，volatile 会在写操作时，在写操作后加一条 store 屏障指令，将本地内存中的共享变量刷新到主内存；会在读操作时，在读操作前加一条 load 指令，从内存中读取共享变量。 有序性：指令没有被编译器重排序。可通过 volatile、synchronized、Lock 保证有序性 4. static synchronized 方法的多线程访问和作用static synchronized 控制的是类的所有实例访问，不管 new 了多少对象，只有一份，所以对该类的所有对象都加了锁。限制多线程中该类的所有实例同时访问 JVM 中该类对应的代码。 面试中关于 synchronized 关键字的 5 连击说一说自己对于 synchronized 关键字的了解synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙来完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？synchronized 关键字最主要的三种使用方式： 修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。也是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而 B 线程需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是给 Class 类上锁。这里再提醒一下：synchronized 关键字加到 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a)因为 JVM 中，字符串常量池具有缓冲功能。下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”双重校验锁实现对象单例(线程安全)12345678910111213141516public class Singleton&#123; private volatile static Singleton uniqueInstance; private Singleton()&#123;&#125; public static Singleton getUniqueInstance()&#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if(uniqueInstance == null)&#123; //类对象加锁 synchronized(Singleton.class)&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分 为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，但此时 uniqueInstance 还未被 初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 讲一下 synchronized 关键字的底层原理synchronized 关键字底层原理属于 JVM 层面。 synchronized 同步语句块的情况 1234567public class SynchronizedDemo&#123; public void method（）&#123; synchronized（this）&#123; System.out.println("synchronized 代码块"); &#125; &#125;&#125; 通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的.class 文件，然后执行 javap -c -s -v -l SynchronizedDemo.class。synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程识图获取锁也是获取 monitor(monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因)的持有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1.相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 synchronized 修饰方法的情况 12345public class SynchronizedDemo2&#123; public synchronized void method()&#123; System.out.println("synchronized 方法"); &#125;&#125; synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的却是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来 辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 说一说 JDK1.6 之后的 synchronized 关键字底层坐了哪些优化，可以详细介绍一下这些优化吗？JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减 少锁操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐 渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。关于这几种优化的详细信息可以查看：synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和 ReenTrantLock 的对比 谈谈 synchronized 和 ReenTrantLock 的区别① 两者都是可重入锁 两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时 这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死 锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多 优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。③ ReenTrantLock 比 synchronized 增加了一些高级功能 相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁； ③可实现选择性通知（锁可以绑定多个条件） * ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也 就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 * ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等 待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过ReenTrantLock类的 ReentrantLock(boolean fair) 构造方法来制定是否是公平的。 * synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也 可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很 好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视 器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵 活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合 Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而 synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果 执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的 signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。 * 性能已不是选择标准]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android端各类图片加载框架对比]]></title>
    <url>%2F2019%2F03%2F04%2FAndroid%E7%AB%AF%E5%90%84%E7%B1%BB%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[前段时间的面试过程中被问到用过什么图片加载框架，我随口而出Glide，面试官继续追问下去是做过什么比较得出Glide比较高效吗？我就阻塞了…所以在此做一次复盘，针对Android端的各种加载框架进行对比 前言 图片加载是Android开发中最最基础的功能，同时图片加载OOM也一直困扰着很多开发者，因此为了降低开发周期和难度，我们经常会选用一些图片加载的开源库。 老牌的有ImageLoader，UIL, Volley，主流的有，Picasso，Glide，Fresco等等，选择一款好的图片加载裤就成了我们的首要问题。 接下来我们对比一下主流的三款 Picasso，Glide，Fresco框架的优缺点。 Picasso，Glide，Fresco的前世今生基本项对比 对比项 Picasso Glide Fresco 地址 github.com/square/pica… github.com/bumptech/gl… github.com/facebook/fr… 发布时间 2013年5月 2014年9月 2015年5月 是否支持gif false true true 是否支持webP true true true 视频缩略图 false true true 大小 100k 500 KB 2～3M 加载速度 中 高 高 Disk+Men Cache true true true Easy of use low mediun difficult star 13160 14709 12444 开发者 Square主导 Google主导 Facebook主导 加载图片耗时及内存对比without animations 对比项 Picasso Glide Fresco java heap／native heap/平均耗时（without animations） Picasso加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d2b55e8?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d1496bb?imageslim) | ![Fresco加载无动画图片 max java heap 12.6MB 11.1MB 13.9MB max native heap 43.8MB 43.8MB 43.8MB avg wait time 241ms 34ms 44ms 从上面的加载静态图片可以看出三大主流框架性能都不错，不过用数据说话整体而言Glide更胜一筹。 allow animations 对比项 Picasso Glide Fresco java heap／native heap/平均耗时（allow animations） Picasso加载动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d57eddb?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f431b031be09?imageslim) | ![Fresco加载动画图片 max java heap 6.8MB 74.8.1MB 36.1MB max native heap 18.2MB 66.8MB 545.3MB avg wait time 1707ms 33910ms 15142ms 上面的数据我们可以忽略Picasso了，因为它根本不支持gif，那么Glide和Fresco可以看出Fresco的java heap基本保持较低平稳状态，而Glide的java heap基本为Fresco的一倍，所以OOM的风险也比fresco大一倍。从时间上glide是有一定差距，不过fresco有两张图片没加载完成，所以时间不是完全可靠的数据从native heap可以看出Fresco最高545MB，这个有点恐怖，下面我们看个知识点。 知识点 Java Heap是对于Java 虚拟机而说的，一般的大小上限是 16M 24M 48M 76M 具体视手机而定。 Native Heap是对于C/C++直接操纵的系统堆内存，所以它的上限一般是具体RAM的2/3左右。 所以对于2G的手机而言，Java Heap 大概76M，而Native Heap是760M左右，相差10倍。 所以Fresco也是存在一定风险的，因为native heap数据实在是太恐怖了。 详细属性对比接下来只详细对比Fresco和GlidePicasso从各方面都比这两个弱，这里就不浪费时间了。 对比项 Glide Fresco 配置 compile &#39;com.github.bumptech.glide:glide:XXX.XXX&#39; compile &#39;com.facebook.fresco:fresco:XXX.XXX 初始化 直接使用 Fresco.initialize(this); layout 普通ImageView 独有的SimpleDraweeView 圆角， 圆形 需要自己实现圆角，继承自BitmapTransformation操作bitmap对象实现 通过RoundingParams设置参数 缓存 Glide内存和磁盘缓存 三级缓存，分别是 Bitmap缓存，未解码图片缓存， 文件缓存。 缓存图像大小 Glide则会根据ImageView控件尺寸获得对应的大小的bitmap来展示，从而缓存也可以针对不同的对象：原始图像（source），结果图像(result) 缓存原始图像 加载策略 Glide只有占位图 先加载小尺寸图片，再加载大尺寸的 加载进度 false true 从上面的对比中可以看出来Fresco蛮强大的，不过使用起来相对Glide要复杂一点，而且需要自己的SimpleDraweeView，这一点在切换框架的时候最让人头疼了。而且Glide直接缓存相对大小的图片，节省空间的同时下场如果是同样大小的图片就不要再次请求，直接可以使用。 依赖Glide123456789repositories &#123; mavenCentral() google()&#125;dependencies &#123; implementation 'com.github.bumptech.glide:glide:4.9.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.9.0'&#125; Fresco要使用完整的Fresco功能就要导入如下的依赖123dependencies &#123; implementation 'com.facebook.fresco:fresco:1.12.1'&#125; bitmap操作Glide 1234Bitmap myBitmap = Glide.with(上下文) .load(url) .asBitmap() //必须 .get() FrescoFresco要获取bitmap更加复杂， 而且使用起来也并不是那么顺畅。首先，Fresco为了更好地管理bitmap 对象（bitmap对象申请和释放会引起频繁的GC操作，从而引起界面卡顿）， 引入了可关闭的引用（CloseableReference）, 持有者在离开作用域的时候需要关闭该引用，而我们要获取的bitmap 对象就是可关闭的引用。也就是说，我们不能像上面Glide那样把bitmap 对象取出来传递给其它地方使用， 只能在Fresco提供的作用域范围内使用。实际项目中会获取缓冲的文件对象： 12345//同样在DataSubscriber中获取FileBinaryResource resource = (FileBinaryResource) Fresco.getImagePipelineFactory().getMainFileCache().getResource(new SimpleCacheKey(url));if (resource != null &amp;&amp; resource.getFile() != null) &#123; setImage(ImageSource.uri(Uri.fromFile(resource.getFile())));&#125; 优点Glide 多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video） 生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求） 高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力） 高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半） Fresco 最大的优势在于5.0以下(最低2.3)的bitmap加载。在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem区) 大大减少OOM（在更底层的Native层对OOM进行处理，图片将不再占用App的内存） 适用于需要高性能加载大量图片的场景 缺点Glide -没有文件缓存 -java heap比Fresco高 Fresco 包较大（2~3M） 用法复杂 底层涉及c++领域，阅读源码深入学习难度大 结论Fresco虽然很强大，但是包很大，依赖很多，使用复杂，而且还要在布局使用SimpleDraweeView控件加载图片。相对而言Glide会轻好多，上手快，使用简单，配置方便，而且从加载速度和性能方面不相上下。对于一般的APP来说Glide是一个不错的选择，如果是专业的图片APP那么Fresco还是必要的。 文章部分转载于]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2.0 使用教程（与常见网络请求库对比）]]></title>
    <url>%2F2019%2F03%2F03%2FRetrofit2.0%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93%E5%AF%B9%E6%AF%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在Android开发中，网络请求十分常用 当下的网络请求加载库中，Retrofit则是当下hottest的一个网络请求库 简介 特别注意： 准确来说，Retrofit是一个 RESTful 的 HTTP 网络请求框架的封装 原因：网络请求的工作本质上是OkHttp完成的，而Retrofit仅负责网络请求接口的封装 App应用程序通过 Retrofit 请求网络，实际上是使用Retrofit接口层封装请求参数、Header、Url等信息，之后由OkHttp完成后续的请求操作 在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析 与其他开源库对比除了 Retrofit，如今 Android 中主流的网络请求框架有： Android-Async-Http Volly OkHttp 介绍 几种网络请求库之间的区别对比 附：各个主流网络请求库的 Github 地址 Android-Async-Http Volley OkHttp Retrofit Retrofit使用介绍使用Retrofit的步骤共有7个： 步骤1：添加 Retrofit 库的依赖 步骤2：创建 接受服务器返回数据 的类 步骤3：创建 用于描述网络请求 的接口 步骤4：创建 Retrofit 实例 步骤5：创建 网络请求接口实例 并 配置网络请求参数 步骤6：发送网络请求（异步\同步） &gt; 封装了 数据转换、线程切换的操作 步骤7：处理服务器返回的数据 接下来我们将这些步骤进行分解 步骤1：添加 Retrofit 库的依赖1.在Gradle加入Retrofit库的依赖 由于Retrofit是基于OkHttp，所以还需要添加OkHttp库依赖 build.gradle 123456dependencies &#123; compile&apos;com.squareup.retrofit2:retrofit:2.0.2&apos; // Retrofit库 compile &apos;com.squareup.okhttp3:okhttp:3.1.2&apos; // Okhttp库 &#125; 2.添加 网络权限AndroidManifest.xml 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 步骤2：创建 接受服务器返回数据 的类Reception.java12345public class Reception&#123; ... //根据返回数据的格式和数据解析方式（Json、XML等）定义 //下面会在实例中进行说明&#125; 步骤3：创建 用于描述网络请求 的接口 Retrofit将Http请求抽象成Java接口：采用注解描述网络请求的参数 和 配置网络请求参数 1.用 动态代理 动态 将该接口的注解“翻译”成一个Http请求，最后再执行Http请求2.注：接口中的每个方法的参数都需要使用注解标注，否则会报错 _GetRequestInterface.interface 12345678public interface GetRequest_Interface&#123; @GET("openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car") Call&lt;Translation&gt; getCall(); //@GET注解的作用：采用Get方法发送网络请求 //getCall() = 接受网络请求数据的方法 //其中返回类型为Call&lt;*&gt;,*是接收数据的类（即上面定义的Translation类） //如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;&#125; 下面详细介绍Retrofit网络请求接口 的注解类型注解类型 注解说明 第一类：网络请求方法 详细说明：a.@GET、@POST、@PUT、@DELETE、@HEAD以上方法分别对应HTTP中的网络请求方式1234567public interface GetRequest_Interface &#123; @GET("openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car") Call&lt;Translation&gt; getCall(); // @GET注解的作用:采用Get方法发送网络请求 // getCall() = 接收网络请求数据的方法 // 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类） &#125; 此处特意说明URL的组成：Retrofit把 网络请求的URL分成了两部分设置：12345678910111213// 第1部分：在网络请求接口的注解设置 @GET("openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car")Call&lt;Translation&gt; getCall();// 第2部分：在创建Retrofit实例时通过.baseUrl()设置Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fanyi.youdao.com/") //设置网络请求的Url地址 .addConverterFactory(GsonConverterFactory.create()) //设置数据解析器 .build();// 从上面看出：一个请求的URL可以通过 替换块 和 请求方法的参数 来进行动态的URL更新。// 替换块是由 被&#123;&#125;包裹起来的字符串构成// 即：Retrofit支持动态改变网络请求根目录 网络请求的完整 Url = 在创建 Retrofit 实例时通过.baseUrl() 设置 + 网络请求接口的注解设置（下面称“path”） 具体整合的规则如下： 建议采用第三种方式来配置，并尽量使用同一种路径形式。 b.@HTTP 作用：替换@GET、@POST、@PUT、@DELETE、@HEAD注解的作用 及 更多功能拓展 具体使用：通过属性 method、path、hasBody进行设置 1234567891011public interface GetRequest_Interface &#123; /** * method：网络请求的方法（区分大小写） * path：网络请求地址路径 * hasBody：是否有请求体 */ @HTTP(method = "GET", path = "blog/&#123;id&#125;", hasBody = false) Call&lt;ResponseBody&gt; getCall(@Path("id") int id); // &#123;id&#125; 表示是一个变量 // method 的值 retrofit 不会做处理，所以要自行保证准确&#125; 第二类：标记 a.@FormUrlEncoded 作用：表示发送form-encoded 的数据 每个键值对需要用 @Filed 来注解键名，随后的对象需要提供值。 b.@Multipart 作用：表示发送form-encoded 的数据（适用于 有文件 上传的场景） 每个键值对需要用 @Part 来注解键名，随后的对象需要提供值。 具体使用如下：_GetRequestInterface 123456789101112131415161718192021222324252627282930public interface GetRequest_Interface &#123; /** *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded） * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值 */ @POST("/form") @FormUrlEncoded Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field("username") String name, @Field("age") int age); /** * &#123;@link Part&#125; 后面支持三种类型，&#123;@link RequestBody&#125;、&#123;@link okhttp3.MultipartBody.Part&#125; 、任意类型 * 除 &#123;@link okhttp3.MultipartBody.Part&#125; 以外，其它类型都必须带上表单字段(&#123;@link okhttp3.MultipartBody.Part&#125; 中已经包含了表单字段的信息)， */ @POST("/form") @Multipart Call&lt;ResponseBody&gt; testFileUpload1(@Part("name") RequestBody name, @Part("age") RequestBody age, @Part MultipartBody.Part file);&#125;// 具体使用 GetRequest_Interface service = retrofit.create(GetRequest_Interface.class); // @FormUrlEncoded Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1("Carson", 24); // @Multipart RequestBody name = RequestBody.create(textType, "Carson"); RequestBody age = RequestBody.create(textType, "24"); MultipartBody.Part filePart = MultipartBody.Part.createFormData("file", "test.txt", file); Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart); 第三类：网络请求参数 详细说明 a.@Header &amp; @Headers 作用：添加请求头 &amp; 添加不固定的请求头 具体使用如下：12345678910111213// @Header@GET("user")Call&lt;User&gt; getUser(@Header("Authorization") String authorization)// @Headers@Headers("Authorization: authorization")@GET("user")Call&lt;User&gt; getUser()// 以上的效果是一致的。// 区别在于使用场景和使用方式// 1. 使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头// 2. 使用方式：@Header作用于方法的参数；@Headers作用于方法 b.@Body 作用：以post方式 传递 自定义数据类型给服务器 特别注意：如果提交的是一个Map，那么作用相当于@Field 不过 Map 要经过FormBody.Builder类处理成为符合OkHttp格式的表单，如： 12FormBody.Builder builder = new ForBody.Builder();builder.add("key","value"); c.@Field &amp; @FieldMap 作用：发送 Post 请求 时提交请求的表单字段 具体使用：与 @FormUrlEncoded 注解配合使用12345678910111213141516171819202122232425262728public interface GetRequest_Interface &#123; /** *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded） * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值 */ @POST("/form") @FormUrlEncoded Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field("username") String name, @Field("age") int age);/** * Map的key作为表单的键 */ @POST("/form") @FormUrlEncoded Call&lt;ResponseBody&gt; testFormUrlEncoded2(@FieldMap Map&lt;String, Object&gt; map);&#125;// 具体使用 // @Field Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1("Carson", 24); // @FieldMap // 实现的效果与上面相同，但要传入Map Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("username", "Carson"); map.put("age", 24); Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map); d.@Part &amp; @PartMape.@Query &amp; @QueryMapf.@Pathg.@Url汇总 步骤4：创建 Retrofit 实例步骤5：创建 网络请求接口实例 并 配置网络请求参数步骤6：发送网络请求（异步\同步）步骤7：处理服务器返回的数据]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio编译过程]]></title>
    <url>%2F2019%2F03%2F02%2FAndroidStudio%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在此记录一下AndroidStudio编译过程 其中使用到的编译工具：aapt、aidl、Java Compiler、dex、zipalign 主要步骤描述： 1.通过aapt打包res资源文件，生成R.java、resource.arsc和res文件（二进制&amp;非二进制如res/raw和pic保持原样） 2.处理.aidl文件，生成对应的Java接口文件 3.通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 4.通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex 5.通过apkbuilder工具，将aapt生成的resource.arsc和res文件、assets文件和classes.dex一起打包生成apk 6.通过Jarsigner工具，对上面的apk进行debug或release签名 7.通过zipalign工具，将签名后的apk进行对齐处理 link]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一道简单的Java面试题【转载自 知乎——方志宏】]]></title>
    <url>%2F2019%2F03%2F01%2F%E8%AE%B0%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这可能是历史上最简单的一道java面试题了。 题目很简单，完成代码，判断一个整数是否是奇数： 1public boolean isOdd(int i) 相信相当数量的人都已经在准备吐槽了，只要看过《编程珠玑》的人都知道这道题的答案和其中极为简单的道理。不过别着急骂街，不管你信不信，这道笔试题我拿到的答案好多都长这样： 1234567public boolean isOdd(int i) &#123; if (i % 2 == 1) &#123; System.out.println("是奇数"); &#125; else &#123; System.out.println("是偶数"); &#125;&#125; 然后编译一下，发现错误了，挠挠头，顶多改成这样： 1234567public boolean isOdd(int i) &#123; if (i % 2 == 1) &#123; return true; &#125; else &#123; return false; &#125;&#125; 好吧，我承认我在筛选简历的能力可能有一些问题，不过不管你信不信，好多大厂工作了几年的程序员，都会写出如上风格的代码。 于是我继续进行引导： 我：“这个函数的定义要求返回一个什么类型的值？” 候选人看了看题干：“布尔类型。” 我：“那么，你if后面的括号里面的表达式的值是一个什么类型的？” 引导到这一步的时候，依然有高达两成的候选人选择了放弃，表示他们不知道。好吧，我真的不知道你们来面试这个职位的信心何在。不过大部分人想了想，还会回答出正确答案： 候选人：“也是布尔类型。” 我：“然后呢？” 有少量候选人虽然没说出来，但是我能看出来他们觉得这只是一个巧合，并不知道怎么进行下一步。不过，大多数人想了想之后，还是会优化成如下代码： 123public boolean isOdd(int i) &#123; return i % 2 == 1;&#125; 终于过了第一关了，进行第二关的引导： 我：“那我传进来一个-1呢？” 将近一半的人在想了想之后会嘴硬地表示他们从小被教导只有自然数才有奇数偶数之分，负数没有奇偶这一说。剩余的人接受了这个设定，想了一会儿，改成这样： 123public boolean isOdd(int i) &#123; return i % 2 == 1 || i % 2 == -1;&#125; 并且在提示之后优化成这样： 123public boolean isOdd(int i) &#123; return i % 2 != 0;&#125; 好吧，这是迄今为止第一个能通过编译且完全满足了需求的代码实现了。说实话，一开始就写成这样的人，如果没有其他什么明显的缺点的话，我这里基本就能通过了。我承认我的要求比较低，但是来面试的人能直接写出这样的真的不太多，粗略地估计的话，大概占一到两成吧。 但是这里还没完呢，还有最重要的第三关呢： 我：“有更好的办法吗？” 候选人：“？” 我：“我觉得取模操作比较慢，有更快的解决方案吗？” 除了少数人能自己想想就想出来了之外，绝大部分（毫不夸张）候选人表示没有或者不知道，于是进行下一步提示： 我：“奇数和偶数转换成二进制有什么区别？” 相当一部分候选人表示自己不懂什么叫二进制和位运算，有的还表示java不是c语言，不用研究这些，就跟很多评论会吐槽我在装逼一样。少部分候选人想了想，会怯怯地回答。 候选人：“奇数最后一位是1，偶数最后一位是0。” 我：“然后呢？” 这里很奇怪的点是，大部分能聊到这里来的候选人会想起来移位操作，我真的不知道是为什么，虽然这道题确实可以有这种操作： 123public boolean isOdd(int i) &#123; return i &gt;&gt; 1 &lt;&lt; 1 != i;&#125; 但是这根本不是重点好吧！！！ 总之，无论如何，能在第三关的各种引导之后，能写出下面这个结果来的人，真的不多。能一开始没有任何引导的就写出来的人，至今只见过两个，一个我去哪儿都带着，一个拒了我的offer。 123public boolean isOdd(int i) &#123; return (i &amp; 1) == 1;&#125; 别以为这就完了！终极boss来了： 我：“这样是不是比上面取模运算要快？” 候选人：“那当然了，位运算肯定快啊。” 我：“但是我们实际代码测试过，发现上面的按位与操作和取模操作，实际运行的时间是差不多的，为什么呢？” 候选人心里mmp：“闹了半天你这是在逗我玩啊？？？” 然而真正能回答出原因来的人，面试过程中我没见过，可能是大牛都看不上我所在的公司吧。只有在某公司的时候，一个同事想了想，给出了我正确答案：“编译器会将对2的指数的取模操作，优化成位运算操作。” 难道是我经历的公司都太low了么…… 作者：方志宏链接：https://zhuanlan.zhihu.com/p/57859872来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteDance【一面总结】]]></title>
    <url>%2F2019%2F02%2F18%2FByteDance%E3%80%90%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[大概在数天前投递了字节跳动-抖音方向的实习生岗位昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题） 1.Java中的引用类型有没有什么了解？Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。 StrongReference（强引用） SoftReference（软引用） WeakReference（弱引用） PhantomReference（虚引用） 引用类型对比 序号 引用类型 取得目标对象方式 垃圾回收条件 是否可能内存泄漏 1 强引用 直接调用 不回收 可能 2 软引用 通过 get()方法 视内存情况回收 不可能 3 弱引用 通过 get()方法 永远回收 不可能 4 虚引用 无法取得 不回收 可能 1.StrongReference（强引用）如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 示例 1String[] arr = new String[]&#123;"a","b","c"&#125;; 2.SoftReference（软引用）如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 示例123456//Example1SoftReference&lt;String[]&gt; softBean = new SoftReference&lt;String[]&gt;(new String[]&#123;"a","b","c"&#125;);//Example2ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();SoftReference&lt;String[]&gt; softBean = new SoftReference&lt;String[]&gt;(new String[]&#123;"a", "b", "c"&#125;, referenceQueue); 3.WeakReference（弱引用）弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 示例12345//Example1WeakReference&lt;String[]&gt; weakBean = new WeakReference&lt;String[]&gt;(new String[]&#123;"a", "b", "c"&#125;);//Example2ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();WeakReference&lt;String[]&gt; softBean = new WeakReference&lt;String[]&gt;(new String[]&#123;"a", "b", "c"&#125;, referenceQueue); 4.PhantomReference（虚引用）“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 示例12ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();PhantomReference&lt;String[]&gt; referent = new PhantomReference&lt;String&gt;(new String[]&#123;"a", "b", "c"&#125;, referenceQueue); 2.Java中创建线程的方式有哪些1.继承Thread类创建线程类(1) 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 (2) 创建Thread子类的实例，即创建了线程对象。 (3) 调用线程对象的start()方法来启用该线程。 1234567891011121314151617public class FirstThreadTest extends Thread &#123; int i = 0; //重写run方法，run方法的方法体就是现场执行体 public void run() &#123; for (; i &lt; 100; i++) &#123; System.out.println(getName() + " " + i); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); if (i == 20) &#123; new FirstThreadTest().start(); new FirstThreadTest().start(); &#125; &#125; &#125;&#125; 上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName() 方法返回调用该方法的线程的名字。 2.通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法 体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread 对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。 3.通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行 体，并且有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该 FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用 get()方法会阻塞线程。 创建线程的三种方式的对比采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程 来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型， 较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接 使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。 3.Object类对象含有的方法有哪些？Java中的Object类是所有类的父类，它提供了以下11个方法： 1.public final native Class&lt;?&gt;getClass() 2.public native int hashCode() 3.public boolean equals(Object obj) 4.protected native Object clone() throws CloneNotSupportedException 5.public String toString() 6.public final native void notify() 7.public final native void notifyAll() 8.public final native void wait(long timeout) throws InterruptedException 9.public final void wait(long timeout,int nanos)throws InterruptedException 10.public final void wait() throws InterruptedException 11.protected void finalize() throws Throwable{} 4.Android中的进程间通信有哪些方式？具体说说BinderAndroid中的IPC方式 使用Intent 使用文件共享 使用Messenger 使用AIDL 使用ContentProvider 使用Socket 1.使用Intent1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。2.使用文件共享1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem.2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。3.使用MessengerMessenger是一种轻量级的IPC方案，它的底层实现是AIDL，可以在不同进程中传递Message对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形 服务端进程：服务端创建一个Service来处理客户端请求，同时通过一个Handler对象来实例化一个Meaaenger对象，然后在Servive的onBind中返回这个Messenger对象底层的Binder即可。 12345678910111213141516171819202122232425262728293031323334353637383940public class MessengerSercive extends Service&#123; private static final String TAG = MessengerSercive.class.getSimpleName(); private class MessengerHandler extends Handler&#123; /** * @param msg */ @Override public void handleMessage(Message msg)&#123; switch (msg.what) &#123; case Constants.MSG_FROM_CLIENT: Log.d(TAG, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]"); Toast.makeText(MessengerService.this, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show(); Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null, Constants.MSG_FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(Constants.MSG_KEY, "我已经收到你的消息，稍后回复你！"); replyMsg.setData(bundle); try &#123; client.send(replyMsg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; private Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent)&#123; return mMessenger.getBinder(); &#125;&#125; 客户端进程：首先绑定服务端Service，绑定成功之后用服务端的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，消息类型是Message。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个Messenger（和服务端一样），并通过Message的replyTo参数传递给服务端。服务端通过Message的replyTo参数就可以回应客户端了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class MainActivity extends AppCompatActivity&#123; private static final String TAG = MainActivity.class.getSimpleName(); private Messenger mGetReplyMessenger = new Messenger(new MessageHandler()); private Messenger mService; private class MessageHandler extends Handler&#123; @Override public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case Constants.MSG_FROM_SERVICE: Log.d(TAG, "received msg form service: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]"); Toast.makeText(MainActivity.this, "received vice: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInsttanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void bindService(View v)&#123; Intent mIntent = new Intent(thia,MessengerService.class); bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; public void sendMessage(View v)&#123; Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bunle(); data.putString(Constants.MSG_KEY, "Hello! This is client."); msg.setData(data); msg.replyTo = mGetReplyMessenger; try&#123; mService.send(mag); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy()&#123; unbindService(mServiceConnection); super.onDestroy(); &#125; private ServiceConnection mServiceConnection = new ServiceConnection()&#123; /** * @param name * @param service */ @Override public void onServiceConnected(ComponentName name, IBinder service)&#123; mService = new Messenger(service); Message msg = Message.obtain(null, Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY,"Hello! This is cient."); msg.setData(data); mag.replyTo = mGetReplyMessenger; try&#123; mService.send(msg); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; /** * @param name */ @Override public void onServiceDiscommected(ComponentName name)&#123; &#125; &#125;;&#125; 注意： 客户端和服务端是通过通过拿到对方的Messenger来发送Message的。只不过客户端通过bindService onServiceConnected而服务端通过message.replyTo来获得对方的Messenger。Messenger中有一个Hanlder以串行的方式处理队列中的消息。不存在并发执行，因此我们不考虑线程同步的问题。 4.使用AIDLMessenger是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用Messenger，而且Messenger只适合传递消息，不能跨进程调用方法的问题，要知道Messenger本质上也是AIDL，只不过系统做了封装方便上层的调用而已。 AIDL文件支持的数据类型 基本数据类型； String和CharSequence； ArrayList，里面的元素必须能够被AIDL支持； HashMap，实现Parcelable接口的对象；注意：如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件。 AIDL，AIDL接口本身也可以在AIDL文件中使用。服务端服务端创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。客户端绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，然后就可以调用AIDL中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致ANR。客户端的onServiceConnected和onServiceDisconnected方法都在UI线程中。 5.Android中的AsyncTask的作用？6.Android中的消息机制？7.Android中的事件分发机制了解多少？如何解决滑动冲突8.Java中的抽象类和接口的区别？理解抽象abstract class 和 interface 是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract calss和interface之间对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。 其实，两者之间还是有很大区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。 语法定义理解1.抽象类12345abstract class Demo&#123; abstract void method1(); abstract void method2(); ...&#125; 2.接口12345interface Demo&#123; void method1(); void method2(); ...&#125; 在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修饰的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract calss。 编程角度理解首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多继承的支持方面的一种折中考虑吧。 其次，在abstract class的定义中，我们可以赋予方法的默认行为。 但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用default关键字实现默认方法。12345interface InterfaceA&#123; default void foo()&#123; System.out.println("InterfaceA foo"); &#125;&#125; 在 Java 8 之前，接口与其实现类之间的耦合度太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在lambda表达式作为Java8语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。 一般性理解接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是“like-a”关系，抽象类反映的是“is-a”关系。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（if they are class），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它，所以，在高级语言上，一个类只能继承一个类（抽象类）（正如人不可能同时是生物和非生物），但是可以实现多个接口（吃饭接口、走路接口）。 总结1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 2.抽象类要被子类继承，接口要被类实现。 3.接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 4.抽象类里可以没有抽象方法。 5.接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。 6.接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。 7.抽象类不能在Java 8的 lambda 表达式中使用。 9.Java设计模式了解多少？观察者模式在哪里使用过？10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习模型的转换 [学习&转载]]]></title>
    <url>%2F2019%2F01%2F26%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端部署我们可能会使用feather CNN nihui的NCNN或者小米的mace等框架。facebook ONNX的出现为模型的转换提供了一种思路，但除了pytorch等框架能很好的支持ONNX。其他等框架并未很好的对接ONNX。在MMdnn出现之前，大家都把caffemodel作为一个中间体来进行转换。 其实就模型转换而言只是个填参数的过程，把模型结构搭好，把参数填进去就即可，但是实践过的朋友大家一定会知道这其中存在不少坑，但是我们更希望有一种自动化的模型转换方案来进行模型转换。 MMdnn的出现为模型转换带来了不少的福音，MMdnn提供了一种IR(中间表示)来来衔接各个模型之间的转换。他囊括并支持了主流的DNN框架。 下面我就简要讲一下几个的简单模型转换 在此我推荐一个查看模型结构的工具Netron 支持数种主流深度学习框架(Caffe,Tensorflow,ONNX等)的模型结构查看。 例如下图是MTCNN Pnet的模型结构图 MMdnn的安装MMdnn的安装非常简单 1pip install mmdnn 转换中的一些坑1.并不是所有Layer和所有网络都支持转换由于各个深度学习框架之间的设计模式不同有的是基于命令式的有的是基于符号形式的。各个框架之间的op的粒度不同，又由于没有一个统一的标准，支持所有框架之间的转换是一件非常难的事情。MMdnn也只是把一些提供的常用的op，如conv,pooling等常规op。 2.Tensorflow与caffe的padding方式并不相同这个问题会出现在MobileNet在转换的过程中，因为Tensorflow的padding方式和其他框架是不同的。Tensorflow标准的卷积操作通常采用非对称的padding，而caffe等其他框架的卷积操作则是采用对称的padding。 如下图 ，比如当 卷积核的大小为3x3 stride为2的时候。尽管他们的padding方式不同，但卷积之后的尺寸确是一样的。 img 转换步骤例如现在我们想把MTCNN的Keras Pnet转化成caffeodel用于部署。 1mmtoir -f keras -w pnet.h5 -o pnet 把keras模型转化成MMdnn IR中间表示，在当然目录下会生成一个.npy 的weights文件和一个.pb文件。接着使用 1mmtomodel -f caffe -in pnet -iw pnet.npy -o pnet]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习经典卷积神经网络 [学习&转载]]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括： 1.LeNet-5, 1998年 2.AlexNet, 2012年 3.ZF-Net, 2013年 4.GoogleNet, 2014年 5.VGG, 2014年 6.ResNet, 2015年 经过科研工作者的反复验证及广泛使用，这些模型逐渐成为经典，我们这里收集了一些常用的模型进行介绍。 1. VGG论文地址 VGGNet是牛津大学计算机视觉组（Visual Geometry Group）和 Google DeepMind 公司的研究员一起研发的的深度卷积神经网络。VGGNet 探索了卷积神经网络的深度与其性能之间的关系，一共有六种不同的网络结构，但是每种结构都有含有５组卷积，每组卷积都使用３ｘ３的卷积核，每组卷积后进行一个２ｘ２最大池化，接下来是三个全连接层。在训练高级别的网络时，可以先训练低级别的网络，用前者获得的权重初始化高级别的网络，可以加速网络的收敛。VGGNet 相比之前state-of-the-art的网络结构，错误率大幅下降，并取得了ILSVRC 2014比赛分类项目的第2名和定位项目的第1名。同时VGGNet的拓展性很强，迁移到其他图片数据上的泛化性非常好。VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（33）和最大池化尺寸（22）。到目前为止，VGGNet依然经常被用来提取图像特征。 经典卷积神经网络之VGGNet VGG模型核心拆解 2. GoogLeNet[v1] Going Deeper with Convolutions [v2] Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift [v3] Rethinking the Inception Architecture for Computer Vision [v4] Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning GoogLeNet的最早版本，出现在2014年的” Going deeper with convolutions “。之所以名为 “GoogLeNet” 而非 “GoogleNet” ,文章说是为了向早期的LeNet致敬。GoogleNet提出了一个全新的深度 CNN 架构——Inception，无全连接层，可以节省运算的同时，减少了很多参数，参数数量是AlexNet的1/12，数量只有5 million，而且在ImageNet竞赛中取得了很好的成绩。 GoogleNet系列论文学习 3. Resnet论文地址 ResNet在2015年被提出，在ImageNet比赛classification任务上获得第一名，因为它 “简单与实用” 并存，之后很多方法都建立在ResNet50或者ResNet101的基础上完成的，检测，分割，识别等领域都纷纷使用ResNet，具有很强的适应性。ResNet的作者何凯明也因此摘得CVPR2016最佳论文奖。 ResNet解析 ResNet学习 4. MobileNet-V1 &amp; MobileNet -V2V1论文地址 V2论文地址 MobileNet是Google团队针对移动端提出的高效图像识别网络，深入的研究了Depthwise Separable Convolutions使用方法后设计出MobileNet，Depthwise Separable Convolutions的本质是冗余信息更少的稀疏化表达。在此基础上给出了高效模型设计的两个选择：宽度因子(Width Multiplier)和分辨率因子(Resolution Multiplier)；通过权衡大小、延迟时间以及精度，来构建规模更小、速度更快的MobileNet。 MobileNet V2是之前MobileNet V1的改进版。MobileNet V1中主要是引入了Depthwise Separable Convolution代替传统的卷积操作，相当于实现了spatial和channel之间的解耦，达到模型加速的目的，整体网络结构还是延续了VGG网络直上直下的特点。和MobileNet V1相比，MobileNet V2主要的改进有两点：1、Linear Bottlenecks。也就是去掉了小维度输出层后面的非线性激活层，目的是为了保证模型的表达能力。2、Inverted Residual block。该结构和传统residual block中维度先缩减再扩增正好相反，因此shotcut也就变成了连接的是维度缩减后的feature map。 深度解读谷歌MobileNet 轻量化网络：MobileNet-V2 5. U-NET论文地址 项目地址 这是Encoder-Decoder网络的一种，在无监督学习中的框架，利用conv与deconv降维升维来进行学习，分别叫做encoder与decoder编码解码，一般基于卷积网络，encoder后相当于学习到了特征，而decoder后相当于还原了图像，既可以用输入图像进行训练，训练好一层加深一层。再可以利用有监督微调，从而达到分类或者图像转换的目的。 6. GAN总结：利用两个网络对抗生成模型，生成器与辨别器，生成器输入图像，生成所需图像，辨别器辨别所需图像与生成图像，使生成器的生成图像骗过辨别器。]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用深度学习框架[学习&转载]]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%B8%B8%E8%A7%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，针对主流的深度学习框架进行简单对比及介绍。 框架 机构 支持语言 Stars Forks Caffe BVLC C++/Python/Matlab 25480 15560 CNTK Microsoft C++ 15083 4020 Keras Fchollet Python 33332 12563 Tensorflow Google Python/C++/Go… 109115 67339 MXNet DMLC Python/C++/R… 15162 5484 PyTorch Facebook Python 18517 4426 性能对比1. 训练时间: Network DenseNet-121 (Multi-GPU)运行于 SSD 硬盘 框架 1xV100/CUDA 9/CuDNN 7 4xV100/CUDA 9/CuDNN 7 Pytorch 27min 10min Keras(TF) 38min 18min Tensorflow 33min 22min MXNet(Gluon) 29min 10min 运行于RAM内存中 框架 1xV100/CUDA 9/CuDNN 7 4xV100/CUDA 9/CuDNN 7 Pytorch 25min 8min Keras(TF) 36min 15min Tensorflow 25min 14min MXNet(Gluon) 28min 8min 2. 1000张图片推理时间(s): Network ResNet-50 框架 K80/CUDA 8/CuDNN 6 P100/CUDA 8/CuDNN 6 CNTK 8.5 1.6 Keras(TF) 10.2 2.9 Tensorflow 6.5 1.8 MXNet 7.7 1.6 PyTorch 7.7 1.9 3. CPU推理时间(s): E5-2630v4, Network FCN5 框架 1 Thread 2 Threads 4 Threads 8 Threads 16 Threads 32 Threads Caffe 1887.2ms 1316.7ms 1051.8ms 952.1ms 952.3ms 834.7ms CNTK 1238.7ms 616.3ms 352.7ms 229.5ms 155.9ms 192.4ms Tensorflow 992.2ms 773.6ms 419.3ms 252.3ms 149.7ms 124.7ms MXNet 1386.8ms 915.5ms 559.0ms 499.1ms 416.3ms 413.9ms 框架评价 框架 安装成本 代码理解程度 API丰富程度 模型丰富程度 文档完整程度 训练与测过程 学习资源 CNTK 良好 良好 良好 良好 优秀 良好 良好 Keras 良好 良好 优秀 优秀 良好 优秀 良好 MXNet 良好 良好 良好 良好 良好 优秀 优秀 Pytorch 优秀 优秀 良好 良好 优秀 良好 良好 Tensorflow 良好 良好 优秀 优秀 优秀 优秀 优秀 Caffe 良好 优秀 良好 良好 优秀 良好 优秀 推荐框架目前众多的深度学习框架，使用者只要选择适合自己的框架即可，我们在日常使用中，考虑到训练的快捷程度，部署难度以及对CNN、RNN模型的直接程度，推荐以下几款深度学习框架。 1.KerasKeras 提供了简单易用的 API 接口，入门快，特别适合初学者入门。其后端采用 TensorFlow, CNTK，以及 Theano。另外，Deeplearning4j 的 Python 也是基于 Keras 实现的。Keras 几乎已经成了 Python 神经网络的接口标准。 2.TensorFlow谷歌出品，追随者众多。代码质量高，支持模型丰富，支持语言多样， TensorBoard 可视化工具使用方便。 3.MXNet已被亚马逊选为 AWS 上的深度学习框架，支持动态图计算。MXNet 有许多中国开发者，因而有非常良好的中文文档支持。Gluon 接口使得 MXNet 像 Keras 一样简单易用。 参考资料 香港浸会大学深度学习框架Benchmark DeepLearningFrameworks 博客 开发者如何选择深度学习框架?]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回环，未来可期]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%9B%9E%E7%8E%AF%EF%BC%8C%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[今天，是我21岁的生日。在一个半月前我辞职了，但准确的说是被动式辞职。现在看来这是一件好事。 第一天到公司楼下 工牌 第一天安顿下来 似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历辞职的原因是优秀的project不被认可…所以和我的直接主管就一并选择了离职… 在外界人看来可能这种做法简直是不解… 嗯，希望这家公司可以保持初心 可是对于程序猿这类人来说，能做自己感兴趣的事情应该是最高的荣誉… 况且是在一个优秀project并且在有良好实现的基础上被否掉…这种痛苦莫过于饮鸩 正如标题所言 回环 ，刚刚接到消息的时候自己还郁闷了一整天，现在回头看这应该是一种回环，就如同立交桥的转环匝道，虽然又绕回了原点，但是却提升了一个维度。 幸运如我，在这短暂的实习中遇到了非常nice的主管，涨了很多见识，意识到我之前是多么的短视…从而也看到了自己未来的一些可能，但前提要做一些付出。 公司对面的腾讯&完美世界 在这两个月的实习中，项目进展有如神助在实习这段时间，项目进展速度惊人，每天都很充实，每天一组的伙伴们都在一起想对策，现在回头想想也许是之前自己在人工智能方面的一点小小的经验加之主管之前在NLP方面的研究的共交使得项目发展迅速。 两个月的时间实现了模型的搭建以及demo的实现&amp;项目预演… 工位 在公司最后一天的项目汇报 至于为什么否掉我们…各种因素…不想明说了…有点官宦风格…各位看客自己想象吧… 下一步，再进站 反射 这一趟实习下来，可以说彻底改变了我曾经对自己的看法… 总的来说，过去我常常视线过度短浅…在对自己人生的规划上也过于保守吧… 事实上，一个人所看到的往往是狭窄的，通过不断的接触高层次的人和事物才能让自己变得更open。 决定了考研，也看清了国内的互联网环境的虚实…希望自己能付有所得… 如果有机会，还是去接触接触技术原始地熏陶熏陶吧… 未来可期在大学里的三年再算上实习的经历…尝试了互联网开发的很多方向… 最终吸引我的并不是各种框架炫技的开发…而是能赋予应用灵魂的人工智能方向… 大概未来的发展方向也就定在这样的趋势了… 继续行走，未来可期。 离开那天天气很好 未来可期]]></content>
      <tags>
        <tag>Inspire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于TensorFlow的CNN中文文本分类]]></title>
    <url>%2F2018%2F05%2F20%2F%E5%9F%BA%E4%BA%8ETensorFlow%E7%9A%84CNN%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。 CNN实现文本分类的原理下图展示了如何使用cnn进行句子分类。输入是一个句子，为了使其可以进行卷积，首先需要将其转化为向量表示，通常使用word2vec实现。d=5表示每个词转化为5维的向量，矩阵的形状是[sentence_length ×× 5]，即[7 ×× 5]。6个filter（卷积核），与图像中使用的卷积核不同的是，nlp使用的卷积核的宽与句子矩阵的宽相同，只是长度不同。这里有（2，3，4）三种size，每种size有两个filter，一共有6个filter。然后开始卷积，从图中可以看出，stride是1，因为对于高是4的filter，最后生成4维的向量，（7-4）/1+1=4。对于高是3的filter，最后生成5维的向量，（7-3）/1+1=5。卷积之后，我们得到句子的特征，使用activation function和1-max-pooling得到最后的值，每个filter最后得到两个特征。将所有特征合并后，使用softmax进行分类。图中没有用到chanel,下文的实验将会使用两个通道，static和non-static，有相关的具体解释。 这里写图片描述 本文使用的模型 这里写图片描述 主要包括五层，第一层是embedding layer,第二层是convolutional layer,第三层是max-pooling layer,第四层是fully connected layer，最后一层是softmax layer.接下来依次介绍相关代码实现。 Input placeholder1234# Placeholders for input, output and dropoutself.input_x = tf.placeholder(tf.int32, [None, sequence_length], name=&quot;input_x&quot;)self.input_y = tf.placeholder(tf.float32, [None, num_classes], name=&quot;input_y&quot;)self.dropout_keep_prob = tf.placeholder(tf.float32, name=&quot;dropout_keep_prob&quot;) tf.placeholder 创建一个占位符变量，在训练或者测试的时候，需要将占位符输入到网络中进行计算，其中的第二个参数是输入张量的形状。None 意味着它可以是任何维度的长度，在我们的实验中它代表批处理的大小，None使得网络可以处理任意长度的batches。失活率同样也是输入的一部分，在训练的时候使用dropout ，测试的时候不使用dropout 。 EMBEDDING LAYER这一层将单词索引映射到低维的向量表示，它本质上是一个查找表，我们从数据中通过学习得到。 1234with tf.device(&apos;/cpu:0&apos;), tf.name_scope(&quot;embedding&quot;): W = tf.Variable(tf.random_uniform([vocab_size, embedding_size], -1.0, 1.0), name=&quot;W&quot;) self.embedded_chars = tf.nn.embedding_lookup(W, self.input_x) self.embedded_chars_expanded = tf.expand_dims(self.embedded_chars, -1) 其中，W 是 在训练时得到的embedding matrix.，用随机均匀分布进行初始化。tf.nn.embedding_lookup实现embedding操作，得到 一个3-dimensional 的张量，形状是 [None, sequence_length, embedding_size]. sequence_length 是数据集中最长句子的长度，其他句子都通过添加“PAD”补充到这个长度。embedding_size 是词向量的大小。 TensorFlow的卷积函数-conv2d 需要四个参数， 分别是batch, width, height 以及channel。 embedding之后不包括 channel, 所以我们人为地添加上它，并设置为1。现在就是[None, sequence_length, embedding_size, 1] CONVOLUTION AND MAX-POOLING LAYERS由图中可知， 我们有不同size的filters。因为每次卷积都会产生不同形状的张量，所以我们要遍历每个filter，然后将结果合并成一个大的特征向量。 12345678910111213141516171819202122232425262728pooled_outputs = []for i, filter_size in enumerate(filter_sizes): with tf.name_scope(&quot;conv-maxpool-%s&quot; % filter_size): # Convolution Layer filter_shape = [filter_size, embedding_size, 1, num_filters] W = tf.Variable(tf.truncated_normal(filter_shape, stddev=0.1), name=&quot;W&quot;) b = tf.Variable(tf.constant(0.1, shape=[num_filters]), name=&quot;b&quot;) conv = tf.nn.conv2d( self.embedded_chars_expanded, W, strides=[1, 1, 1, 1], padding=&quot;VALID&quot;, name=&quot;conv&quot;) # Apply nonlinearity h = tf.nn.relu(tf.nn.bias_add(conv, b), name=&quot;relu&quot;) # Max-pooling over the outputs pooled = tf.nn.max_pool( h, ksize=[1, sequence_length - filter_size + 1, 1, 1], strides=[1, 1, 1, 1], padding=&apos;VALID&apos;, name=&quot;pool&quot;) pooled_outputs.append(pooled)# Combine all the pooled featuresnum_filters_total = num_filters * len(filter_sizes)self.h_pool = tf.concat(3, pooled_outputs)self.h_pool_flat = tf.reshape(self.h_pool, [-1, num_filters_total]) 这里W 是filter 矩阵，h 是对卷积结果进行非线性转换之后的结果。每个 filter都从整个embedding划过,不同之处在于覆盖多少单词。 “VALID” padding意味着没有对句子的边缘进行padding,也就是用了narrow convolution，输出的形状是 [1, sequence_length - filter_size + 1, 1, 1]。narrow convolution与 wide convolution的区别是是否对边缘进行填充。 这里写图片描述 Narrow vs. Wide Convolution. Filter size 5, input size 7. Source: A Convolutional Neural Network for Modelling Sentences (2014)当你的filter比输入的size还大时，你可以看到wide convolution是多么的有用，甚至说是必须的。如上所示，narrow convolution产出的尺寸是（7-5）+1=3，而wide convolution产出尺寸是（7+2*4-5）+1=11。通常，输出尺寸的规则表达式为： 这里写图片描述 对输出进行max-pooling后得到形状是 [batch_size, 1, 1, num_filters] 的张量，本质上是一个特征向量，最后一个维度是特征代表数量。把每一个max-pooling之后的张量合并起来之后得到一个长向量 [batch_size, num_filters_total]. in tf.reshape 中的 -1表示T将向量展平。 DROPOUT LAYERDropout也许是cnn中最流行的正则化方法。dropout的想法很简单，dropout layer随机地选择一些神经元，使其失活。这样可以阻止co-adapting,迫使它们每一个都学习到有用的特征。失活的神经单元个数由dropout_keep_prob 决定。在训练的时候设为 0.5 ,测试的时候设为 1 (disable dropout) . 123# Add dropoutwith tf.name_scope(&quot;dropout&quot;): self.h_drop = tf.nn.dropout(self.h_pool_flat, self.dropout_keep_prob) SCORES AND PREDICTIONS利用特征向量，我们可以用矩阵相乘计算两类的得分，也可以用 softmax函数计算两类的概率值。 12345with tf.name_scope(&quot;output&quot;): W = tf.Variable(tf.truncated_normal([num_filters_total, num_classes], stddev=0.1), name=&quot;W&quot;) b = tf.Variable(tf.constant(0.1, shape=[num_classes]), name=&quot;b&quot;) self.scores = tf.nn.xw_plus_b(self.h_drop, W, b, name=&quot;scores&quot;) self.predictions = tf.argmax(self.scores, 1, name=&quot;predictions&quot;) LOSS AND ACCURACY可以用得分定义损失值。损失计算的是网络的误差，我们的目标是将其最小化，分类问题标准的损失函数是交叉熵损失。 1234# Calculate mean cross-entropy losswith tf.name_scope(&quot;loss&quot;): losses = tf.nn.softmax_cross_entropy_with_logits(self.scores, self.input_y) self.loss = tf.reduce_mean(losses) 计算正确率 1234# Calculate Accuracywith tf.name_scope(&quot;accuracy&quot;): correct_predictions = tf.equal(self.predictions, tf.argmax(self.input_y, 1)) self.accuracy = tf.reduce_mean(tf.cast(correct_predictions, &quot;float&quot;), name=&quot;accuracy&quot;) MINIMIZING THE LOSS利用TensorFlow 内置的optimizers，例如 Adam optimizer，优化网络损失。 1234global_step = tf.Variable(0, name=&quot;global_step&quot;, trainable=False)optimizer = tf.train.AdamOptimizer(1e-4)grads_and_vars = optimizer.compute_gradients(cnn.loss)train_op = optimizer.apply_gradients(grads_and_vars, global_step=global_step) train_op 是一个新建的操作，我们可以在参数上进行梯度更新。每执行一次 train_op 就是一次训练步骤。 TensorFlow 可以自动地计算才那些变量是“可训练的”然后计算他们的梯度。通过global_step这个变量可以计算训练的步数，每训练一次自动加一。 CHECKPOINTINGTensorFlow 中可以用checkpointing 保存模型的参数。checkpointing中的参数也可以用来继续训练。 1234567# Checkpointingcheckpoint_dir = os.path.abspath(os.path.join(out_dir, &quot;checkpoints&quot;))checkpoint_prefix = os.path.join(checkpoint_dir, &quot;model&quot;)# Tensorflow assumes this directory already exists so we need to create itif not os.path.exists(checkpoint_dir): os.makedirs(checkpoint_dir)saver = tf.train.Saver(tf.all_variables()) DEFINING A SINGLE TRAINING STEP用一个batch的数据进行一次训练。 123456789101112131415def train_step(x_batch, y_batch): &quot;&quot;&quot; A single training step &quot;&quot;&quot; feed_dict = &#123; cnn.input_x: x_batch, cnn.input_y: y_batch, cnn.dropout_keep_prob: FLAGS.dropout_keep_prob &#125; _, step, summaries, loss, accuracy = sess.run( [train_op, global_step, train_summary_op, cnn.loss, cnn.accuracy], feed_dict) time_str = datetime.datetime.now().isoformat() print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy)) train_summary_writer.add_summary(summaries, step) train_op 什么也不返回，只是更新网络中的参数。最终，打印出当前训练的损失值与正确率。如果batch的size很小的话，这两者在不同的batch中差别很大。因为使用了dropout，训练的metrics可能要比测试的metrics糟糕。 同样的函数也可以用在测试时。 12345678910111213141516def dev_step(x_batch, y_batch, writer=None): &quot;&quot;&quot; Evaluates model on a dev set &quot;&quot;&quot; feed_dict = &#123; cnn.input_x: x_batch, cnn.input_y: y_batch, cnn.dropout_keep_prob: 1.0 &#125; step, summaries, loss, accuracy = sess.run( [global_step, dev_summary_op, cnn.loss, cnn.accuracy], feed_dict) time_str = datetime.datetime.now().isoformat() print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy)) if writer: writer.add_summary(summaries, step) TRAINING LOOP通过迭代数据进行训练。 123456789101112131415# Generate batchesbatches = data_helpers.batch_iter( zip(x_train, y_train), FLAGS.batch_size, FLAGS.num_epochs)# Training loop. For each batch...for batch in batches: x_batch, y_batch = zip(*batch) train_step(x_batch, y_batch) current_step = tf.train.global_step(sess, global_step) if current_step % FLAGS.evaluate_every == 0: print(&quot;\nEvaluation:&quot;) dev_step(x_dev, y_dev, writer=dev_summary_writer) print(&quot;&quot;) if current_step % FLAGS.checkpoint_every == 0: path = saver.save(sess, checkpoint_prefix, global_step=current_step) print(&quot;Saved model checkpoint to &#123;&#125;\n&quot;.format(path)) VISUALIZING RESULTS IN TENSORBOARD 这里写图片描述 这里写图片描述 从上图中我们可以观察到: 我们的训练 metrics不平滑，因为用的batch sizes很小。如果用大的batches (或者在整个测试集上进行评估)，会得到平滑的线。 测试集的 accuracy明显比训练集的低，说明网络过拟合了，我们应该用更大的数据集，更强的正则化，更少的模型参数。 训练集上的 loss 和 accuracy比测试集低的原因是用了dropout. 参考：http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验室招新题目②]]></title>
    <url>%2F2018%2F05%2F08%2F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE(2)%2F</url>
    <content type="text"><![CDATA[火车装箱 现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车要求： 其中每节车厢中包含两种元素 车厢号：TrainNum 以及所装载货物数量：GoodsNum； 其中每节车厢以前车厢 -&gt; 后车厢 的形式进行连接； 按照每节车厢的GoodsNum的降序进行连接； 自定义一个TrainCabin数据结构 12345struct TrainCabin&#123;//TODO structure your struct&#125;; 写出一个函数 12TrainCabin* AssembleTraninCabin(TrainCabin* TrainList);//选择你认为时间复杂度最小的算法进行编码 返回值为已按照以上要求排好序后的火车链表 输入 第一个值为TrainNum 第二个值为GoodsNum 中间以|分割 输入-1 以结束输入 Input：1 | 3 2 | 5 3 | 7 4 | 2 5 | 0 -1 输出 在控制台中打印排好序的火车列 按照以下示例格式 Output：| 3 | 7 | -&gt; | 2 | 5 | -&gt; | 1 | 3 | -&gt; | 4 | 2 | -&gt; | 5 | 0 | 题解非常基础的一道考察数据抽象、数据结构构造、排序算法、单向链表的简单题…但今天的现场情况不容乐观12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream.h&gt;#include&lt;stdlib.h&gt;typedef struct TrainCabin&#123; int TrainNum; int GoodsNum; struct TrainCabin *next;&#125;TrainCabin;TrainCabin* AssembleTraninCabin(TrainCabin *TrainList)&#123; TrainCabin *i=TrainList; TrainCabin *j; TrainCabin *temp=(TrainCabin*)malloc(sizeof(TrainCabin)); temp-&gt;next=NULL; while(i!=NULL) &#123; j=i-&gt;next; while(j!=NULL) &#123; if((*i).GoodsNum&gt;(*j).GoodsNum) &#123; (*temp).TrainNum=(*i).TrainNum; (*temp).GoodsNum=(*i).GoodsNum; (*i).TrainNum=(*j).TrainNum; (*i).GoodsNum=(*j).GoodsNum; (*j).TrainNum=(*temp).TrainNum; (*j).GoodsNum=(*temp).GoodsNum; &#125; j=j-&gt;next; &#125; i=i-&gt;next; &#125; return TrainList;&#125;void display(const TrainCabin *TrainList)&#123; while(TrainList-&gt;next!=NULL) &#123; cout&lt;&lt;"|"&lt;&lt;(*TrainList).TrainNum&lt;&lt;"|"&lt;&lt;(*TrainList).GoodsNum&lt;&lt;"| -&gt; "; TrainList=TrainList-&gt;next; &#125; cout&lt;&lt;"|"&lt;&lt;(*TrainList).TrainNum&lt;&lt;"|"&lt;&lt;(*TrainList).GoodsNum&lt;&lt;"|"&lt;&lt;endl;&#125;int main()&#123; int TrainNum=0,GoodsNum=0; TrainCabin *frist,*last; TrainCabin *temp; frist=(TrainCabin*)malloc(sizeof(TrainCabin)); frist-&gt;next=NULL; last=frist; char input; while(1) &#123; cin&gt;&gt;TrainNum; if(TrainNum==-1) break; cin&gt;&gt;input; cin&gt;&gt;GoodsNum; temp=(TrainCabin*)malloc(sizeof(TrainCabin)); temp-&gt;TrainNum=TrainNum; temp-&gt;GoodsNum=GoodsNum; temp-&gt;next=NULL; last-&gt;next=temp; last=temp; &#125; TrainCabin *result=AssembleTraninCabin((*frist).next); display(result); return 0;&#125;]]></content>
      <tags>
        <tag>Lab_Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后生可畏]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%90%8E%E7%94%9F%E5%8F%AF%E7%95%8F%2F</url>
    <content type="text"><![CDATA[Take your Child to work Day at Google 2018 When I heared a kid who Firmly said I will be a video game programmer, I realize that it is extraordinary.]]></content>
      <tags>
        <tag>Inspire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment Navigation Drawer]]></title>
    <url>%2F2018%2F05%2F05%2FFragment%20Navigation%20Drawer%2F</url>
    <content type="text"><![CDATA[..最近这段时间在着手做一个开源项目..使用新鲜的Kotlin以及Google最经典的MaterialDesign..由于刚开始使用自然会碰到很多坑..上面是我的项目Logo🤣本篇文章重点讲解最经典的MaterialDesign中的抽屉式布局 Navigation Drawer虽然AndroidStudio已经集成了Sample但跟手复现一遍还是很受益的。 在2015年I/O大会上..Google发布了NavigationView，与之前的官方文档相比，本文档更容易创建完整的抽屉式布局随着Android 5.0 Lollipop的发布，新的材料设计风格的抽屉横跨屏幕的整个高度，并显示在ActionBar半透明的上方并重叠StatusBar。Like this： Usage本指南将介绍如何建立一个基于MaterialDesign的可以切换不同Fragment到内容区域的抽屉式导航。In this way,you can define multiple fragments, and then define the list of options which will display in the drawers items list. Each item when clicked will switch the relevant fragment into the activity’s container view. SetupMake sure to setup the Google Design Support Library before using Google’s new NavigationView,announced as part of the Android M release. The NavigationView should be backwards compatible with all versions down to Android 2.1. Make sure you have this Gradle dependency added to your app/build.gradle file:123dependencies &#123; implementation 'com.android.support:design:27.1.1'&#125; Setup Drawer Resources Create a menu/drawer_view.xml file:1234567891011121314151617&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;group android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_first_fragment" android:icon="@drawable/ic_one" android:title="First" /&gt; &lt;item android:id="@+id/nav_second_fragment" android:icon="@drawable/ic_two" android:title="Second" /&gt; &lt;item android:id="@+id/nav_third_fragment" android:icon="@drawable/ic_three" android:title="Third" /&gt; &lt;/group&gt;&lt;/menu&gt; Note that you can set one of these elements to be default selected by using android:checked=&quot;true&quot; . You can also create subheaders too and group elements together: 123456789101112&lt;item android:title="Sub items"&gt; &lt;menu&gt; &lt;group android:checkableBehavior="single"&gt; &lt;item android:icon="@drawable/ic_dashboard" android:title="Sub item 1" /&gt; &lt;item android:icon="@drawable/ic_forum" android:title="Sub item 2" /&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt; Define Fragments接下来，你需要来定义你的Fragments，这些Fragments将会显示在你的Activity中。These can be any support fragments you define within your application. Make sure that all the fragments extend from android.support.v4.app.Fragment. Setup ToolbarIn order to slide our navigation drawer over the ActionBar, we need to use the new Toolbar widget as defined in the AppCompat v21 library.The Toolbar can be embedded into your view hierarchy which makes sure that the drawer slides over the ActionBar. Create a new layout file res/layout/toolbar.xml with the following code:1234567891011&lt;android.support.v7.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/toolbar" android:layout_height="wrap_content" android:layout_width="match_parent" android:fitsSystemWindows="true" android:minHeight="?attr/actionBarSize" app:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" android:background="?attr/colorPrimaryDark"&gt;&lt;/android.support.v7.widget.Toolbar&gt; Note that when the android:fitsSystemWindows attribute is set to true for a view, the view would be laid out as if the StatusBar and the ActionBar were present i.e. the UI on top gets padding enough to not be obscured by the navigation bar. Without this attribute, there is not enough padding factored into consideration for the ToolBar: We want our main content view to have the navigation bar and hence android:fitsSystemWindows is set to true for the Toolbar. To use the Toolbar as an ActionBar, you need to disable the default ActionBar. This can be done by setting the app theme in styles.xml file. 12345678&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="colorPrimary"&gt;#673AB7&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;#512DA8&lt;/item&gt; &lt;item name="colorAccent"&gt;#FF4081&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; Also note that normally you should decide on your color scheme by going to Material Palette and choosing a primary and dark primary color. For this example, we will pick purple-based colors as shown in the screenshot. Note: If you forget to disable the ActionBar in styles.xml, you are likely to see a java.lang.IllegalStateException with an error message that reads This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead.If you see this message, you need to make sure to follow the previous steps. Setup Drawer in ActivityNext, let’s setup a basic navigation drawer based on the following layout file which has the entire drawer setup in res/layout/activity_main.xml. Note that the Toolbar is added as the first child of the main content view by adding the include tag. Note: if you are using a CoordinatorLayout, it must not lie outside of the DrawerLayout. See https://stackoverflow.com/questions/32523188/coordinatorlayout-appbarlayout-navigationdrawer 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- This DrawerLayout has two children at the root --&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!-- This LinearLayout represents the contents of the screen --&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;!-- The ActionBar displayed at the top --&gt; &lt;include layout="@layout/toolbar" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;!-- The main content view where fragments are loaded --&gt; &lt;FrameLayout android:id="@+id/flContent" app:layout_behavior="@string/appbar_scrolling_view_behavior" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/LinearLayout&gt; &lt;!-- The navigation drawer that comes from the left --&gt; &lt;!-- Note that `android:layout_gravity` needs to be set to 'start' --&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nvView" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="start" android:background="@android:color/white" app:menu="@menu/drawer_view" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; Now, let’s setup the drawer in our activity. We can also setup the menu icon too. 123456789101112131415161718192021222324252627282930313233343536373839 public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawer; private Toolbar toolbar; private NavigationView nvDrawer; // Make sure to be using android.support.v7.app.ActionBarDrawerToggle version. // The android.support.v4.app.ActionBarDrawerToggle has been deprecated. private ActionBarDrawerToggle drawerToggle; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Set a Toolbar to replace the ActionBar. toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); // Find our drawer view mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // The action bar home/up action should open or close the drawer. switch (item.getItemId()) &#123; case android.R.id.home: mDrawer.openDrawer(GravityCompat.START); return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; Navigating between Menu ItemsSetup a handler to respond to click events on the navigation elements and swap out the fragment. This can be put into the activity directly: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends AppCompatActivity &#123; // ... @Override protected void onCreate(Bundle savedInstanceState) &#123; // ...From section above... // Find our drawer view nvDrawer = (NavigationView) findViewById(R.id.nvView); // Setup drawer view setupDrawerContent(nvDrawer); &#125; private void setupDrawerContent(NavigationView navigationView) &#123; navigationView.setNavigationItemSelectedListener( new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; selectDrawerItem(menuItem); return true; &#125; &#125;); &#125; public void selectDrawerItem(MenuItem menuItem) &#123; // Create a new fragment and specify the fragment to show based on nav item clicked Fragment fragment = null; Class fragmentClass; switch(menuItem.getItemId()) &#123; case R.id.nav_first_fragment: fragmentClass = FirstFragment.class; break; case R.id.nav_second_fragment: fragmentClass = SecondFragment.class; break; case R.id.nav_third_fragment: fragmentClass = ThirdFragment.class; break; default: fragmentClass = FirstFragment.class; &#125; try &#123; fragment = (Fragment) fragmentClass.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // Insert the fragment by replacing any existing fragment FragmentManager fragmentManager = getSupportFragmentManager(); fragmentManager.beginTransaction().replace(R.id.flContent, fragment).commit(); // Highlight the selected item has been done by NavigationView menuItem.setChecked(true); // Set action bar title setTitle(menuItem.getTitle()); // Close the navigation drawer mDrawer.closeDrawers(); &#125; // ...&#125; Add Navigation Header The NavigationView also accepts a custom attribute that can reference a layout that provides a header of our layout. For instance, you can create a layout/nav_header.xml similar to the following: 1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="192dp" android:background="?attr/colorPrimaryDark" android:padding="16dp" android:theme="@style/ThemeOverlay.AppCompat.Dark" android:orientation="vertical" android:gravity="bottom"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Header" android:textColor="@android:color/white" android:textAppearance="@style/TextAppearance.AppCompat.Body1"/&gt;&lt;/LinearLayout&gt; You would then reference this in the layout res/layout/activity_main.xml in the NavigationView with the app:headerLayout custom attribute: 12345678&lt;!-- res/layout/activity_main.xml --&gt; &lt;!-- The navigation drawer --&gt; &lt;android.support.design.widget.NavigationView ... app:headerLayout="@layout/nav_header"&gt; &lt;/android.support.design.widget.NavigationView&gt; This app:headerLayout inflates the specified layout into the header automatically. This can alternatively be done at runtime with: 123456789// Lookup navigation viewNavigationView navigationView = (NavigationView) findViewById(R.id.nav_draw);// Inflate the header view at runtimeView headerLayout = navigationView.inflateHeaderView(R.layout.nav_header);// We can now look up items within the header if neededImageView ivHeaderPhoto = headerLayout.findViewById(R.id.imageView); Getting references to the headerNote: Version 23.1.0 of the design support library switches NavigationView to using a RecyclerView and causes NPE (null exceptions) on header lookups unless the header is added at runtime. If you need to get a reference to the header, you need to use the new getHeaderView()method introduced in the latest v23.1.1 update: 1234567// There is usually only 1 header view. // Multiple header views can technically be added at runtime.// We can use navigationView.getHeaderCount() to determine the total number.View headerLayout = navigationView.getHeaderView(0); 动画汉堡图标 为了让汉堡包图标动画显示抽屉正在打开和关闭，我们需要使用ActionBarDrawerToggle类。 在你的res/values/strings.xml添加如下内容： 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;string name="drawer_open"&gt;Open navigation drawer&lt;/string&gt; &lt;string name="drawer_close"&gt;Close navigation drawer&lt;/string&gt;&lt;/resources&gt; 我们需要将DrawerLayout和工具栏结合在一起： 1234567891011121314151617181920212223protected void onCreate(Bundle savedInstanceState) &#123; // Set a Toolbar to replace the ActionBar. toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); // Find our drawer view mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout); drawerToggle = setupDrawerToggle(); // Tie DrawerLayout events to the ActionBarToggle mDrawer.addDrawerListener(drawerToggle); &#125; private ActionBarDrawerToggle setupDrawerToggle() &#123; // NOTE: Make sure you pass in a valid toolbar reference. ActionBarDrawToggle() does not require it // and will not render the hamburger icon without it. return new ActionBarDrawerToggle(this, mDrawer, toolbar, R.string.drawer_open, R.string.drawer_close); &#125; 接下来，我们需要确保在恢复屏幕或配置发生变化（即屏幕旋转）时同步状态： 1234567891011121314151617181920212223// `onPostCreate` called when activity start-up is complete after `onStart()`// NOTE 1: Make sure to override the method with only a single `Bundle` argument// Note 2: Make sure you implement the correct `onPostCreate(Bundle savedInstanceState)` method. // There are 2 signatures and only `onPostCreate(Bundle state)` shows the hamburger icon.@Overrideprotected void onPostCreate(Bundle savedInstanceState) &#123; super.onPostCreate(savedInstanceState); // Sync the toggle state after onRestoreInstanceState has occurred. drawerToggle.syncState();&#125;@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); // Pass any configuration change to the drawer toggles drawerToggle.onConfigurationChanged(newConfig);&#125; 我们还需要更改onOptionsItemSelected()方法并允许ActionBarToggle处理事件。 1234567@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; if (drawerToggle.onOptionsItemSelected(item)) &#123; return true; &#125; return super.onOptionsItemSelected(item);&#125; ActionBarToggle将执行与先前完成的功能相同的功能，但会添加更多检查，并允许鼠标​​单击图标以打开和关闭抽屉。有关更多上下文，请参阅源代码。 有一点需要注意的是，ActionBarDrawerToggle会为您呈现汉堡图标的自定义DrawerArrowDrawable。 另外，请确保使用的android.support.v7.app.ActionBarDrawerToggle版本。在android.support.v4.app.ActionBarDrawerToggle已被弃用。 使状态栏半透明 要使状态栏变成半透明状态并让我们的抽屉滑过它，我们需要将其设置android:windowTranslucentStatus为true。由于此样式不适用于之前的Kitkat设备，因此我们将为res/values-v19/styles.xmlAPI版本19及之后的版本添加 文件。 注意：如果res/values/styles.xml直接用此android:windowTranslucentStatus行修改，则可能需要构建仅适用于19或更高版本的SDK，这显然会限制您支持许多较旧的设备。 在res/values-v19/styles.xml我们可以添加以下内容： 1234567&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 现在，如果你运行你的应用程序，你应该看到导航抽屉，并能够在你的片段之间进行选择。 将自定义视图添加到导航抽屉对设计支持库23.1.0所做的一项改进是增加了对导航抽屉项目的自定义视图的支持。例如，我们可以为其中一行创建自定义开关，如Google Play电影的导航抽屉： 该方法与将ActionView项目添加到ActionBar相同。我们只需要定义一个单独的布局，如下面的代码片段。我们将调用这个文件action_view_switch.xml： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.SwitchCompat android:layout_width="fill_parent" android:layout_height="match_parent" android:text="Switch"/&gt;&lt;/LinearLayout&gt; 然后，我们使用该app:actionLayout属性引用此布局。标题必须提供，但也可以设置为空白： 12345&lt;menu xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/nav_switch" app:actionLayout="@layout/action_view_switch" android:title="Downloaded only" /&gt;&lt;/menu&gt; 只要您的活动将实施该方法，您就可以直接使用XML附加事件。要通过Java以编程方式将事件处理添加到切换开关，您需要先获取菜单实例并访问相应的ActionView： 123456789Menu menu = navigationView.getMenu();MenuItem menuItem = menu.findItem(R.id.nav_switch);View actionView = MenuItemCompat.getActionView(menuItem);actionView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 自定义小部件的使用app:actionViewClass也可以用于菜单项目。有关Action Views的更多详细信息，请参阅将SearchView添加到ActionBar指南。 持久导航抽屉在某些情况下，特别是在平板电脑上，导航抽屉应该是充当侧栏的活动的永久固定装置(Like my Blog Design)： 要达到此效果，请查看以下描述一种方法的链接： 静态导航抽屉 相关的Stackoverflow问题 示例代码 第三方库也可能使这更容易实现。 第三方库有一些第三方库仍然可以作为DrawerLayout直接使用自动提供某些材料设计元素的替代方案： MaterialDrawer NavigationDrawerMaterial 通常这些都是不必要的，但请检查它们以查看它们提供的功能。 限制设计支持库的当前版本的确有其局限性。主要问题在于突出显示导航菜单中的当前项目的系统。NavigationView的itemBackground属性不能正确处理项目的选中状态：不管怎样，所有项目都突出显示或者没有任何项目。这使得这个属性基本上不适用于大多数应用程序。 Fragment的替代品虽然许多导航抽屉示例显示了如何将Fragment用于导航抽屉，但如果您希望将抽屉用作当前显示的活动的叠加层，也可以使用RelativeLayout/ LinearLayout。 而不是&lt;FrameLayout&gt;你可以用一个&lt;LinearLayout&gt;替代 1234567891011121314151617181920212223&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/drawer_layout"&gt; &lt;LinearLayout android:id="@+id/content_frame" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;!-- The navigation drawer --&gt; &lt;ListView android:id="@+id/left_drawer" android:layout_width="240dp" android:layout_height="wrap_content" android:layout_gravity="start" android:choiceMode="singleChoice" android:divider="@android:color/transparent" android:dividerHeight="0dp" android:background="#111"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 取而代之的是： 12345// Insert the fragment by replacing any existing fragmentgetFragmentManager().beginTransaction() .replace(R.id.content_frame, fragment) .commit(); 您可以改为使用LinearLayout容器直接为活动充气： 123LayoutInflater inflater = getLayoutInflater();LinearLayout container = (LinearLayout) findViewById(R.id.content_frame);inflater.inflate(R.layout.activity_main, container); References http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html http://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st http://antonioleiva.com/navigation-view/]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验室招新题目①]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[摇篮排序输入摇篮数组以摇篮中的序号为基准进行排序请自定义Bucket的数据结构包括1&#123;&#123;序号&#125;,&#123;学科&#125;&#125; 要求： 写出一个方法 1Bucket[] sortBucket(Bucket[] J,boolean Flag) 返回为排好序后的Bucket数组并在控制台中答应 Flag == true返回正序排序 Flag == false返回倒序排序 面向大一同学要求：在控制台中输入Bucket数组example：input: 1 数学 3 语文 2 英语 trueoutput: 1 数学 2 英语 3 语文 面向大二同学要求：构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮在其中输入Bucket数组example：input: 1 数学 3 语文 2 英语output: 1 数学 2 英语 3 语文]]></content>
      <tags>
        <tag>Lab_Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三年三月三天三小时]]></title>
    <url>%2F2018%2F04%2F27%2F%E4%B8%89%E5%B9%B4%E4%B8%89%E6%9C%88%E4%B8%89%E5%A4%A9%E4%B8%89%E5%B0%8F%E6%97%B6%2F</url>
    <content type="text"><![CDATA[2018.04.26/14:27 👨‍💻我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。-我的价值终于得到了认可…前20年的知识积奠..后3年的专业浅触..以及3个月来的准备..还有近3天以来的焦虑..最终是拿到Offer前3小时的不镇定…也许这种过程正是我踏入社会的开始以及最重要的是可以在我梦寐的大平台上开拓自己的视野强化自己的专业知识…这一切也来源于我3年以来的不懈…但更值得感谢的是我的伯乐–我的专业引路人刘老师和班导严老师在这三年来的照料与解惑…反观我三年前刚入校的木讷与轻浮..到现在可以负责实验室..以及得到社会的认可这一路来没有他们的指引我也许还在自己的混沌中不能自拔… My favorite mural Creazione di Adamo by Michelangelo 我也曾愣头青…在还未准备充分就冲去面试阿里…连续挂掉两次的腾讯面试…以及没有音讯的美团…到现在我心心念的还在等结果的大疆…以及我已拿到实习Offer的爱奇艺… 拿到Offer的我一点也没有激动…只是让我千疮百孔的心得到了一点满足… 在这一路的面试经历中我发现，我最终收益的还是我对专业的坚持…始终没有放弃我热爱的Android移动端开发..当出现新的技术..我总是首先想到应用于移动端…至少这种原力式的驱动来自于我的世界观..我认为在这个时代互联网的最大作用应该是带动人类发展进步..即使如今是个百家合唱的互联网环境..更多的企业选择了推动经济的捞钱式行为…大量的研发资源用于对娱乐或是低俗文化的传播…使得如今都是面向上市敲钟式创业… 异曲同工的是最近在年级群中看到有已面50家公司拿到3个Offer的人却大言不惭的写着面经..教唆想去参加工作的同学若是没有项目去某宝花钱购买…纯粹的面向面试的编程令人感到恶俗…地球科技的进步如果存在很多这样的人简直不堪想象吧… 如今这个时代有点伪文艺复兴的感觉…好像世间很纷乱…不是那么安定…但大家好像还过得自得其乐…这种自杀式的习惯在一点点的吞噬人类心灵最后的进取… 三年 👹大学这三年来其实是憋了一口气的去追赶我高中三年所遗失的种种三年后再看我倒是追回来了一些..这是值得肯定的至少我没有被世俗赶上..至少我暂时赢得了自己的认可 伯乐 🐎 世有伯乐，然后有千里马。千里马常有，而伯乐不常有。我是一个傲慢的自谦的，不易被他人压制的，向往自由的人。 这三年来我真心的感谢我的班导严灵毓老师、我的计算机语言入门人刘伟老师。是他们的慧眼给了我进升的平台。这两位老师的性格迥异对我来说是非常受益的… 其一、那种对学生的关怀与学术上、人生上大义至简的指导与沟通是让我摆脱各种木讷与混沌的唯一绳索。 另一位、那种随性的不羁的帅气的男性风格成为了我对男性理解的标榜…作为我项目指导老师对我的信任，直接影响了我之后对软件产品的看法与理解…将项目大意解释与学生，其他的可以自我发挥的做法，至少目前我没有在其他老师身上发现过…这种对学生的信任同样也是让我辗转各种实验室后最终又回到Lab603的唯一理由… 现在再回头看看这三年…充实又充满回忆… 开发者同伴 😎 如果拿伯牙与钟子期的故事来说我们可能过头..其实我们也没有到那种境界…只是想用这种感觉来表达我这三年来对他的感谢，他与我共同开发了我这三年来的大部分项目… 2016年10月12日 星期三 23:22 张睿在我的宿舍里一起重构项目看到结果后的喜悦 这三年来不下10个大大小小的项目其中2/3都是我和他共同开发的…无数个通宵..无数个需求的争执无数个问题的解决…在这一系列的过程中如果没有这样一个人的存在又会变得有多大的挑战呢？我现在只能说张睿这三年来感谢你的互助，没有你我也走不到这一步…我会在这条路继续走下去的…只为了我们那无数个日夜的单纯的梦。 2016年10月16日 星期日 3:11 我们合作的第一个项目OneKey2Alarm肝通宵 Project ⌨️ 项目之于开发者如同父与子的关系 相信每一个开发者在完成他的Project后都会加倍心力的去维护他的Project…在这过程中也同时是开发者经验能力提升的关键…所以在面试过程中每个开发者在他过去完成的项目质量与数量就显得格外宝贵..通过项目的侧面观察可以看得出一个人的代码风格..他的个性..他的为人…所以如上文所述的那种面向面试的编程方式是我个人非常厌恶的…我认为只要是一个有追求的开发者..一个合格的程序员都十分摒弃这种做法…通过获取他人的劳动成果来打肿脸充胖子..总有一天会败露的。真诚是一个人最美好也是最底线的品质…如果你想让这个世界达到公平那么久应该人人有责…通过不择手段的方式来通过面试这样对更多优秀的项目开发者无异于是一种侮辱…我周围的同学在最近找工作的过程中没有一个人是轻松的…一家家公司一次次的拒绝到让人怀疑自己…但说实话只有内心强大的人才能冲出这片混沌…因为从此之后你就会脱离象牙塔…不会再有人去庇护你…你要面对的是狰狞而残酷的社会..要为自己的言行负责了…人人不易…唯有坚持才能冲破重围… 在这里同时想感谢我未来的部门领导..是他对我的认可..我才直接的得到了这一提升自己视野的机会…我会向自己证明他并没有看错 2018.04 武汉春季Hackthon 2018.04 凌晨4:00 武汉春季Hackthon 2018.04 武汉春季Hackthon 产品展示 家庭 👪 我拥有这样的家庭应该是我人生走过20年所幸至极之事 父母对我的关心与爱护适合且得当 父母对我的放养式管理我称为“不管之恩”这种做法间接的使我自由发展寻我所乐 父母对我的无条件支持我的选择使我受益 生于张先生与陈女士是我这一生无可比拟的幸运 感谢我的父母让我度过了无忧的童年、少年..未来世界的狰狞我已经可以独自去面对了，也请你们放心我永远爱你们❤️ Last but not least 💪通过我一次次的失败..经验的积累..也拿到了如愿的Offer…我明白这并不是标榜着什么..而是又一次新的开始..我这长久以来只是在为自己争取去更好的平台学习..发展…在此想给未来的自己说：不要让你之前的努力白费..保持自己的梦想..不要被世俗侵染..保持学习..保持竞争力..切勿自满… 记一个即将步入社会的男生回首过去20年的狰狞与对自己未来的勉励 Lab603 我的工位 ;-)]]></content>
      <tags>
        <tag>Inspire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java与Kotlin下的6种单例模式]]></title>
    <url>%2F2018%2F04%2F25%2FJava%E4%B8%8EKotlin%E4%B8%8B%E7%9A%846%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 最近在学习Kotlin，由于Google粑粑把这一语言提携为官方指定，并且对于移动端等开发得天独厚的优势，作为一名AndroidDeveloper学习Kotlin是必要的。当初在学习Java时对单例模式的六种书写与应用记忆深刻所以这次对不同单例模式的Java与Kotlin实现进行了分别探讨。 六种模式如下： 饿汉模式 懒汉模式 线程安全的懒汉模式 双重校验锁式 静态内部类式 枚举式 饿汉模式：static final field饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。123456789//Java实现public class Singleton&#123; //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; Kotlin引入了 object类型，可以很容易声明单例模式12//Kotlin实现object Singleton 这种方式和 Java 单例模式的饿汉式一样，不过比 Java 中的实现代码量少很多，其实是个语法糖（Kotlin漫山遍野都是语法糖）。反编译生成的 class 文件后如下： 123456789public final class Singleton &#123; public static final Singleton INSTANCE = null; static &#123; Singleton singleton = new Singleton(); &#125; private Singleton() &#123; INSTANCE = this; &#125;&#125; 从反编译的代码可以看出 object 对象实际上还是利用了 INSTANCE 静态变量，但是在Java和Kotlin混编时，Java代码中调用则需要注意，使用如下Singleton.INSTANCE.test(),Kolint中调用时只需要使用Singleton.test()。这种实现方式在类加载时就创建了单例对象，所以肯定是线程安全的，但是还是有饿汉式实现方式的问题： 如果构造方法中有耗时操作的话，会导致这个类的加载比较慢。 饿汉式一开始就创建实例，但是并没有调用，会造成资源浪费。 还有一个 Java 饿汉式单例模式没有的问题：无法自定义构造函数，object 中不允许 constructor 函数。 懒汉模式：线程不安全懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。1234567891011//Java实现public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton()； &#125; return instance; &#125;&#125; 这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。123456789101112131415//Kotlinclass Singleton private constructor()&#123; companion object&#123; private var instance : Singleton? = null get()&#123; if(field == null)&#123; field = Singleton() &#125; return field &#125; fun get():Singleton&#123; return instance!! &#125; &#125;&#125; 上述代码中，我们可以发现在Kotlin实现中，我们让其主构造函数私有化并自定义了其属性访问器，其余内容大同小异。 如果不清楚Kotlin构造函数的使用方式。请点击 - - - 构造函数 不清楚Kotlin的属性与访问器，请点击 - - -属性和字段 线程安全的懒汉模式为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。1234567891011//Java实现public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton()； &#125; return instance; &#125;&#125; 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。12345678910111213141516//Kotlinclass Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null get() &#123; if (field == null) &#123; field = Singleton() &#125; return field &#125; @Synchronized fun get(): Singleton&#123; return instance!! &#125; &#125;&#125; 大家都知道在使用懒汉式会出现线程安全的问题，需要使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加 @Synchronized 注解 双重校验锁式双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。12345678910111213141516171819202122//Java实现public class Singleton&#123; /** * volatile保证了： * 1.instance再多线程下的并发可见性 * 2.禁止instance在操作时的指令重排序 */ private volatile static Singleton instance = null; public static Singleton getIntance()&#123; //第一次判空，保证不必要的同步 if(instance == null)&#123; //synchronized对Singleton加全局锁，保证每次只要一个线程创建实例 synchronized(Singleton.class)&#123; //第二次判空时为了在null的情况下创建实例 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。 从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。12345678//Kotlin实现class Singleton private constructor()&#123; companion object&#123; val instance: Singleton by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123; SingletonDemo() &#125; &#125;&#125; 哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的延迟属性 Lazy。 Lazy是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。 这里还有有两个额外的知识点。 高阶函数 委托属性 如果你了解以上知识点，我们直接来看Lazy的内部实现。 Lazy内部实现 123456public fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; = when (mode) &#123; LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer) LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer) LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer) &#125; 观察上述代码，因为我们传入的mode = LazyThreadSafetyMode.SYNCHRONIZED， 那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。 Lazy接口 SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下： 1234567public interface Lazy&lt;out T&gt; &#123; //当前实例化对象，一旦实例化后，该对象不会再改变 public val value: T //返回true表示，已经延迟实例化过了，false 表示，没有被实例化， //一旦方法返回true，该方法会一直返回true,且不会再继续实例化 public fun isInitialized(): Boolean&#125; 继续查看SynchronizedLazyImpl，具体实现如下： SynchronizedLazyImpl内部实现 123456789101112131415161718192021222324252627282930private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123; private var initializer: (() -&gt; T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this override val value: T get() &#123; val _v1 = _value //判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑 if (_v1 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") return _v1 as T &#125; return synchronized(lock) &#123; val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") (_v2 as T) &#125; else &#123; val typedValue = initializer!!()//调用高级函数获取其返回值 _value = typedValue //将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值 initializer = null typedValue &#125; &#125; &#125; //省略部分代码&#125; 通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。 到里这里其实大家还是肯定有疑问，我这里只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢？。这里又涉及到了委托属性。 委托属性语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。 而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。 123@kotlin.internal.InlineOnly//返回初始化的值。public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value 静态内部类式这种方法也是《Effective Java》上所推荐的。12345678910//Java实现public class Singleton&#123; private static class SingletonHolder&#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton()&#123;&#125; public static final Singleton getInstance()&#123; return SingletonHolder.INSTANCE; &#125;&#125; 这种写法仍然使用JVM本身机制保证了线程安全的问题。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将内部类SingletonHodler，在该内部类中定义了一个static类型的变量INSTANCE，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 由于SingletonHodler是私有的，除了getInstance()之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。123456789//Kotlin实现class Singleton private constructor() &#123; companion object &#123; val instance = SingletonHolder.holder &#125; private object SingletonHolder &#123; val holder= Singleton() &#125;&#125; 枚举式：Enum用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。 1234//Java实现public enum EasySingleton&#123; INSTANCE;&#125; 我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。1234//Kotlin实现enum class EasySingleton&#123; INSTANCE;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次呆若木鸡的面试]]></title>
    <url>%2F2018%2F04%2F24%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%91%86%E8%8B%A5%E6%9C%A8%E9%B8%A1%E7%9A%84%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[记录一道很简单很简单的入门题…核心就是一个我高中就学过的数学知识…叉积…可惜年久不用…在面试的紧要关头就显得呆若木鸡…很遗憾没有表现出自己的真实水平… /* * * 在一个平面中.任意一个直线线段可以由2个点表示,任意一个点可以由X,Y坐标值表示. *例如线段 J 由 点A(x1, y1), B(x2, y2)表示. 其中坐标值 x,y 都为int. *求写出一个方法, boolean checkIntersect(Line J, Line K); *检查在平面中给出的2个线段是否相交, return true 代表线段相交, false 为不想交. *请自行定义线段Line的数据结构, 并可以假设传入参数Line J 和 Line K 为有效输入. */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package aiqyInterview;public class CheckIntersect &#123; /** * * @author EdwardZhang * 判断线段相交： * 两个线段的交点个数可能有0个 1个或者无数个 * 判断两个线段相交，可以按照如下步骤： * 判断A点B点是否在线段CD的两侧，即计算叉积时异号 * 判断C点和D点是否在线段AB的两侧，即计算叉积时异号 * 然后在处理特殊情况，即ABCD四个点有至少三个点共线的情况， * 即出现叉积为零的情况，如果A点与线段CD共线， * 则要查看A点是否在线段CD上，其它情况依次类推。 */ class Point &#123; int x; int y; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; &#125; class Line &#123; Point A = new Point(); Point B = new Point(); public Point getA() &#123; return A; &#125; public void setA(int i, int j) &#123; A.x = i; A.y = j; &#125; public Point getB() &#123; return B; &#125; public void setB(int i, int j) &#123; B.x = i; B.y = j; &#125; &#125; public static float direct(Point i, Point j, Point k) &#123; // 计算叉积 return (k.x - i.x) * (j.y - i.y) - (j.x - i.x) * (k.y - i.y); &#125; public static boolean onSegment(Point a, Point b, Point c) &#123; // 共线时，判断点是否落在线段 float minx = Math.min(a.x, b.x); float maxx = Math.max(a.x, b.x); float miny = Math.min(a.y, b.y); float maxy = Math.max(a.y, b.y); if (c.x &gt;= minx &amp;&amp; c.x &lt;= maxx &amp;&amp; c.y &gt;= miny &amp;&amp; c.y &lt;= maxy) &#123; return true; &#125; return false; &#125; public static boolean checkIntersect(Line X, Line Y) &#123; float d1 = direct(Y.A, Y.B, X.A); float d2 = direct(Y.A, Y.B, X.B); float d3 = direct(X.A, X.B, Y.A); float d4 = direct(X.A, X.B, Y.B); if (d1 * d2 &lt; 0 &amp;&amp; d3 * d4 &lt; 0) return true; else if (d1 == 0 &amp;&amp; onSegment(Y.A, Y.B, X.A)) return true; else if (d2 == 0 &amp;&amp; onSegment(Y.A, Y.B, X.B)) return true; else if (d3 == 0 &amp;&amp; onSegment(X.A, X.B, Y.A)) return true; else if (d4 == 0 &amp;&amp; onSegment(X.A, X.B, Y.B)) return true; return false; &#125; public static void main(String[] args) &#123; CheckIntersect checkIntersect = new CheckIntersect(); Line a = checkIntersect.new Line(); Line b = checkIntersect.new Line(); a.setA(0, 0); a.setB(2, 2); b.setA(2, 0); b.setB(0, 2); System.out.println(checkIntersect(a,b));//相交 true a.setA(0, 0); a.setB(2, 2); b.setA(2, 0); b.setB(1, 0); System.out.println(checkIntersect(a,b));//相离 false a.setA(0, 0); a.setB(2, 2); b.setA(2, 0); b.setB(4, 2); System.out.println(checkIntersect(a,b));//平行 false a.setA(0, 0); a.setB(2, 2); b.setA(1, 1); b.setB(3, 3); System.out.println(checkIntersect(a,b));//在一条直线上 true &#125;&#125;]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Inspire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系应届生求职指北]]></title>
    <url>%2F2018%2F04%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%BA%94%E5%B1%8A%E7%94%9F%E6%B1%82%E8%81%8C%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[今天早晨看到了Easy大大的这篇文章，在文章中读到了自己的影子，并且也明白了这段时间自己在实习招聘中的不足，受益匪浅。希望我的好友可以看到从中受益特此转载 From：https://github.com/easychen/career-guide-for-cs-graduate 计算机系应届生求职指北最近帮了一个朋友的朋友做了下职业规划，结合之前在微博上的一些问答，觉得不少应届生同学对求职有蛮多误解的，所以这里分享下我的一点经验吧。虽然本文题为指北，但只是一个面向对行业、对业界技术不熟悉的同学的操作手册。各位技术大牛可能觉得粗浅，请见谅。 本文略长，会谈及以下问题。 职业规划越早越好 一定要珍惜校招的机会窗口 应届生的求职策略 技术职位的选择 语言和技术栈的选择 技术栈的优化 简历的书写 下边我们一点一点来讲。 本文作者 @Easy （ weibo.com/easy ），方糖全栈课（ quanzhanke.com ）主讲人，有多年大规模网站、云平台开发经验、曾运营过用户数十万的程序员拍卖平台，为上千名程序员找过工作。转载请保留以上作者信息和链接，谢谢。 内容更新通知 可微信扫码（未关注直接关注）订阅本指北更新。 职业规划越早越好职业是一个非常特殊的东西，它有两点很特别，一个是「不可重来」，另一个是「验证耗时」。之前和一个老友聊天，他感叹说，回过头看看，自己的整个职业过得乱七八糟。等到现在明白这点的时候，已经来不及了。因为一般一段职业经历短则一到两年，长则三到五年。换两家公司，十年一晃就过去了。如果你在这十年中没有很好的成长，又不幸身在某些公司，那三十多岁可能就面临被清退的处境了。 我一般不屑于去和别人分享什么人生经验，毕竟有些坑不自己跳下去是不会牢记在心的。但职业的坑不一样，等你发现在坑里时，可能已经晚了。所以我花了蛮多时间来研究这个。有兴趣的同学可以去读读我的《程序员跳槽全攻略》，专门讲职业规划的。( 在我的个人网站上可以免费读 方糖气球🎈|程序员跳槽全攻略 ) 一定要珍惜校招的机会窗口我大学的语文老师曾告诫我们说，人生就像四季一样，春天该播种，你去播种，秋天该收获，你去收获，这样是最省力的。你非要倒过来呢，也不是不行，但就是会很累，会付出更多的精力和代价。 校招也类似，它是社会和企业为从未步入职场的同学特意准备的一个绿色通道。在这个通道里，我们将候选人当做一张白纸，可以没有经验、没有行业常识，只要对工作充满热情、有还算聪明的头脑，基本都算是合格的。企业会为这些同学准备培训，并留足适应期，有的甚至还会安排一对一的老员工来带。 但是，一旦你错过了它，那一切都不一样了，因为你进入了名为「社招」的红海。在这里，所有已经毕业的人变成了你的竞争对手，不但要面对和你一样工作年限的人竞争，还要面对其他工作时间更长、经验更丰富的同行跳槽带来的竞争。甚至经常发生因为招到了一个中级岗位的候选人，取消掉两个初级岗位的情况。 所以校招非常重要，一定不要错过。 应届生的求职策略既然校招这么重要，那么我们怎么才能在其中占据优势呢？记住两个词「择优录取」和「跑赢同学」。 择优录取在微博上经常可以看到这样的问题：「我这个也会、那个也合格，凭什么他们就不招我呢？」这是典型的没有明白招聘本质的表现。要明白，求职不是「会考」而是「高考」，不是什么产品的出厂合格校验，而是一场中国这个资源紧缺型国家里的又一场优质资源争夺战。 那些薪水高、发展空间好的知名企业（后文简称大厂），每年招聘的人数是一定的。极端点说，如果现在所有候选人的水平都下调20%，他们依然要招人的，不然没法发展（严格讲会有一些调整空间，但也扛不了多久）。 所以，尤其是在校招里边，「绝对值」并不重要，「相对值」才是最重要的。 跑赢同学我来讲一个很老的童话，听过的同学请装作没听过。两个人在森林里边遇到了熊🐻，kuma 看见他们就嗷嗷的追了过来。一个同学转身就跑，另一个问他说，我们怎么跑也跑不过熊的，那跑有什么用呢？这个同学回答说，我只要跑赢你就好了呀。 那其实校招也是一样的。它不是说你的能力要有多少，其实再牛的应届生的水平放到行业里边，都是不入流的，因为很多水平是靠海量的用户压出来的，你没有遇到过这些场景，怎么可能知道怎么去应对。 所以应届生和那些社招的候选人比，通常都是没啥胜算的，但幸运的是，我们和他们是不同的赛道。要跑赢一个在大厂核心岗位工作了一两年的人不容易，但要跑赢那些和你一样在大学只学了一堆理论基础，甚至理论课都没好好学天天在寝室吃鸡的同学，就容易很多了。 要承认，即使这样，要跑赢某些天资聪颖、能力拔群的学霸还是有难度的。但这场比赛是不公平的，因为它没规定每个人必须同时开始跑。鲁迅说得好，笨鸟先飞。（鲁迅：我没有说过）如果我们能更早的认识到这点，花更多时间去准备，那么赢的概率就会成倍提升。 我本身就是一个非常好的例子。严格的讲，我的能力算是平庸偏上一点点的，虽然在当时无论如何我都不会承认。当我在大一下半期认识到这一点时，就开始自学 PHP，大二的时候写了一堆没人用的开源项目，大三上半期找了家公司做兼职，已经能把学费挣回来了。当大三下半期开始找实习时，我的简历已经可以秒杀同校同学，小小PK 一流高校的同学了。 所以你以为校招比的是能力，其实对于执行力中等、同样天赋的同学来讲，校招比的其实是认知。越早认识到本质的人，就越容易在这场游戏里边胜出。从这个角度讲，坚持读到这里的你，甚至可能已经赢了一半了。所以记得要把这篇文章分享给你的好朋友，然后千万别让你不喜欢的同学知道。 技术岗位的选择技术岗位的大体分布如图： 现在几乎所有的软件都已经互联网化了，就算没有互联网化的，它以后也会互联网化，所以我们就不单纯地去说软件开发这个行业了。 开发岗首先就是开发岗，这个就包括了前端开发、后端开发和移动开发。 前端开发和后端开发，主要是 B/S 结构里的。B/S 结构就是 Browser-Server 结构。而前端指的就是浏览器这个端；后端指的就是服务器这个端。 前端前端主要做的事情，就是把从服务器端读取到的数据展现给用户，然后通过各种 UI 控件和用户互动，再将新的数据送回服务器端。具体的技术包括 HTML、CSS、JavaScript，还可能有一些嵌入浏览器运行的组件，比如 Flash 、 WebGL 。 后端后端则主要送数据给前端，一般有两种方式，以前用的比较多的是，将数据在服务器端先渲染完，然后将输出的结果发送给前端；现在用的比较多的方式是将纯数据通过 Json 或者 xml 等格式发送给前端，在浏览器中通过 JS 来进行渲染。 所以以前很多后端的工程师往往也懂一些前端的知识，比如我认识的很多 PHP 程序员，他们不但懂 MySQL 和 Apache，还懂 HTML 、 CSS 、 JS 和 PS。这种前后端都懂的工程师，也叫全栈工程师。 后端可以用各种语言开发，国内用的比较多的包括 Java、PHP ，还有相对小众一些的 Python 、 Ruby 、 Go。其实 C 也是可以写后端的，不过现在已经很少有公司直接用它写了。 后来有了 NodeJS ，JavaScript 也能跑到后端了，所以很多前端工程师也有了后端开发的能力，他们也占了全栈工程师的很大一部分。 客户端相对于 B/S 结构，还有 C/S 结构，就是 Client-Server 。C/S 结构下不用浏览器来展现数据和交互，而是用客户端，一般是 Mac/Win/Linux 三大平台。 移动端手机大潮起来以后，不管是 B/S 结构还是 C/S 结构，全部移动化了。B/S 结构对应的就是适配手机浏览器的移动网页、以及嵌入在微信、微博里边的 H5 页面; C/S 结构就是 APP ，一般覆盖 iOS 和 Android 两个主流平台。 除了这些标准开发岗，而还有一些新兴或者相对小众的开发方向，比如人工智能/算法工程师、做智能硬件的硬件开发工程师、给企业做解决方案的企业软件工程师。 其他岗位软件并不是开发出来就完了的，在上线或者发布之前，我们还需要「测试工程师」来进行测试；而上线以后，还需要「运维工程师」来管理和优化服务器集群。现在服务器都虚拟化和容器化了，运维工程师中也出现了懂开发的分支，叫做 DevOps。 中高级岗位不管是开发岗还是测试、运维岗，都有其对应的中高级岗位。开发一般是技术经理；运维一般是架构师；测试一般是测试总监。技术总监、CTO 就是更高一级的职位了。 以上的职位分类我们参考了招聘网站的分类，不一定准确，可能会有很多岗位没覆盖到，不少公司也会有自己独特的岗位设置。 职位的选择如果能选择的话，不建议一开始就选运维或者测试。原因有两个：第一，因为它们虽然很重要，但不是软件开发的核心岗位。第二，从开发岗往这两个职位转非常容易，反之却非常难。 之前在给掘金写《程序员职业小白书》的时候，我做过一个邮件访谈，以问题的形式采访了多位在不同阶段、不同岗位、不同城市的程序员的日常。大家可以读一读，了解下。程序员们的日常是怎样的 （虽然这个小册是收费的，但访谈这一章却是可以免费读的，不需要购买哈） 语言和技术栈的选择语言概况虽然出于某种政治正确，我们一般都会说，语言不重要。但语言真的不重要么？并不是这样的，每种语言都有自己的优缺点和适用范围。 像日语和英语一样，一个是看动画玩游戏用的，一个是看资料写代码用的。（误）下边简单介绍下我眼中的各个语言。 C/C++ ：系统语言，用来写底层操作系统、高性能中间件和嵌入式开发。 Python：人工智能的好选择举例来说，如果你想做人工智能方向的话，Python语言就是非常不错的选择。因为它在各个大学和研究机构用的非常多，有成熟好用的数学库，适合于科学计算。在深度学习等热门方向上，有大量用 Python 开发的框架，新出的 Paper 也能很快在 GitHub 上找到 Python 的代码实现，可以说是不二选择了。 JavaScript：前端和全端如果你想做前端，那么目前来看，除了 JavaScript 还真没有别的选择，因为现在能在浏览器里边跑起来，也就是它了。过两年等 wasm 成熟可能会有其他选择，但现在，是真没有。 而相应的，如果你学会了 JavaScript ，想在这个基础上再把后端给做了，那么 Node.JS 就是非常好的选择。因为它使用的就是 JavaScript 的解释器，按 JavaScript 写就好了。从学习成本上来讲，它是非常低的，可以通过很低的投入，就进入了服务器端的领域。 PHP：依然是网站首选如果你要做网站，那么 PHP 就是首选了。一方面是有大量的可用代码，世界上超过80%的网站都用的 PHP，基本上你能想到的网站功能，都有能找到的实现，悬念只是有没有免费的；另一方面，PHP7 的性能提升了很多，用来写 API 也非常好。 另外一点，就是目前使用 PHP 的团队非常多，即使在二三线城市也比较容易找到工作，当然，组建团队也同样相对容易。 Java：大数据分析如果你要做大数据分析，那么可能就离不开 Java 了。从 Hadoop 开始一系列的 Google Big Table 的开源实现都是 Java 的，用于海量数据搜索的 Elastic Stack 也是 Java 的。 Go：云计算和容器管理如果你现在要想去做云计算，那 Go 就是一个非常好的选择。 因为它就是为了大规模计算设计的，并发管理和性能都非常不错。而且有很多云计算的软件，它就是 Go 写的，如果你要去修改它，调整里边的实现逻辑的话，不会 Go 可能很麻烦。当然，理论上讲，你也可以通过容器和微服务的方式来搞定，但肯定比直接改代码麻烦。 另外区块链的大热平台以太坊的官方（最具潜力）实现，也是Go做的。钱途大大的。 语言的选择兴趣优先在语言的选择上，尤其是第一门语言的选择上，我一直推荐兴趣优先的原则。因为对初学者而言，当你遇到困难坚持不下去时，兴趣会帮你一把。中学时为了改仙剑，我连汇编都试着学了个入门 🤣 市场其次但其实对绝大部分应届生而言，对各种语言并没有特别的偏好。而且「找到工作」这件事是非常重要的。所以与其盲目的选择语言学习不如来看看各个语言在招聘市场的表现。 我之前写过一个脚本，可以抓取几个互联网招聘大站的招聘启事，并按职位对薪资进行统计。下边是最近一周的统计结果。 先来说说这些数据怎么看。 职位热度类似于招聘职位数，和其他语言对比就能看出差距。平均薪资之所有有两个值，是因为我们一般招聘时会给出薪资的上限和下限。严格的讲，这并不是当前某个语言的程序员们的薪资，而是他们下一次跳槽时的可能薪资。另外，部分企业喜欢在上限值上边虚高，所以把上限乘80%可能更合理。而下限一般比较真实，更具备对比价值。 然后我们来看看能发现什么。 Java 的数据非常牛首先我们会发现，Java 的职位热度非常高，几乎在所有城市里边都是排名第一的。这里有一个特殊原因，就是 Android 职位基本也是使用 Java 语言进行开发的，所以这两个职位有一些重叠。也就是说，学好 Java 其实可以同时应聘 Java工程师 和 Android 工程师（可能需要额外在学一点点应用开发的知识），这非常划算。而从薪资方面看，Java 也是数一数二的。 前端紧跟其后紧随其后的是前端职位。前端是个非常有意思的特点，那就是——几乎所有的公司都会招前端。对比 Java 而言，可能有很多大厂的后端用的不是 Java ，那他们就不需要招聘 Java 工程师。如果你非常想去这家公司，但你会的语言是 Java ，那么就可能和机会擦肩而过。而前端岗位的话，机会就可能大得多。这有点像血型里边的O型血，怎么地方都能用。就算是自以为站在食物链顶端鄙视「古典互联网」的区块链公司也不得不招前端呢，也是一个非常好的选择。 除了看热度，我们也要考虑到竞争，比如 Java 是一个「传统」岗，很多软件行业的工程师也是会 Java 的。而「前端」是一个新兴的互联网岗，专业前端还不算太多（和 Java 比啦），所以入职难度说不定反而低一些。 其他语言其他语言在各个城市的数据各不相同，大家可以挑自己感兴趣的看。比如 Go 语言在北京比其他城市热几倍；区块链虽然看起来很火，但其实职位数也就比 PHP 的一半多点；Ruby 虽然薪资不错，但岗位非常少… 总之语言的选择因人而异因时而异，请综合各种视角去选择一个适合自己的。 学习路线图在选择好职位和语言后，就要寻找对应的学习路线图进行学习了。这里推荐这个 Star 数量超过4万的路线图（的中文版）：GitHub - goodjack/developer-roadmap-chinese: 2018 年成為 Web 開發人員的路線圖 虽然不是很全，但细节不错。 前端路线图 后端路线图 DevOPs路线图 技术栈的优化之前我们在分析 Java 数据的时候，发现一个有意思的问题，那就是 Java 的技术栈可以同时覆盖两个热门职位 —— Java 和 Android，这让我们的求职竞争力一下翻了一倍。那么在其他的语言和岗位上还存不存在类似的情况呢？ 其实是有的，比如前端岗位就是一个非常有潜力的例子，它的后端解决方案 NodeJS 正在日益流行 。在我写这篇文章的时候，互联网招聘大站 拉勾网 上北京的 NodeJS 职位数是 181，上海是 114，深圳是 65 。所以学完前端知识再补一下 NodeJS 的收益是不错的。 但这个技术栈其实还可以进一步优化，因为一个偶然的原因，我统计了一下 PHP 岗位和前端岗位招聘启事里边出现的技术关键词，发现其重合度竟然高于60%。具体的技术关键词和热度见这里 《PHP&amp;前端岗（1~3年）核心技术点分析报告》 回头一想其实也很好理解，毕竟招 PHP 是来做网站的，HTML CSS JS 总得会一些才行。这意味着PHP的同学只需要补上部分前端知识，比如主流框架 React / Vue / Angular 和 SPA 开发就可以同时应聘 PHP 和 前端 职位。 这会有多大的竞争力呢？前端招聘启事里边，有超过十分之一的企业提及了PHP。这还没完，React 有一个混合应用解决方案，叫做 React Native，可以直接用 React 栈来开发手机APP。这个技术的需求如何呢？现在拉勾网上北京的 React Native 相关职位数有 84 。 于是呢，我们可以选择 PHP + React + React Native 的技术栈，仅仅多学习一点知识，可以投递的岗位就从原来的 364 变成了 364 + 373 + 84 。 这就是技术栈优化的策略。关于这个技术栈的优化结构，可以看这里 《方糖全栈学习路线图》，这个栈还顺便把区块链应用开发也覆盖了。大家可以举一反三，去优化自己选中的技术栈。 简历的写作不要最后找工作的时候再来写简历。现在就开始写，即使你什么都不会。这样你才会真切的感受到，自己的缺点和劣势。然后通过不断的学习，往简历上追加新的内容，直到你自己看起来觉得有竞争力了，简历才算阶段性完成了。 关于简历的写作技巧和工具，我之前写过一篇文章详细说明，可以点这里阅读 《如何写出一份专业的技术简历》 （这篇文章本身依然是免费的，不用购买小册就能读） 写在最后( 由于V站上某些同学的疑惑，这里我也补充一下吧。学好基础知识是必须的，这是最基本的，如果这些地方你都丢分了，这些技巧就都白费了 ) ( 刷题库是面试必须的，但只刷题库就舍本逐末了，实践驱动的学习会让你对基础的理解更深入，虽然辛苦点。顺便po一个题库网站 [nowcoder]https://www.nowcoder.com/ ) 不知不觉已经写了这么多了，其实还有一些内容想说，但暂时就不写到这里了。 等以后有空我再整理一个小册子吧。我把文章也同时发布到了 GitHub，以后的更新会通过 GitHub 进行，欢迎 watch 和 star 。https://github.com/easychen/career-guide-for-cs-graduate PS：如果你还不知道怎么用 GitHub，那么赶紧学学吧，这可是程序员的必备（交友）工具哦。]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Inspire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络编程面试题集]]></title>
    <url>%2F2018%2F04%2F17%2FAndroid%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章Fork from android-interview 网络编程TCP与UDP有什么区别？ TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 TCP首部开销20字节;UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 简单介绍一下TCP三次握手与四次分手过程？TCP用三次握手（three-way handshake）过程创建一个连接，使用四次分手关闭一个连接。 三次握手与四次分手的流程如下所示： 三次握手 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。 四次分手 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 三次握手与四次分手也是个老生常谈的概念，举个简单的例子说明一下。 三次握手 例如你小时候出去玩，经常玩忘了回家吃饭。你妈妈也经常过来喊你。如果你没有走远，在门口的小土堆上玩泥巴，你妈妈会喊：”小新，回家吃饭了”。你听到后会回应：”知道了，一会就回去”。妈妈听到你的回应后又说：”快点回来，饭要凉了”。这样你妈妈和你就完成了三次握手的过程。😁说到这里你也可以理解三次握手的必要性，少了其中一个环节，另一方就会陷入等待之中。 三次握手的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误. 四次分手 例如偶像言情剧干净利落的分手，女主对男主说：我们分手吧🙄，男主说：分就分吧😰。女主说：你果然是不爱我了，你只知道让我多喝热水🙄。男主说：事到如今也没什么好说的了，祝你幸福🙃。四次分手完成。说到这里你可以理解了四次分手的必要性，第一次是女方（客户端）提出分手，第二次是男主（服务端）同意女主分手，第三次是女主确定男主不再爱她，也同意男主分手。第四次两人彻底拜拜（断开连接）。 因为TCP是全双工模式，所以四次分手的目的就是为了可靠地关闭连接。 TCP如何保证数据传输的可靠性？ 确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。 数据校验。 数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。 流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。 拥塞控制：当网络发生拥塞时，减少数据的发送。 HTTP与HTTPS有什么区别？ HTTPS是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 如下图所示，可以很明显的看出两个的区别： 注：TLS是SSL的升级替代版，具体发展历史可以参考传输层安全性协议。 HTTP与HTTPS在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来： 如果URL的协议是HTTP，则客户端会打开一条到服务端端口80（默认）的连接，并向其发送老的HTTP请求。 如果URL的协议是HTTPS，则客户端会打开一条到服务端端口443（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的HTTP请求。 所以你可以看到，HTTPS比HTTP多了一层与SSL的连接，这也就是客户端与服务端SSL握手的过程，整个过程主要完成以下工作： 交换协议版本号 选择一个两端都了解的密码 对两端的身份进行认证 生成临时的会话密钥，以便加密信道。 SSL握手是一个相对比较复杂的过程，更多关于SSL握手的过程细节可以参考TLS/SSL握手过程 SSL/TSL的常见开源实现是OpenSSL，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。更多源于OpenSSL的技术细节可以参考OpenSSL。 谈一谈对HTTP缓存的理解？HTTP的缓存机制也是依赖于请求和响应header里的参数类实现的，最终响应式从缓存中去，还是从服务端重新拉取，HTTP的缓存机制的流程如下所示： 👉 点击图片查看大图 HTTP的缓存可以分为两种： 强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。 对比缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。 强制缓存优先于对比缓存。 上面提到强制缓存使用的的两个标识： Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。 Cache-Control：Expires有个时间校验的问题，所有HTTP1.1采用Cache-Control替代Expires。 Cache-Control的取值有以下几种： private: 客户端可以缓存。 public: 客户端和代理服务器都可缓存。 max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据。 no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发。 我们再来看看对比缓存的两个标识： Last-Modified/If-Modified-Since Last-Modified 表示资源上次修改的时间。 当客户端发送第一次请求时，服务端返回资源上次修改的时间： 1Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT 客户端再次发送，会在header里携带If-Modified-Since。将上次服务端返回的资源时间上传给服务端。 1If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT 服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改，则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存。 上面是一种时间戳标记资源是否修改的方法，还有一种资源标识码ETag的方式来标记是否修改，如果标识码发生改变，则说明资源已经被修改，ETag优先级高于Last-Modified。 Etag/If-None-Match ETag是资源文件的一种标识码，当客户端发送第一次请求时，服务端会返回当前资源的标识码： 1ETag: "5694c7ef-24dc" 客户端再次发送，会在header里携带上次服务端返回的资源标识码： 1If-None-Match:"5694c7ef-24dc" 服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较，如果不同，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回304，客户端可以继续使用缓存。 HTTPS是如何保证安全的，证书如何校验？HTTP如何实现长连接？]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议复习]]></title>
    <url>%2F2018%2F04%2F16%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[奇迹般的腾讯笔试通过了，昨天下午经过了一面…发现之前着眼于Android与Java的知识而没有对计算机网络系统的复习…导致了这次面试的滑铁卢…所以想进这样的一线大厂做一名合格的程序员还是要全面发展…不能顾此失彼 Http协议 默认端口：80 Http协议的主要特点 支持客户／服务器模式 简单快速：客户向服务端请求服务时，只需传送请求方式和路径。 灵活：允许传输任意类型的数据对象。由Content-Type加以标记。 无连接：每次响应一个请求，响应完成以后就断开连接。 无状态：服务器不保存浏览器的任何信息。每次提交的请求之间没有关联。 非持续性和持续性 HTTP1.0默认非持续性；HTTP1.1默认持续性 持续性浏览器和服务器建立TCP连接后，可以请求多个对象 非持续性浏览器和服务器建立TCP连接后，只能请求一个对象 非流水线和流水线 类似于组成里面的流水操作 流水线：不必等到收到服务器的回应就发送下一个报文。 非流水线：发出一个报文，等到响应，再发下一个报文。类似TCP。 POST和GET的区别 Post一般用于更新或者添加资源信息 Get一般用于查询操作，而且应该是安全和幂等的 Post更加安全 Get会把请求的信息放到URL的后面 Post传输量一般无大小限制 Get不能大于2KB Post执行效率低 Get执行效率略高 为什么POST效率低，Get效率高 Get将参数拼成URL,放到header消息头里传递 Post直接以键值对的形式放到消息体中传递。 但两者的效率差距很小很小 Https 端口号是443 是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议。 Socket 使用TCP 客户端 1234567Socket socket = new Socket(&quot;ip&quot;, 端口);InputStream is = socket.getInputStream();DataInputStream dis = new DataInputStream(is);OutputStream os = socket.getOutputStream();DataInputStream dos = new DataOutputStream(os); 服务器端 123ServerSocket serverSocket = new ServerSocket(端口);Socket socket = serverSocket.accept();//获取流的方式与客户端一样 读取输入流 123456789byte[] buffer = new byte[1024]; do&#123; int count = is.read(buffer); if(count &lt;= 0)&#123; break; &#125; else&#123; // 对buffer保存或者做些其他操作 &#125; &#125;while(true); 使用UDP客户端和服务器端一样的 123456789DatagramSocket socket = new DatagramSocket(端口);InetAddress serverAddress = InetAddress.getbyName(&quot;ip&quot;);//发送DatagramPackage packet = new DatagramPacket(buffer, length, host, port);socket.send(packet);//接收byte[] buf = new byte[1024];DatagramPacket packet = new DatagramPacket(buf, 1024);Socket.receive(packet); TCP与UDP 面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。 TCP协议 Transmission Control Protocol，传输控制协议 面向连接的协议 需要三次握手建立连接 需要四次挥手断开连接 TCP报头最小长度：20字节 三次握手的过程： 客户端发送：SYN = 1, SEQ = X, 端口号 服务器回复：SYN = 1, ack = X + 1, SEQ = Y，ACK = 1 客户端发送：ack = Y + 1, SEQ = X + 1,ACK = 1 SYN – 建立连接位 ACK – 响应位 SEQ – 顺序号码 ack – 确认号 确认应答信号ACK = 收到的SEQ + 1。连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。 第一次握手：主机A发送位码为SYN = 1，随机产生SEQ = 1234567的数据包到服务器，主机B由SYN = 1知道，A要建立联机 第二次握手：主机B收到请求后要确认联机信息，向A发送ACK = （主机A的SEQ+1），SYN = 1，ack = 1，随机产生SEQ = 3452671的包； 第三次握手：主机A收到后检查ack是否正确，即第一次发送的（SEQ+1），以及位码ACK是否为1，若正确，主机A会再发送ack = （主机B的SEQ+1），ACK = 1，主机B收到后确认SEQ值与ACK = 1则连接建立成功。 四次挥手过程 A向B提出停止连接请求，FIN = 1 B收到，ACK = 1 B向A提出停止连接请求，FIN = 1 A收到，ACK = 1 FIN – 关闭连接 SYN – 建立连接位 ACK – 响应位 SEQ – 顺序号码 ack – 确认号优点： 可靠，稳定1、传递数据前，会有三次握手建立连接 2、传递数据时，有确认、窗口、重传、拥塞控制 3、传递数据后，会断开连接节省系统资源 缺点： 传输慢，效率低，占用系统资源高1、传递数据前，建立连接需要耗时2、传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源 易被攻击1、因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击 如何保证接收的顺序性： TCP协议使用SEQ和ACK机制保证了顺序性TCP的每个报文都是有序号的。确认应答信号ACK=收到的SEQ+1 【注意】中断连接端可以是Client端，也可以是Server端。 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 整个过程Client端所经历的状态如下： 而Server端所经历的过程如下： 【注意】 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。 UDP协议 User Data Protocol，用户数据包协议 面向无连接的协议 UDP报头只有8字节 简介： 传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息 UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制 UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。 UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。 使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 优点： 传输速率快1、传输数据前，不需要像TCP一样建立连接2、传输数据时，没有确认、窗口、重传、拥塞控制等机制 较安全1、由于没有了TCP的一些机制，被攻击者利用的漏洞就少了 缺点： 不可靠，不稳定1、由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包 用UDP协议通讯时怎样得知目标机是否获得了数据包 仿造TCP的做法，每发一个UDP包，都在里面加一个SEQ序号，接收方收到包后，将SEQ序号回复给发送方。如果发送方在指定时间以内没有收到回应，说明丢包了。 TCP与UDP的区别 TCP面向有链接的通信服务 UDP面向无连接的通信服务 TCP提供可靠的通信传输 UDP不可靠,会丢包 TCP保证数据顺序 UDP不保证 TCP数据无边界 UDP有边界 TCP速度快 UDP速度慢 TCP面向字节流 UDP面向报文 TCP一对一 UDP可以一对一，一对多 TCP报头至少20字节 UDP报头8字节 TCP有流量控制，拥塞控制 UDP没有 问题为什么UDP比TCP快 TCP需要三次握手 TCP有拥塞控制，控制流量等机制 为什么TCP比UDP可靠 TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。 TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有。因此可能丢包。 什么时候使用TCP 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。在日常生活中，常见使用TCP协议的应用如下：浏览器，用的HTTPFlashFXP，用的FTPOutlook，用的POP、SMTPPutty，用的Telnet、SSHQQ文件传输 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。比如，日常生活中，常见使用UDP协议的应用如下：QQ语音QQ视频TFTP TCP无边界，UDP有边界 TCP无边界 客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的； UDP有边界 客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。 为什么连接的时候是三次握手，关闭的时候是四次握手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态是用来重发可能丢失的ACK报文。]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开源库面试题集]]></title>
    <url>%2F2018%2F04%2F15%2FAndroid%E5%BC%80%E6%BA%90%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章Fork from android-interview 谈谈对Okhttp的理解？Volley与OkHttp的对比： Volley：支持HTTPS。缓存、异步请求，不支持同步请求。协议类型是Http/1.0, Http/1.1，网络传输使用的是 HttpUrlConnection/HttpClient，数据读写使用的IO。 OkHttp：支持HTTPS。缓存、异步请求、同步请求。协议类型是Http/1.0, Http/1.1, SPDY, Http/2.0, WebSocket，网络传输使用的是封装的Socket，数据读写使用的NIO（Okio）。 SPDY协议类似于HTTP，但旨在缩短网页的加载时间和提高安全性。SPDY协议通过压缩、多路复用和优先级来缩短加载时间。 Okhttp的子系统层级结构图如下所示： 👉 点击图片查看大图 网络配置层：利用Builder模式配置各种参数，例如：超时时间、拦截器等，这些参数都会由Okhttp分发给各个需要的子系统。 重定向层：负责重定向。 Header拼接层：负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应。 HTTP缓存层：负责读取缓存以及更新缓存。 连接层：连接层是一个比较复杂的层级，它实现了网络协议、内部的拦截器、安全性认证，连接与连接池等功能，但这一层还没有发起真正的连接，它只是做了连接器一些参数的处理。 数据响应层：负责从服务器读取响应的数据。 在整个Okhttp的系统中，我们还要理解以下几个关键角色： OkHttpClient：通信的客户端，用来统一管理发起请求与解析响应。 Call：Call是一个接口，它是HTTP请求的抽象描述，具体实现类是RealCall，它由CallFactory创建。 Request：请求，封装请求的具体信息，例如：url、header等。 RequestBody：请求体，用来提交流、表单等请求信息。 Response：HTTP请求的响应，获取响应信息，例如：响应header等。 ResponseBody：HTTP请求的响应体，被读取一次以后就会关闭，所以我们重复调用responseBody.string()获取请求结果是会报错的。 Interceptor：Interceptor是请求拦截器，负责拦截并处理请求，它将网络请求、缓存、透明压缩等功能都统一起来，每个功能都是一个Interceptor，所有的Interceptor最终连接成一个Interceptor.Chain。典型的责任链模式实现。 StreamAllocation：用来控制Connections与Streas的资源分配与释放。 RouteSelector：选择路线与自动重连。 RouteDatabase：记录连接失败的Route黑名单。 谈谈对Fresco理解？Fresco与Glide的对比： Glide：相对轻量级，用法简单优雅，支持Gif动态图，适合用在那些对图片依赖不大的App中。 Fresco：采用匿名共享内存来保存图片，也就是Native堆，有效的的避免了OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大的App中。 Fresco的整体架构如下图所示： 👉 点击图片查看大图 DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由负责。 DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。 DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。 DraweeHolder：统筹管理Hierarchy与DraweeHolder。 ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。 Producer/Consumer：Producer也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。 IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。 纵观整个Fresco的架构，DraweeView是门面，和用户进行交互，DraweeHierarchy是视图层级，管理图层，DraweeController是控制器，管理数据。它们构成了整个Fresco框架的三驾马车。当然还有我们幕后英雄Producer，所有的脏活累活都是它干的，最佳劳模👍 理解了Fresco整体的架构，我们还有了解在这套矿建里发挥重要作用的几个关键角色，如下所示： Supplier：提供一种特定类型的对象，Fresco里有很多以Supplier结尾的类都实现了这个接口。 SimpleDraweeView：这个我们就很熟悉了，它接收一个URL，然后调用Controller去加载图片。该类继承于GenericDraweeView，GenericDraweeView又继承于DraweeView，DraweeView是Fresco的顶层View类。 PipelineDraweeController：负责图片数据的获取与加载，它继承于AbstractDraweeController，由PipelineDraweeControllerBuilder构建而来。AbstractDraweeController实现了DraweeController接口，DraweeController是Fresco的数据大管家，所以的图片数据的处理都是由它来完成的。 GenericDraweeHierarchy：负责SimpleDraweeView上的图层管理，由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角），该类由GenericDraweeHierarchyBuilder进行构建，该构建器将placeholderImage、retryImage、failureImage、progressBarImage、background、overlays与pressedStateOverlay等xml文件或者Java代码里设置的属性信息都传入GenericDraweeHierarchy中，由GenericDraweeHierarchy进行处理。 DraweeHolder：该类是一个Holder类，和SimpleDraweeView关联在一起，DraweeView是通过DraweeHolder来统一管理的。而DraweeHolder又是用来统一管理相关的Hierarchy与Controller DataSource：类似于Java里的Futures，代表数据的来源，和Futures不同，它可以有多个result。 DataSubscriber：接收DataSource返回的结果。 ImagePipeline：用来调取获取图片的接口。 Producer：加载与处理图片，它有多种实现，例如：NetworkFetcherProducer，LocalAssetFetcherProducer，LocalFileFetchProducer。从这些类的名字我们就可以知道它们是干什么的。Producer由ProducerFactory这个工厂类构建的，而且所有的Producer都是像Java的IO流那样，可以一层嵌套一层，最终只得到一个结果，这是一个很精巧的设计👍 Consumer：用来接收Producer产生的结果，它与Producer组成了生产者与消费者模式。 注：Fresco源码里的类的名字都比较长，但是都是按照一定的命令规律来的，例如：以Supplier结尾的类都实现了Supplier接口，它可以提供某一个类型的对象（factory, generator, builder, closure等）。以Builder结尾的当然就是以构造者模式创建对象的类。 EventBus是如何做到发送粘性消息的？EventBus里有一个HashMap用来存储粘性事件队列，当注册事件时，如果该事件是粘性事件，则从该队列中取出最后一个该类型的事件并发送给订阅者。 天猫七巧板布局、vLayout的实现原理？]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法面试题集]]></title>
    <url>%2F2018%2F04%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章Fork from android-interview 数据结构与算法通常也与Java的集合牵扯在一起考察，这里我们将两者放在一起来讲。 什么是算法？ 算法是指令的集合，是为了解决特定问题而规定的一些列操作。 时间复杂度 算法的执行时间随着问题规模的增长而变化的规律。 算法的执行时间受到以下四个因素的影响： 硬件层面：计算机执行每条指令的速度 软件层面：编译产生的代码质量 算法策略：算法的好坏 问题规模 空间复杂度 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。 例如：插入排序的算法复杂度是O(1)。而一般递归算法的时间复杂度就是O(n)，因为每次递归都要存储结果。 常熟阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)，平方阶O(n^2)、立方阶O(n^3)、k次方阶O(n^k)、指数阶O(2^n); 描述一下Java的集合体系，List、Set与Map有什么区别？Java集合里使用接口来定义功能，是一套完善的继承体系。Iterator是所有集合的总接口，其他所有接口都继承于它，该接口定义了集合的遍历操作，Collection接口继承于Iterator，是集合的次级接口（Map独立存在，除外），定义了集合的一些通用操作。 Java集合的类结构图如下所示： 👉 点击图片查看大图 List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢； Set：无序，不可重复； Map：键值对，键唯一，值多个； 并发集合了解哪些？ ConcurrentHashMap：线程不安全的HashMap、效率低下的HashTable、线程安全且高效的ConcurrentHashMap。 ConcurrentHashMap存储元素的结构如下所示： ConcurrentHashMap与HashMap一样适用数组加链表存储元素，适用链表定址法来解决哈希冲突，不同之处在于当链表长度大于8的时候会将链表转换为一棵红黑树，查找时间复杂度由O(N)变成O(lgN)。 ConcurrentHashMap并发控制的关键在于一个变量，如下所示： 1private transient volatile int sizeCtl; sizeCtl被volatile关键字修饰是一个多线程共享的变量，当它的值为负数的时候说明某个线程正在操作这个Map，想要去操作这个Map的线程就要一直去竞争这个sizeCtl，没有得到这个变量的值就要一直自旋等待这个变量，当占用这个变量的线程操作完成后，要将这个变量的值设置回来，以便让其他线程走出自旋，竞争到该变量。 这种同步进制事实上是一种CAS的做法。 CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。 Vector，ArrayList与LinkedList有什么区别，应用场景是什么？ Vector实现了基于动态Object数组的数据结构，线程安全，可以设置增长因子，效率比较低，不建议使用。 ArrayList实现了基于动态Object数组的数据结构，非线程安全，地址连续，查询效率比较高，插入和删除效率比较低。适合查询操作频繁的场景。 LinkedList实现了基于链表的数据结构，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。 HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？ HashMap：基于HashMap.Node数组加单向链表实现，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。 LinkedHashMap：基于 ConcurrentHashMap：基于hash表实现，线程安全且高效，分段锁的实现相对于HashTable的实现提高了很大的效率。 TreeMap：基于红黑树实现，非线程安全，可以按照自然顺序或者自定义顺序自动排序，不允许插入null值，查找效率比较高，适合需要排序的场景。 ConcurrentHashMap存储元素的结构如下所示： ConcurrentHashMap与HashMap一样适用数组加链表存储元素，适用链表定址法来解决哈希冲突，不同之处在于当链表长度大于8的时候会将链表转换为一棵红黑树，查找时间复杂度由O(N)变成O(lgN)。 ConcurrentHashMap并发控制的关键在于一个变量，如下所示： 1private transient volatile int sizeCtl; sizeCtl被volatile关键字修饰是一个多线程共享的变量，当它的值为负数的时候说明某个线程正在操作这个Map，想要去操作这个Map的线程就要一直去竞争这个sizeCtl，没有得到这个变量的值就要一直自旋等待这个变量，当占用这个变量的线程操作完成后，要将这个变量的值设置回来，以便让其他线程走出自旋，竞争到该变量。 这种同步进制事实上是一种CAS的做法。 CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较 HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？ HashSet：基于HashMap实现，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。 LinkedHashSet： TreeSet基于红黑树实现，非线程安全，可以按照自然顺序或者自定义顺序自动排序，不允许插入null值。适合需要排序的场景。 HashSet基于hash表实现，非线程安全，允许插入null，查找效率高。适合查找操作频繁的场景。 HashMap是如何解决hash碰撞的？ 开发定址法 链表法 HashMap基于数组实现，数组里的元素是一个单向链表。 HashMap具有以下特点： 基于数组实现，数组里的元素是一个单向链表。 键不可以重复，值可以重复，键、值都可以为null 非线程安全 HashMap实现了以下接口： Map：以键值对的形式存取元素 Cloneable：可以被克隆 Serializable：可以序列化 查找流程 计算哈希值，根据哈希值与数组容量计算它所在的索引，根据索引查找它所在的链表。 在单向链表中查找该元素 删除流程 计算哈希值，根据哈希值与数组容量计算它所在的索引，根据索引查找它所在的链表。 从起始节点开始遍历，查找要删除的元素，删除该节点，将节点的后继添加为它前驱的后继 插入流程 根据key计算hash值，并根据hash值和数组容量，找到索引值，该位置即为存储该元素的链表所在处。 遍历table[i]位置的链表，查找相同的key，若找到则则用新的value替换掉oldValue. 若没有查找到相同的key，则添加key到table[i]位置，新添加的元素总是添加在单向链表的表头位置，后面的元素称为它的后继。 HashSet基于HashMap实现，也就是说它本质上也是一个数组，它以HashMap的key来存储元素，因为HashMap里的key是不会重复的，所以HashSet的元素时不重复且无序的。 SpareArray做了哪些优化？优点 key保存在int mKeys[]数组中，相对于HashMap不再对key进行自动装箱，避免资源消耗。但是vaule是保存在Object[] mValues数组中还是需要自动装箱的。 相对于HashMap，不再使用额外的Entry对象来存储数据，减少了内存开销。 数据量小的情况下，随机访问效率更高。 缺点 插入操作需要复制数组，增删效率低。 数据量巨大时，复制数组成本巨大，gc()成本也巨大。 数据量巨大时，查询效率也会明显下降。 简单说一说SpareArray的插入流程？SpareArray的key是一个int有序数组，查找过程使用的二分查找。 用二分查找法查找元素的key。 如果插入的数据冲突了，则直接覆盖原则。 如果当前插入的key上的数据为DELETE，则直接覆盖。 如果前面几步都失败了，则检查是否需要gc()并且在索引上插入数据。 N个无序树中查找最大的10个数？手写代码遍历文件目录？电梯运行的算法分析？手写一下单链表的查询操作？手写二分查找？手写一个字符串翻转？从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？1234567891011string: Hello length: 5 0 1 2 3 4 before: H e l l o after: o l l e H index sum 0: H---&gt;o 0--&gt;4 4 1: e---&gt;l 1--&gt;3 4 2: l---&gt;l 2--&gt;2 4 解法一：使用数组 将字符串转换为char数组 遍历循环给char数组赋值 12345678910public static String strReverseWithArray2(String string)&#123; if(string==null||string.length()==0)return string; int length = string.length(); char [] array = string.toCharArray(); for(int i = 0;i&lt;length/2;i++)&#123; array[i] = string.charAt(length-1-i); array[length-1-i] = string.charAt(i); &#125; return new String(array);&#125; 解法二：使用栈 将字符串转换为char数组 将char数组中的字符依次压入栈中 将栈中的字符依次弹出赋值给char数组 12345678910111213public static String strReverseWithStack(String string)&#123; if(string==null||string.length()==0)return string; Stack&lt;Character&gt; stringStack = new Stack&lt;&gt;(); char [] array = string.toCharArray(); for(Character c:array)&#123; stringStack.push(c); &#125; int length = string.length(); for(int i= 0;i&lt;length;i++)&#123; array[i] = stringStack.pop(); &#125; return new String(array);&#125; 解法三：逆序遍历 逆序遍历字符串中的字符，并将它依次添加到StringBuilder中 123456789public static String strReverseWithReverseLoop(String string)&#123; if(string==null||string.length()==0)return string; StringBuilder sb = new StringBuilder(); for(int i = string.length()-1;i&gt;=0;i--)&#123; sb.append(string.charAt(i)); &#125; return sb.toString(); &#125; 单链表反转，合并多个单链表单链表的结构就像一个火车的结构，火车头拉着许多车厢，实现链表翻转，可以利用递归翻转法，在反转当前节点之前先反转后续节点。这样从头结点开始，层层深入直到尾结点才开始反转指针域的指向。简单的说就是从尾结点开始，逆向反转各个结点的指针域指向， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class LinkedListReverse &#123; public static void main(String[] args) &#123; Node head = new Node(0); Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); head.setNext(node1); node1.setNext(node2); node2.setNext(node3); // 打印反转前的链表 Node h = head; while (null != h) &#123; System.out.print(h.getData() + " "); h = h.getNext(); &#125; // 调用反转方法 head = Reverse1(head); System.out.println("\n**************************"); // 打印反转后的结果 while (null != head) &#123; System.out.print(head.getData() + " "); head = head.getNext(); &#125; &#125; /** * 递归，在反转当前节点之前先反转后续节点 */ public static Node Reverse1(Node head) &#123; // head看作是前一结点，head.getNext()是当前结点，reHead是反转后新链表的头结点 if (head == null || head.getNext() == null) &#123; return head;// 若为空链或者当前结点在尾结点，则直接还回 &#125; Node reHead = Reverse1(head.getNext());// 先反转后续节点head.getNext() head.getNext().setNext(head);// 将当前结点的指针域指向前一结点 head.setNext(null);// 前一结点的指针域令为null; return reHead;// 反转后新链表的头结点 &#125; &#125; class Node &#123; private int Data;// 数据域 private Node Next;// 指针域 public Node(int Data) &#123; // super(); this.Data = Data; &#125; public int getData() &#123; return Data; &#125; public void setData(int Data) &#123; this.Data = Data; &#125; public Node getNext() &#123; return Next; &#125; public void setNext(Node Next) &#123; this.Next = Next; &#125; &#125; 排序算法以下排序算法内容来自：面试中的 10 大排序算法总结.md]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Algorithm</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题集]]></title>
    <url>%2F2018%2F04%2F10%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章Fork from android-interview Java谈谈对Java多态的理解？ 多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。 多态的三个必要条件： 继承父类。 重写父类的方法。 父类的引用指向子类对象。 静态方法与静态成员变量可以被继承吗，为什么？静态方法与静态成员变量可以被继承，但是不能被重写。它对子类隐藏，因此静态方法也不能实现多态。 为什么Java里的匿名内部类只能访问final修饰的外部变量？匿名内部类用法 12345678910111213141516public class TryUsingAnonymousClass &#123; public void useMyInterface() &#123; final Integer number = 123; System.out.println(number); MyInterface myInterface = new MyInterface() &#123; @Override public void doSomething() &#123; System.out.println(number); &#125; &#125;; myInterface.doSomething(); System.out.println(number); &#125;&#125; 编译后的结果 1234567891011121314class TryUsingAnonymousClass$1 implements MyInterface &#123; private final TryUsingAnonymousClass this$0; private final Integer paramInteger; TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) &#123; this.this$0 = this$0; this.paramInteger = paramInteger; &#125; public void doSomething() &#123; System.out.println(this.paramInteger); &#125;&#125; 因为匿名内部类最终用会编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类，例如：Integer paramInteger，如果变量不定义成final的，paramInteger在匿名内部类被可以被修改，进而造成和外部的paramInteger不一致的问题，为了避免这种不一致的情况，因为Java规定匿名内部类只能访问final修饰的外部变量。 讲一下Java的编码方式？为什么需要编码 计算机存储信息的最小单元是一个字节即8bit，所以能表示的范围是0~255，这个范围无法保存所有的字符，所以需要一个新的数据结构char来表示这些字符，从char到byte需要编码。 常见的编码方式有以下几种： ASCII：总共有 128 个，用一个字节的低 7 位表示，0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。 GBK：码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。 UTF-16：UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 UTF-8：统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。 Java中需要编码的地方一般都在字符到字节的转换上，这个一般包括磁盘IO和网络IO。 Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。 静态代理与动态代理区别是什么，分别用在什么样的场景里？静态代理与动态代理的区别在于代理类生成的时间不同，如果需要对多个类进行代理，并且代理的功能都是一样的，用静态代理重复编写代理类就非常的麻烦，可以用动态代理动态的生成代理类。 1234567891011121314151617 // 为目标对象生成代理对象public Object getProxyInstance() &#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开启事务"); // 执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println("提交事务"); return null; &#125; &#125;);&#125; 描述一下Java的异常体系？ Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时， Java虚拟机（JVM）一般会选择线程终止。 Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常，程序中应当尽可能去处理这些异常。运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。 描述一个类的加载过程？Person person = new Person() 查找Person.class，并加载到内存中。 执行类里的静态代码块。 在堆内存里开辟内存空间，并分配内存地址。 在堆内存里建立对象的属性，并进行默认的初始化。 对属性进行显示初始化。 对对象进行构造代码块初始化。 调用对象的构造函数进行初始化。 将对象的地址赋值给person变量。 Java对象的生命周期是什么？ 加载：将类的信息加载到JVM的方法区，然后在堆区中实例化一个java.lang.Class对象，作为方法去中这个类的信息入口。 连接：验证：验证类是否合法。准备：为静态变量分配内存并设置JVM默认值，非静态变量不会分配内存。解析：将常量池里的符号引用转换为直接引用。 初始化：初始化类的静态赋值语句和静态代码块，主动引用会被触发类的初始化，被动引用不会触发类的初始化。 使用：执行类的初始化，主动引用会被触发类的初始化，被动引用不会触发类的初始化。 卸载：卸载过程就是清楚堆里类的信息，以下情况会被卸载：① 类的所有实例都已经被回收。② 类的ClassLoader被回收。③ 类的CLass对象没有被任何地方引用，无法在任何地方通过反射访问该类。 描述一下类的加载机制？ 类的加载就是虚拟机通过一个类的全限定名来获取描述此类的二进制字节流，而完成这个加载动作的就是类加载器。 类和类加载器息息相关，判定两个类是否相等，只有在这两个类被同一个类加载器加载的情况下才有意义，否则即便是两个类来自同一个Class文件，被不同类加载器加载，它们也是不相等的。 注：这里的相等性包含Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果以及Instance关键字对对象所属关系的判定结果等。 类加载器可以分为三类： 启动类加载器（Bootstrap ClassLoader）：负责加载\lib目录下或者被-Xbootclasspath参数所指定的路径的，并且是被虚拟机所识别的库到内存中。 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录下或者被java.ext.dirs系统变量所指定的路径的所有类库到内存中。 应用类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载器去加载应用程序中的类库。 这么多类加载器，那么当类在加载的时候会使用哪个加载器呢？🤔 这个时候就要提到类加载器的双亲委派模型，流程图如下所示： 双亲委派模型的整个工作流程非常的简单，如下所示： 如果一个类加载器收到了加载类的请求，它不会自己立即去加载类，它会先去请求父类加载器，每个层次的类加载器都是如此。层层传递，直到传递到最高层的类加载器，只有当父类加载器反馈自己无法加载这个类，才会有当前子类加载器去加载该类。 关于双亲委派机制，在ClassLoader源码里也可以看出，如下所示： 1234567891011121314151617181920212223242526272829303132public abstract class ClassLoader &#123; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; //首先，检查该类是否已经被加载 Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; //先调用父类加载器去加载 if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; //如果父类加载器没有加载到该类，则自己去执行加载 long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats &#125; &#125; return c; &#125;&#125; 为什么要这么做呢？🤔 这是为了要让越基础的类由越高层的类加载器加载，例如Object类，无论哪个类加载器去尝试加载这个类，最终都会传递给最高层的类加载器去加载，前面我们也说过，类的相等性是由类与其类加载器共同判定的，这样Object类无论在何种类加载器环境下都是同一个类。 相反如果没有双亲委派模型，那么每个类加载器都会去加载Object，那么系统中就会出现多个不同的Object类了，如此一来系统的最基础的行为也就无法保证了。 描述一下GC的原理和回收策略？提到垃圾回收，我们可以先思考一下，如果我们去做垃圾回收需要解决哪些问题？ 🤔 一般说来，我们要解决以下三个问题： 哪些内存回收？ 什么时候回收？ 如何回收？ 这些问题分别对应着引用管理和回收策略等方案。 提到引用，我们都知道Java中有四种引用类型： 强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。 软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候回回收这类对象。 弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次GC发生时，当GC发生时，无论内存是否足够，都会回收该对象。 虚引用：PhantomReference，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用取得一个对象的引用，它存在的唯一目的是在这个对象被回收时可以收到一个系统通知。 不同的引用类型，在做GC时会区别对待，我们平时生成的Java对象，默认都是强引用，也就是说只要强引用还在，GC就不会回收，那么如何判断强引用是否存在呢？🤔 一个简单的思路就是：引用计数法，有对这个对象的引用就+1，不再引用就-1，但是这种方式看起来简单美好，但它却不嫩解决循环引用计数的问题。 因此可达性分析算法登上历史舞台😎，用它来判断对象的引用是否存在。 可达性分析算法通过一系列称为GC Roots的对象作为起始点，从这些节点从上向下搜索，搜索走过的路径称为引用链，当一个对象没有任何引用链与GC Roots连接时就说明此对象不可用，也就是对象不可达。 GC Roots对象通常包括： 虚拟机栈中引用的对象（栈帧中的本地变量表） 方法去中类的静态属性引用的对象 方法区中常量引用的对象 Native方法引用的对象 可达性分析算法整个流程如下所示： 第一次标记：对象在经过可达性分析后发现没有与GC Roots有引用链，则进行第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行finalize()方法。没有覆盖finalize()方法或者finalize()方法已经被执行过都会被认为没有必要执行。 如果有必要执行：则该对象会被放在一个F-Queue队列，并稍后在由虚拟机建立的低优先级Finalizer线程中触发该对象的finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的finalize()方法发生了死循环或者执行时间较长的情况，会阻塞F-Queue队列里的其他对象，影响GC。 第二次标记：GC对F-Queue队列里的对象进行第二次标记，如果在第二次标记时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。 接口和抽象类有什么区别？共同点 是上层的抽象层。 都不能被实例化 都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不会提供具体的实现。 区别 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。 一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。 问：抽象类是否可继承实体类 (concrete class)答： 抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数 答案很明确，可以继承。其实从Object就是个实体类，java的API文档里，每个抽象类的条目里都明确写着直接或间接继承自Object，所以这点是没有疑问的。关键在于这答案里所说的“前提是实体类必须有明确的构造函数”一句，是什么意思。一般学习者会写的简单试验代码：123class A&#123;&#125;abstract class B extends A&#123;&#125; 结果完全正常，编译通过。似乎和“实体类必须有明确的构造函数”完全没有关系。 这个问题涉及到两个个基础知识： 所有的class都必须有一个构造方法，如果你没有在代码里声明构造方法，系统会自动给你生成一个公有无参的构造方法。而只要你自己声明了一个构造方法，无论有参无参，私有公有，系统就不再帮你生成默认无参构造器了。 所有的子类构造器都要求在第一行代码中调用父类构造器，如果不写，系统默认去调用父类的无参构造器。 所以，如果把系统默认配给的方法也算进去，class A{}的代码实际上是12345class A&#123; public A()&#123;&#125;&#125; B继承 A 的时候，则是123456789abstract class B extends A&#123; public B()&#123; super(); &#125;&#125; 要试验出这继承规则的内部情况，也很简单，在最上面那个简单试验代码里，加上个私有构造器，有参无参都行。12345class A&#123; private A()&#123;&#125; &#125; 这个时候，如基础知识(1) 中所说，系统不再给你默认无参构造器， B的构造器根据（2）中的规则去调用super()，却找不到A的无参构造器，所以导致abstract class B extends A{} 编译不能通过。（因为A中没有任何构造器可供子类调用，其实这个时候A只能够供内部类继承，我用的Eclipse的3.4版本会建议给B改名，但是这解决不了这个问题。） 现在，你应该了解了资料给的那句语焉不详的“实体类必须有明确的构造函数”的含义： 没写构造器的，那是拥有默认无参公有构造函数的，子类可以什么都不写，让默认构造器去调用它。这是最初那两行代码的情况。 写了子类可访问的无参构造器的，也是一样，子类里可以什么都不写，用默认机制调用。 写了 有参构造器却没写无参构造器的，父类里没有子类可访问的无参构造器，子类必须在子类构造器里的第一句写明，调用父类有参构造器，并把参数传进去。 声明为final的以及所有构造器都不在子类访问权限之内的类无法继承 其实只要是在类的继承中，无论抽象还是实体，都需要符合这个规则的。在这个继承试验中随时删掉或是加上abstract的前缀，结果都没有变化。个人觉得“实体类必须有明确的构造函数”一句实在是无法把这个情况表达清楚，所以广大求职者还是写得清楚些好。 我喜欢的写法是“可以继承，但是和实体类的继承一样，也要求父类可继承，并且拥有子类可访问到的构造器。” 内部类、静态内部类在业务中的应用场景是什么？12345678static class Outer &#123; class Inner &#123;&#125; static class StaticInner &#123;&#125;&#125;Outer outer = new Outer();Outer.Inner inner = outer.new Inner();Outer.StaticInner inner0 = new Outer.StaticInner(); 静态内部类：只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。 非静态内部类：持有外部类的引用，可以自由使用外部类的所有变量和方法 synchronized与ReentrantLock有什么区别？synchronized是互斥同步的一种实现。 synchronized：当某个线程访问被synchronized标记的方法或代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或代码块。 前面我们已经说了volatile关键字，这里我们举个例子来综合分析volatile与synchronized关键字的使用。 :point_up: 举个栗子 1234567891011121314151617181920public class Singleton &#123; //volatile保证了：1 instance在多线程并发的可见性 //2 禁止instance在操作时的指令重排序 private volatile static Singleton instance; public static Singleton getInstance() &#123; //第一次判空，保证不必要的同步 if (instance == null) &#123; //synchronized对Singleton加全局锁，保证每次只要一个线程创建实例 synchronized (Singleton.class) &#123; //第二次判空时为了在null的情况下创建实例 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 这是一个经典的DCL单例。 它的字节码如下： 可以看到被synchronized同步的代码块，会在前后分别加上monitorenter和monitorexit，这两个字节码都需要指定加锁和解锁的对象。 关于加锁和解锁的对象： synchronized代码块 ：同步代码块，作用范围是整个代码块，作用对象是调用这个代码块的对象。 synchronized方法 ：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。 synchronized静态方法 ：同步静态方法，作用范围是整个静态方法，作用对象是调用这个类的所有对象。 synchronized(this)：作用范围是该对象中所有被synchronized标记的变量、方法或代码块，作用对象是对象本身。 synchronized(ClassName.class) ：作用范围是静态的方法或者静态变量，作用对象是Class对象。 synchronized(this)添加的是对象锁，synchronized(ClassName.class)添加的是类锁，它们的区别如下： 对象锁：Java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。 类锁：对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。我们都知道，java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是MyClass.class的方式。 类锁和对象锁不是同一个东西，一个是类的Class对象的锁，一个是类的实例的锁。也就是说：一个线程访问静态synchronized的时候，允许另一个线程访问对象的实例synchronized方法。反过来也是成立的，因为他们需要的锁是不同的。 volatile的原理是什么？volatile也是互斥同步的一种实现，不过它非常的轻量级。 volatile有两条关键的语义： 保证被volatile修饰的变量对所有线程都是可见的 禁止进行指令重排序 要理解volatile关键字，我们得先从Java的线程模型开始说起。如图所示： Java内存模型规定了所有字段（这些字段包括实例字段、静态字段等，不包括局部变量、方法参数等，因为这些是线程私有的，并不存在竞争）都存在主内存中，每个线程会有自己的工作内存，工作内存里保存了线程所使用到的变量在主内存里的副本拷贝，线程对变量的操作只能在工作内存里进行，而不能直接读写主内存，当然不同内存之间也无法直接访问对方的工作内存，也就是说主内存是线程传值的媒介。 我们来理解第一句话： 保证被volatile修饰的变量对所有线程都是可见的 如何保证可见性？🤔 被volatile修饰的变量在工作内存修改后会被强制写回主内存，其他线程在使用时也会强制从主内存刷新，这样就保证了一致性。 关于“保证被volatile修饰的变量对所有线程都是可见的”，有种常见的错误理解： 错误理解：由于volatile修饰的变量在各个线程里都是一致的，所以基于volatile变量的运算在多线程并发的情况下是安全的。 这句话的前半部分是对的，后半部分却错了，因此它忘记考虑变量的操作是否具有原子性这一问题。 举个栗子 1234567891011121314151617181920private volatile int start = 0;private void volatileKeyword() &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; start++; &#125; &#125; &#125;; for (int i = 0; i &lt; 10; i++) &#123; Thread thread = new Thread(runnable); thread.start(); &#125; Log.d(TAG, "start = " + start);&#125; 这段代码启动了10个线程，每次10次自增，按道理最终结果应该是100，但是结果并非如此。 为什么会这样？🤔 仔细看一下start++，它其实并非一个原子操作，简单来看，它有两步： 取出start的值，因为有volatile的修饰，这时候的值是正确的。 自增，但是自增的时候，别的线程可能已经把start加大了，这种情况下就有可能把较小的start写回主内存中。 所以volatile只能保证可见性，在不符合以下场景下我们依然需要通过加锁来保证原子性： 运算结果并不依赖变量当前的值，或者只有单一线程修改变量的值。（要么结果不依赖当前值，要么操作是原子性的，要么只要一个线程修改变量的值） 变量不需要与其他状态变量共同参与不变约束 比方说我们会在线程里加个boolean变量，来判断线程是否停止，这种情况就非常适合使用volatile。 我们再来理解第二句话。 禁止进行指令重排序 什么是指令重排序？🤔 指令重排序是值指令乱序执行，即在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开为获取下一条指令所需数据而造成的等待，通过乱序执行的技术，提供执行效率。 指令重排序绘制被volatile修饰的变量的赋值操作前，添加一个内存屏障，指令重排序时不能把后面的指令重排序到内存屏障之前的位置。 关于指令重排序不是本篇文章重点讨论的内容，更多细节可以参考指令重排序。 如何防止反射、序列化攻击单例？枚举单例 1234567891011121314151617public enum Singleton &#123; INSTANCE &#123; @Override protected void read() &#123; System.out.println("read"); &#125; @Override protected void write() &#123; System.out.println("write"); &#125; &#125;; protected abstract void read(); protected abstract void write();&#125; class文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public abstract class Singleton extends Enum&#123; private Singleton(String s, int i) &#123; super(s, i); &#125; protected abstract void read(); protected abstract void write(); public static Singleton[] values() &#123; Singleton asingleton[]; int i; Singleton asingleton1[]; System.arraycopy(asingleton = ENUM$VALUES, 0, asingleton1 = new Singleton[i = asingleton.length], 0, i); return asingleton1; &#125; public static Singleton valueOf(String s) &#123; return (Singleton)Enum.valueOf(singleton/Singleton, s); &#125; Singleton(String s, int i, Singleton singleton) &#123; this(s, i); &#125; public static final Singleton INSTANCE; private static final Singleton ENUM$VALUES[]; static &#123; INSTANCE = new Singleton("INSTANCE", 0) &#123; protected void read() &#123; System.out.println("read"); &#125; protected void write() &#123; System.out.println("write"); &#125; &#125;; ENUM$VALUES = (new Singleton[] &#123; INSTANCE &#125;); &#125;&#125; 类的修饰abstract，所以没法实例化，反射也无能为力。 关于线程安全的保证，其实是通过类加载机制来保证的，我们看看INSTANCE的实例化时机，是在static块中，JVM加载类的过程显然是线程安全的。 对于防止反序列化生成新实例的问题还不是很明白，一般的方法我们会在该类中添加上如下方法，不过枚举中也没有显示的写明该方法。 1234//readResolve to prevent another instance of Singletonprivate Object readResolve()&#123; return INSTANCE;&#125; 线程为什么阻塞，为和要使用多线程？使用多线程更多的是为了提高CPU的并发，可以让CPU同事处理多个事情，多线程场景的使用场景： 为了不让耗时操作阻塞主线程，开启新线程执行耗时操作。 某种任务虽然耗时但是不消耗CPU，例如：磁盘IO，可以开启新线程来做，可以显著的提高效率。 优先级比较低的任务，但是需要经常去做，例如：GC，可以开启新线程来做。 了解线程的生命周期吗，描述一下？线程状态流程图图 NEW：创建状态，线程创建之后，但是还未启动。 RUNNABLE：运行状态，处于运行状态的线程，但有可能处于等待状态，例如等待CPU、IO等。 WAITING：等待状态，一般是调用了wait()、join()、LockSupport.spark()等方法。 TIMED_WAITING：超时等待状态，也就是带时间的等待状态。一般是调用了wait(time)、join(time)、LockSupport.sparkNanos()、LockSupport.sparkUnit()等方法。 BLOCKED：阻塞状态，等待锁的释放，例如调用了synchronized增加了锁。 TERMINATED：终止状态，一般是线程完成任务后退出或者异常终止。 NEW、WAITING、TIMED_WAITING都比较好理解，我们重点说一说RUNNABLE运行态和BLOCKED阻塞态。 线程进入RUNNABLE运行态一般分为五种情况： 线程调用sleep(time)后查出了休眠时间 线程调用的阻塞IO已经返回，阻塞方法执行完毕 线程成功的获取了资源锁 线程正在等待某个通知，成功的获得了其他线程发出的通知 线程处于挂起状态，然后调用了resume()恢复方法，解除了挂起。 线程进入BLOCKED阻塞态一般也分为五种情况： 线程调用sleep()方法主动放弃占有的资源 线程调用了阻塞式IO的方法，在该方法返回前，该线程被阻塞。 线程视图获得一个资源锁，但是该资源锁正被其他线程锁持有。 线程正在等待某个通知 线程调度器调用suspend()方法将该线程挂起 我们再来看看和线程状态相关的一些方法。 sleep()方法让当前正在执行的线程在指定时间内暂停执行，正在执行的线程可以通过Thread.currentThread()方法获取。 yield()方法放弃线程持有的CPU资源，将其让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。 wait()方法是当前执行代码的线程进行等待，将当前线程放入预执行队列，并在wait()所在的代码处停止执行，知道接到通知或者被中断为止。该方法可以使得调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到再次被唤醒。该方法只能在同步代码块里调用，否则会抛出IllegalMonitorStateException异常。 wait(long millis)方法等待某一段时间内是否有线程对锁进行唤醒，如果超过了这个时间则自动唤醒。 notify()方法用来通知那些可能等待该对象的对象锁的其他线程，该方法可以随机唤醒等待队列中等同一共享资源的一个线程，并使该线程退出等待队列，进入可运行状态。 notifyAll()方法可以是所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，进入可运行状态，一般会是优先级高的线程先执行，但是根据虚拟机的实现不同，也有可能是随机执行。 join()方法可以让调用它的线程正常执行完成后，再去执行该线程后面的代码，它具有让线程排队的作用。 线程池了解吗，有几种线程池，应用场景是什么？Executors类提供了一系列工厂方法用来创建线程池。这些线程是适用于不同的场景。 newCachedThreadPool()：无界可自动回收线程池，查看线程池中有没有以前建立的线程，如果有则复用，如果没有则建立一个新的线程加入池中，池中的线程超过60s不活动则自动终止。适用于生命周期比较短的异步任务。 newFixedThreadPool(int nThreads)：固定大小线程池，与newCachedThreadPool()类似，但是池中持有固定数目的线程，不能随时创建线程，如果创建新线程时，超过了固定线程数，则放在队列里等待，直到池中的某个线程被移除时，才加入池中。适用于很稳定、很正规的并发线程，多用于服务器。 newScheduledThreadPool(int corePoolSize)：周期任务线程池，该线程池的线程可以按照delay依次执行线程，也可以周期执行。 newSingleThreadExecutor()：单例线程池，任意时间内池中只有一个线程。 ThreadLocal的原理了解吗？ThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示： 实现单个线程单例以及单个线程上下文信息存储，比如交易id等。 实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例。 承载一些线程相关的数据，避免在方法中来回传递参数。 wait和notify机制，手写一下生产者和消费者模型？生成者消费者模型 生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 wait()和notify()方法的实现生成者消费者模型，缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ProducerAndCustomerModel &#123; private static Integer count = 0; private static final Integer FULL = 10; private static String LOCK = "lock"; public static void main(String[] args) &#123; ProducerAndCustomerModel PACM = new ProducerAndCustomerModel(); new Thread(PACM.new Producer()).start(); new Thread(PACM.new Consumer()).start(); new Thread(PACM.new Producer()).start(); new Thread(PACM.new Consumer()).start(); new Thread(PACM.new Producer()).start(); new Thread(PACM.new Consumer()).start(); new Thread(PACM.new Producer()).start(); new Thread(PACM.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (LOCK) &#123; while (count == FULL) &#123; try &#123; LOCK.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); LOCK.notifyAll(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (LOCK) &#123; while (count == 0) &#123; try &#123; LOCK.wait(); &#125; catch (Exception e) &#123; &#125; &#125; count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); LOCK.notifyAll(); &#125; &#125; &#125; &#125;&#125; 死锁是如何发生的，如何避免死锁？当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DeadLockDemo &#123; public static void main(String[] args) &#123; // 线程a Thread td1 = new Thread(new Runnable() &#123; public void run() &#123; DeadLockDemo.method1(); &#125; &#125;); // 线程b Thread td2 = new Thread(new Runnable() &#123; public void run() &#123; DeadLockDemo.method2(); &#125; &#125;); td1.start(); td2.start(); &#125; public static void method1() &#123; synchronized (String.class) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程a尝试获取integer.class"); synchronized (Integer.class) &#123; &#125; &#125; &#125; public static void method2() &#123; synchronized (Integer.class) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程b尝试获取String.class"); synchronized (String.class) &#123; &#125; &#125; &#125;&#125; 造成死锁的四个条件： 互斥条件：一个资源每次只能被一个线程使用。 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class BreakDeadLockDemo &#123; public static void main(String[] args) &#123; // 线程a Thread td1 = new Thread(new Runnable() &#123; public void run() &#123; BreakDeadLockDemo.method1(); &#125; &#125;); // 线程b Thread td2 = new Thread(new Runnable() &#123; public void run() &#123; BreakDeadLockDemo.method2(); &#125; &#125;); td1.start(); td2.start(); &#125; public static void method1() &#123; synchronized (String.class) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程a尝试获取integer.class"); synchronized (Integer.class) &#123; System.out.println("线程a获取到integer.class"); &#125; &#125; &#125; public static void method2() &#123; // 不再获取线程a需要的Integer.class锁。 synchronized (String.class) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程b尝试获取Integer.class"); synchronized (Integer.class) &#123; System.out.println("线程b获取到Integer.class"); &#125; &#125; &#125;&#125; 了解Java注解的原理吗，注解如何获取？注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用Java的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。 String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？ String是不可变的（修改String时，不会在原有的内存地址修改，而是重新指向一个新对象），String用final修饰，不可继承，String本质上是个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String也没有对外暴露修改char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。 StringBuffer是线程安全的。 StringBuilder是非线程安全的。 Java里的幂等性了解吗？ 幂等性原本是数学上的一个概念，即：f(x) = f(f(x))，对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。 幂等性最为常见的应用就是电商的客户付款，试想一下，如果你在付款的时候因为网络等各种问题失败了，然后又去重复的付了一次，是一种多么糟糕的体验。幂等性就是为了解决这样的问题。 实现幂等性可可以使用Token机制。 核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。 例如：电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。 Java泛型了解吗，知道它的运行机制吗？ 泛型是为了参数化类型。 为什么使用泛型？ 相对于使用Object这种简单粗暴的方式，泛型提供了一种参数化的能力，使得数据的类型可以像参数一样被传递进来，这提供了一种扩展能力。 当数据类型确定以后，提供了一种类型检测机制，只有相匹配的数据才可以正常赋值，否则编译错误，增强了安全性。 泛型提高了代码的可读性，不必等到运行时采取执行类型转换，在编写代码阶段，程序员就可以通过参数书写正确的数据类型。 除了用 表示泛型外，还有 &lt;?&gt; 这种形式。? 被称为通配符。 &lt;?&gt; 被称作无限定的通配符。 &lt;? extends T&gt; 被称作有上限的通配符。 &lt;? super T&gt; 被称作有下限的通配符。 Java里的反射为何会消耗性能？反射慢主要因为反射是动态类型，这样导致把在zhuang Java的类型擦除，知道它的原理吗？ 泛型信息只存在代码编译阶段，在进入JVM之前，与泛型相关的信息都会被擦除掉。 在类型擦除的时候，如果泛型类里的类型参数没有指定上限，例如：，则会被转成Object类型，如果指定了上限，例如：，则会被传换成对应的类型上限。 闭包了解吗，Java里有闭包吗？ 「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。 12345678fun main(args: Array&lt;String&gt;) &#123; test&#125;val test = if (5 &gt; 3) &#123; print("yes")&#125; else &#123; print("no")&#125; Lambda表达式了解吗？ Lambda 表达式俗称匿名函数。Kotlin 的 Lambda表达式更“纯粹”一点， 因为它是真正把Lambda抽象为了一种类型，而 Java 8 的 Lambda 只是单方法匿名接口实现的语法糖罢了。 1234567val printMsg = &#123; msg: String -&gt; println(msg) &#125;fun main(args: Array&lt;String&gt;) &#123; printMsg("hello")&#125; 高阶函数了解吗？ 当定义一个闭包作为参数的函数，称这个函数为高阶函数。 1234567891011fun main(args: Array&lt;String&gt;) &#123; log("world", printMsg)&#125;val printMsg = &#123; str: String -&gt; println(str)&#125;val log = &#123; str: String, printLog: (String) -&gt; Unit -&gt; printLog(str)&#125;]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试题集]]></title>
    <url>%2F2018%2F04%2F08%2FAndroid%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章部分 Fork from android-interview并且在此基础上对一些问题进行了补充、深入剖析 手画一下Android系统架构图，描述一下各个层次的作用？Android系统架构图 从上到下依次分为六层： 应用框架层 进程通信层 系统服务层 Android运行时层 硬件抽象层 Linux内核层 Activity、View、Window 三者关系这个问题真的很不好回答，所以这里先来个算是比较恰当的比喻来形容下它们的关系。Activity 像一个工匠(Control Unit)，Window 像窗户(承载模型)，View 像窗花(显示视图)，LayoutInflater 像剪刀，Xml 配置像窗花图纸。 Activity 构造的时候会初始化一个 Window，准确的说是 PhoneWindow。 这个 PhoneWindow 有一个“ViewRoot”，这个“ViewRoot”是一个 View 或者说 ViewGroup，是最初试的根视图 “ViewRoot”通过 addView 方法来一个个的添加 View。比如 TextView，Button 等 这些 View 的事件监听，是由 WindowManagerService 来接受消息，并且回调 Activity 函数。比如 onClickListener，onKeyDown 等。 四种 LaunchMode 及其使用场景standard 模式这是默认模式，每次激活 Activity 时都会创建 Activity 实例，并放入任务栈中。使用场景：大多数 Activity singleTop 模式如果在任务的栈顶正好存在该 Activity 的实例，就重用该实例(会调用实例的 onNewIntent())，否则就会创建新的实例并放入栈顶，即使栈中已经存在该 Activity 的实例，只要不在栈顶，就会创建新的实例。使用场景如新闻类或者阅读类 App 的内容页面。 singleTask 模式如果在栈中已经有该 Activity 的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance 模式在一个新栈中创建该 Activity 的实例，并让多个应用共享该栈中的该 Activity 实例。一旦该模式的 Activity 实例已经存在于某个栈中，任何应用再激活该 Activity 时都会重用该栈中的实例(会调用实例的 onNewIntent())。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景：如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance 不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B(singleInstance) -&gt; C，完全退出后，再次启动，首先打开的是 B。 Activity如与Service通信？可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法里执行相关操作。注：只有activities,services,和contentproviders可以绑定到一个service—你不能从一个broadcastreceiver绑定到service． Service的生命周期与启动方法有什么区别？ startService()：开启Service，调用者退出后Service仍然存在。 bindService()：开启Service，调用者退出后Service也随即退出。 Service生命周期： 只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory 只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？ bindService生命周期 通过IBinder从你的客户端绑定到一个service，你必须： １实现ServiceConnection. 你的实现必须重写两个回调方法： onServiceConnected() 系统调用这个来传送在service的onBind()中返回的IBinder． OnServiceDisconnected() Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用． ２调用bindService()，传给它ServiceConnection的实现． ３当系统调用你的onServiceConnected()方法时，你就可以使用接口定义的方法们开始调用service了． ４要与service断开连接，调用unbindService()． 当你的客户端被销毁，它将从service解除绑定，但是你必须总是在你完成与service的交互时或当你的activity暂停于是service在不被使用时可以关闭此两种情况下解 除绑定．(下面会讨论更多在适当的时候绑定和解除绑定的问题． 使用这个ServiceConnection，客户端可以绑定到一个service，通过把它传给bindService()．例如： 12Intent intent = new Intent(this, LocalService.class);bindService(intent,mConnection, Context.BIND_AUTO_CREATE); 第一个bindService()的参数是一个明确指定了要绑定的service的Intent． 第二个参数是ServiceConnection对象． 第三个参数是一个标志，它表明绑定中的操作．它一般应是BIND_AUTO_CREATE，这样就会在service不存在时创建一个．其它可选的值是BIND_DEBUG_UNBIND和BIND_NOT_FOREGROUND,不想指定时设为0即可。 补充事项下面是一些关于绑定到service的重要事项： 你总是需要捕获DeadObjectException异常．它会在连接被打断时抛出．这是被远程方法抛出的唯一异常． 对象引用计数是跨进程的作用的． 你应该在客户端的生命期内使绑定和解除绑定配对进行，例如： 如果你需要在你的activity可见时与service交互，你应该在onStart()绑定并在onStop()中解除绑定． 如果你想让你的activity即使在它停止时也能接收回应，那么你可以在onCreate()中绑定并在onDestroy()中解除绑定．注意这意味着你的activity需要使用在自己整 个运行期间使用service(即使位于后台)，所以如果service在另一个进程中，那么你增加了这个进程的负担而使它变得更容易被系统杀掉． 注：你一般不应该在你的activity的onResume()和onPause()中绑定和解除绑定到service，因为这些回调方法,出现在每个生命期变化中，并且你需要使发生在这 些变化中的处理最小化．还有，如果你应用中的多个activity绑定到同一个service，并且有一个变化发生在其中两个activity之间，service可能在当前activity解除绑 定(pause中)和下一个绑定前(rusume中)被销毁又重建． bindService和startService混合使用时 如果先bindService,再startService:在bind的Activity退出的时候,Service会执行unBind方法而不执行onDestory方法,因为有startService方法调用过,所以Activity与Service解除绑定后会有一个与调用者没有关连的Service存在 如果先bindService,再startService,再调用Context.stopServiceService的onDestory方法不会立刻执行,因为有一个与Service绑定的Activity,但是在Activity退出的时候,会执行onDestory,如果要立刻执行stopService,就得先解除绑定 把上面的”如果先bindService,再startService”换成”如果先startService,再bindService”,结果是一样的 问题:如果在一个Activity的onCreate方法中,先bindService(serviceIntent,conn,Context.BIND_AUTO_CREATE);再startService(serviceIntent);退出这个Activity时,会执行onUnBind但是再次进入这个Activity的时候,为什么不执行onBind方法了?只有在这个Service销毁后(执行onDestory),再进这个Activity才会执行onBind，还有就是当有两个客户端时，在第一个客户端startServie启动服务再bindService绑定服务,这时跳到第二个客户端里（启动时会调用onBind())，再客户端startServie启动服务再bindService绑定服务，启动时不会调用用onBind()了(因为之前客户端已经启动后没有onDestory()销毁Service，所以再客户端第二次绑定服务时，只会返回IBinder对象给onServiceConnected())，而且要注意的是当，当第一个服务启动并绑定一个服务时，再跳去第二个服务端启动并绑定这个服务时，第二个服务端再解绑时，不会调用onUnbind()，只有回到第一个客户端时，解绑这是才会调用onUnbind(),顺序反过来结果是一样的。得出一个结论是：当一个服务没被onDestory()销毁之前，只有第一个启动它的客户端能调用它的onBind()和onUnbind()。 广播分为哪几种，应用场景是什么？ 普通广播：调用sendBroadcast()发送，最常用的广播。 有序广播：调用sendOrderedBroadcast()，发出去的广播会被广播接受者按照顺序接收，广播接收者按照Priority属性值从大-小排序，Priority属性相同者，动态注册的广播优先，广播接收者还可以选择对广播进行截断和修改。 广播的两种注册方式有什么区别？ 静态注册：常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。 动态注册：非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造成内存泄漏。 广播发送和接收的原理了解吗？ 继承BroadcastReceiver，重写onReceive()方法。 通过Binder机制向ActivityManagerService注册广播。 通过Binder机制向ActivityMangerService发送广播。 ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。 BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。 广播传输的数据是否有限制，是多少，为什么要限制？ContentProvider、ContentResolver与ContentObserver之间的关系是什么？ ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。 ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。 ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。 遇到过哪些关于Fragment的问题，如何处理的？ getActivity()空指针：这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()，此时就会有空指针，解决方案是在Fragment里使用一个全局变量mActivity，在onAttach()方法里赋值，这样可能会引起内存泄漏，但是异步任务没有停止的情况下本身就已经可能内存泄漏，相比直接crash，这种方式显得更妥当一些。 Fragment视图重叠：在类onCreate()的方法加载Fragment，并且没有判断saveInstanceState==null或if(findFragmentByTag(mFragmentTag) == null)，导致重复加载了同一个Fragment导致重叠。（PS：replace情况下，如果没有加入回退栈，则不判断也不会造成重叠，但建议还是统一判断下） 12345678@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123;// 在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠 ; if(saveInstanceState == null)&#123; // 或者 if(findFragmentByTag(mFragmentTag) == null) // 正常情况下去 加载根Fragment &#125; &#125; Android里的Intent传递的数据有大小限制吗，如何解决？Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。处理方式如下： 进程内：EventBus，文件缓存、磁盘缓存。 进程间：通过ContentProvider进行款进程数据共享和传递。 描述一下Android的事件分发机制？Android事件分发机制的本质：事件从哪个对象发出，经过哪些对象，最终由哪个对象处理了该事件。此处对象指的是Activity、Window与View。 Android事件的分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View Android事件的分发主要由三个方法来完成，如下所示： 123456789101112131415// 父View调用dispatchTouchEvent()开始分发事件public boolean dispatchTouchEvent(MotionEvent event)&#123; boolean consume = false; // 父View决定是否拦截事件 if(onInterceptTouchEvent(event))&#123; // 父View调用onTouchEvent(event)消费事件，如果该方法返回true，表示 // 该View消费了该事件，后续该事件序列的事件（Down、Move、Up）将不会在传递 // 该其他View。 consume = onTouchEvent(event); &#125;else&#123; // 调用子View的dispatchTouchEvent(event)方法继续分发事件 consume = child.dispatchTouchEvent(event); &#125; return consume;&#125; Touch 事件分发中只有两个主角：ViewGroup 和 View。ViewGroup 包含 onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent 三个相关事件。View 包含 dispatchTouchEvent、onTouchEvent 两个相关事件。其中 ViewGroup 又继承于 View。 ViewGroup 和 View 组成了一个树状结构，根节点为 Activity 内部包含的一个 ViewGroup。 触摸事件由 Action Down、Action Move、Action Up 组成，其中一次完整的触摸事件中，Down 和 Up 都只有一个，Move 有若干个，可以为 0 个。 当 Activity 接收到 Touch 事件时，将遍历子 View 进行 Down 事件的分发。ViewGroup 的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的 View，这个 View 会在 onTouchEvent 结果返回 true。 当某个子 View 返回 true 时，会终止 Down 事件的分发，同时在 ViewGroup 中记录该子 View。接下去的 Move 和 Up 事件将由该子 View 直接进行处理。由于子 View 是保存在 ViewGroup 中的，多层 ViewGroup 的节点结构时，上级 ViewGroup 保存的会是真实处理事件的 View 所在的 ViewGroup 对象：如 ViewGroup0-ViewGroup1-TextView 的结构中，TextView 返回了 true，它将被保存在 ViewGroup1 中，而 ViewGroup1 也会返回 true，被保存在 ViewGroup0 中。当 Move 和 Up 事件来时，会先从 ViewGroup0 传递至 ViewGroup1，再由 ViewGroup1 传递至 TextView。 当 ViewGroup 中所有子 View 都不捕获 Down 事件时，将触发 ViewGroup 自身的 onTouch 事件。触发的方式是调用 super.dispatchTouchEvent 函数，即父类 View 的 dispatchTouchEvent 方法。在所有子 View 都不处理的情况下，触发 Activity 的 onTouchEvent 方法。 onInterceptTouchEvent 有两个作用：1.拦截 Down 事件的分发。2.终止 Up 和 Move 事件向目标 View 传递，使得目标 View 所在的 ViewGroup 捕获 Up 和 Move 事件。 描述一下View的绘制原理？ View的绘制流程主要分为三步： onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成绘制工作。 onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。 onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。 requestLayout()、invalidate()与postInvalidate()有什么区别？ requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定会触发onDraw()方法。 invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。 postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。 一般说来需要重新布局就调用requestLayout()方法，需要重新绘制就调用invalidate()方法。 Scroller用过吗，了解它的原理吗？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356//实例化Scroller对象，在自定义View中，mContext可以在自定义View的构造方法中获取Scroller mScroller = new Scroller(mContext);//在一个自定义View中实现该方法，方法名可以自定义public void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int scrollY = getScrollY(); int dx = destX - scrollX; int dy = destY - scrollY; //前两个参数表示起始位置，第三第四个参数表示位移量，最后一个参数表示时间 mScroller.startScroll(scrollX,scrollY,dx,dy,1000); invalidate();&#125;//自定义View中重写该方法@Overridepublic void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); &#125;&#125;``` Scroller滑动的整个过程(图片From：https://img-blog.csdn.net/20160919174056964)&lt;img src="https://img-blog.csdn.net/20160919174056964"/&gt;### 了解APK的打包流程吗，描述一下？Android的包文件APK分为两个部分：代码和资源，所以打包方面也分为资源打包和代码打包两个方面，这篇文章就来分析资源和代码的编译打包原理。APK整体的的打包流程如下图所示：&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/vm/apk_package_flow.png"/&gt;具体说来：1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。3. 通过Javac工具编译项目源码，生成Class文件。4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。6. 利用KeyStore对生成的APK文件进行签名。7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件的速度会更快。### 了解APK的安装流程吗，描述一下？APK的安装流程如下所示：&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/package/apk_install_structure.png" width="600"/&gt;1. 复制APK到/data/app目录下，解压并扫描安装包。2. 资源管理器解析APK里的资源文件。3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。5. 安装完成后，发送广播。### 当点击一个应用图标以后，都发生了什么，描述一下这个过程？点击应用图标后会去启动应用的LauncherActivity，如果LancerActivity所在的进程没有创建，还会创建新进程，整体的流程就是一个Activity的启动流程。Activity的启动流程图（放大可查看）如下所示：![Activity的启动流程图](https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_start_flow.png)整个流程涉及的主要角色有：- Instrumentation: 监控应用与系统相关的交互行为。- AMS：组件管理调度中心，什么都不干，但是什么都管。- ActivityStarter：Activity启动的控制器，处理Intent与Flag对Activity启动的影响，具体说来有：1 寻找符合启动条件的Activity，如果有多个，让用户选择；2 校验启动参数的合法性；3 返回int参数，代表Activity是否启动成功。- ActivityStackSupervisior：这个类的作用你从它的名字就可以看出来，它用来管理任务栈。- ActivityStack：用来管理任务栈里的Activity。- ActivityThread：最终干活的人，是ActivityThread的内部类，Activity、Service、BroadcastReceiver的启动、切换、调度等各种操作都在这个类里完成。注：这里单独提一下ActivityStackSupervisior，这是高版本才有的类，它用来管理多个ActivityStack，早期的版本只有一个ActivityStack对应着手机屏幕，后来高版本支持多屏以后，就有了多个ActivityStack，于是就引入了ActivityStackSupervisior用来管理多个ActivityStack。整个流程主要涉及四个进程：- 调用者进程，如果是在桌面启动应用就是Launcher应用进程。- ActivityManagerService等所在的System Server进程，该进程主要运行着系统服务组件。- Zygote进程，该进程主要用来fork新进程。- 新启动的应用进程，该进程就是用来承载应用运行的进程了，它也是应用的主线程（新创建的进程就是主线程），处理组件生命周期、界面绘制等相关事情。![img](http://upload-images.jianshu.io/upload_images/3985563-b7edc7b70c9c332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)有了以上的理解，整个流程可以概括如下：1. 点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。2. AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。3. Zygote接收到新进程创建请求后fork出新进程。4. 在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。5. ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。### BroadcastReceiver与LocalBroadcastReceiver有什么区别？- BroadcastReceiver 是跨应用广播，利用Binder机制实现。- LocalBroadcastReceiver 是应用内广播，利用Handler实现，利用了IntentFilter的match功能，提供消息的发布与接收功能，实现应用内通信，效率比较高。### Android Handler机制是做什么的，原理了解吗？Android消息循环流程图如下所示：&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_structure.png"/&gt;主要涉及的角色如下所示：- Message：消息，分为硬件产生的消息（例如：按钮、触摸）和软件产生的消息。- MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。- Looper：消息循环器，主要用来把消息分发给相应的处理者。- Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。整个消息的循环流程还是比较清晰的，具体说来：1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。2. Looper通过loop()不断提取触发条件的Message，并将Message交给对应的target handler来处理。3. target handler调用自身的handleMessage()方法来处理Message。事实上，在整个消息循环的流程中，并不只有Java层参与，很多重要的工作都是在C++层来完成的。我们来看下这些类的调用关系。&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_class.png"/&gt;注：虚线表示关联关系，实线表示调用关系。在这些类中MessageQueue是Java层与C++层维系的桥梁，MessageQueue与Looper相关功能都通过MessageQueue的Native方法来完成，而其他虚线连接的类只有关联关系，并没有直接调用的关系，它们发生关联的桥梁是MessageQueue。### Android Binder机制是做什么的，为什么选用Binder，原理了解吗？Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种：1. 管道：在创建时分配一个page大小的内存，缓存区大小比较有限；2. 消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；3. 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；4. 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；5. 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。6. 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量：- 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。- 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。- 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传送IPC只能由用户在数据包里填入UID/PID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。### 描述一下Activity的生命周期，这些生命周期是如何管理的？Activity与Fragment生命周期如下所示：&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/complete_android_fragment_lifecycle.png"/&gt;读者可以从上图看出，Activity有很多种状态，状态之间的变化也比较复杂，在众多状态中，只有三种是常驻状态：- Resumed（运行状态）：Activity处于前台，用户可以与其交互。- Paused（暂停状态）：Activity被其他Activity部分遮挡，无法接受用户的输入。- Stopped（停止状态）：Activity被完全隐藏，对用户不可见，进入后台。其他的状态都是中间状态。我们再来看看生命周期变化时的整个调度流程，生命周期调度流程图如下所示：&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_lifecycle_structure.png" /&gt;所以你可以看到，整个流程是这样的：1. 比方说我们点击跳转一个新Activity，这个时候Activity会入栈，同时它的生命周期也会从onCreate()到onResume()开始变换，这个过程是在ActivityStack里完成的，ActivityStack是运行在Server进程里的，这个时候Server进程就通过ApplicationThread的代理对象ApplicationThreadProxy向运行在app进程ApplicationThread发起操作请求。2. ApplicationThread接收到操作请求后，因为它是运行在app进程里的其他线程里，所以ApplicationThread需要通过Handler向主线程ActivityThread发送操作消息。3. 主线程接收到ApplicationThread发出的消息后，调用主线程ActivityThread执行响应的操作，并回调Activity相应的周期方法。注：这里提到了主线程ActivityThread，更准确来说ActivityThread不是线程，因为它没有继承Thread类或者实现Runnable接口，它是运行在应用主线程里的对象，那么应用的主线程到底是什么呢？从本质上来讲启动启动时创建的进程就是主线程，线程和进程处理是否共享资源外，没有其他的区别，对于Linux来说，它们都只是一个struct结构体。### Activity的通信方式有哪些？- startActivityForResult- EventBus- LocalBroadcastReceiver### Android应用里有几种Context对象，Context类图如下所示：&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/context_uml.png" width="600" /&gt;可以发现Context是个抽象类，它的具体实现类是ContextImpl，ContextWrapper是个包装类，内部的成员变量mBase指向的也是个ContextImpl对象，ContextImpl完成了实际的功能，Activity、Service与Application都直接或者间接的继承ContextWrapper。### 描述一下进程和Application的生命周期？一个安装的应用对应一个LoadedApk对象，对应一个Application对象，对于四大组件，Application的创建和获取方式也是不尽相同的，具体说来：- Activity：通过LoadedApk的makeApplication()方法创建。- Service：通过LoadedApk的makeApplication()方法创建。- 静态广播：通过其回调方法onReceive()方法的第一个参数指向Application。- ContentProvider：无法获取Application，因此此时Application不一定已经初始化。### Android哪些情况会导致内存泄漏，如何分析内存泄漏？* 内存溢出OOM和内存泄露(对象无法被回收)的区别 内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer，但给它存了long才能存下的数，那就是内存溢出。内存溢出通俗的讲就是内存不够用。 内存泄漏 memory leak：是指程序在申请内存后，无法释放自己申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。 常见的产生内存泄漏的情况如下所示：- 持有静态的Context（Activity）引用。- 持有静态的View引用，- 内部类&amp;匿名内部类实例无法释放（有延迟时间等等），而内部类又持有外部类的强引用，导致外部类无法释放，这种匿名内部类常见于监听器、Handler、Thread、TimerTask- 资源使用完成后没有关闭，例如：BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap。- 不正确的单例模式，比如单例持有Activity。- 集合类内存泄漏，如果一个集合类是静态的（缓存HashMap），只有添加方法，没有对应的删除方法，会导致引用无法被释放，引发内存泄漏。- 错误的覆写了finalize()方法，finalize()方法执行执行不确定，可能会导致引用无法被释放。查找内存泄漏可以使用Android Profiler工具或者利用LeakCanary工具。### Android有哪几种进程，是如何管理的？Android的进程主要分为以下几种：**前台进程**用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：- 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）- 托管某个 Service，后者绑定到用户正在交互的 Activity- 托管正在“前台”运行的 Service（服务已调用 startForeground()）- 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）- 托管正执行其 onReceive() 方法的 BroadcastReceiver通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。**可见进程**没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：- 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。- 托管绑定到可见（或前台）Activity 的 Service。可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。**服务进程**正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。**后台进程**包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。**空进程**不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。ActivityManagerService负责根据各种策略算法计算进程的adj值，然后交由系统内核进行进程的管理。### SharePreference性能优化，可以做进程同步吗？在Android中, SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/ &lt; package name &gt; /shared_prefs目录下.之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会把整个文件全部加载进内存，如果SharedPreference文件比较大，会带来以下问题：1. 第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。2. 解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。3. 这些key和value会永远存在于内存之中，占用大量内存。优化建议1. 不要存放大的key和value，会引起界面卡、频繁GC、占用内存等等。2. 毫不相关的配置项就不要放在在一起，文件越大读取越慢。3. 读取频繁的key和不易变动的key尽量不要放在一起，影响速度，如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失。4. 不要乱edit和apply，尽量批量修改一次提交，多次apply会阻塞主线程。5. 尽量不要存放JSON和HTML，这种场景请直接使用JSON。6. SharedPreference无法进行跨进程通信，MODE_MULTI_PROCESS只是保证了在API 11以前的系统上，如果sp已经被读取进内存，再次获取这个SharedPreference的时候，如果有这个flag，会重新读一遍文件，仅此而已。### 如何做SQLite升级？数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：1. 将现有表命名为临时表。2. 创建新表。3. 将临时表的数据导入新表。4. 删除临时表。重写如果是跨版本数据库升级，可以由两种方式，如下所示：1. 逐级升级，确定相邻版本与现在版本的差别，V1升级到V2,V2升级到V3，依次类推。2. 跨级升级，确定每个版本与现在数据库的差别，为每个case编写专门升级大代码。### 进程保护如何做，如何唤醒其他进程？进程保活主要有两个思路：1. 提升进程的优先级，降低进程被杀死的概率。2. 拉活已经被杀死的进程。如何提升优先级，如下所示：监控手机锁屏事件，在屏幕锁屏时启动一个像素的Activity，在用户解锁时将Activity销毁掉，前台Activity可以将进程变成前台进程，优先级升级到最高。如果拉活利用广播拉活Activity。### 理解序列化吗，Android为什么引入Parcelable？所谓序列化就是将对象变成二进制流，便于存储和传输。- Serializable是java实现的一套序列化方式，可能会触发频繁的IO操作，效率比较低，适合将对象存储到磁盘上的情况。- Parcelable是Android提供一套序列化机制，它将序列化后的字节流写入到一个共性内存中，其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息。### 如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存注：这里inDensity表示目标图片的dpi（放在哪个资源文件夹下），inTargetDensity表示目标屏幕的dpi，所以你可以发现inDensity和inTargetDensity会对Bitmap的宽高进行拉伸，进而改变Bitmap占用内存的大小。在Bitmap里有两个获取内存占用大小的方法。- getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。- getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 getByteCount() 方法。在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。为了保证在加载Bitmap的时候不产生内存溢出，可以受用BitmapFactory进行图片压缩，主要有以下几个参数：- BitmapFactory.Options.inPreferredConfig：将ARGB_8888改为RGB_565，改变编码方式，节约内存。- BitmapFactory.Options.inSampleSize：缩放比例，可以参考Luban那个库，根据图片宽高计算出合适的缩放比例。- BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。### Android如何在不压缩的情况下加载高清大图？使用BitmapRegionDecoder进行布局加载。### Android里的内存缓存和磁盘缓存是怎么实现的。内存缓存基于LruCache实现，磁盘缓存基于DiskLruCache实现。这两个类都基于Lru算法和LinkedHashMap来实现。LRU算法可以用一句话来描述，如下所示：&gt;LRU是Least Recently Used的缩写，最近最久未使用算法，从它的名字就可以看出，它的核心原则是如果一个数据在最近一段时间没有使用到，那么它在将来被访问到的可能性也很小，则这类数据项会被优先淘汰掉。LruCache的原理是利用LinkedHashMap持有对象的强引用，按照Lru算法进行对象淘汰。具体说来假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。 为什么会选择LinkedHashMap呢？这跟LinkedHashMap的特性有关，LinkedHashMap的构造函数里有个布尔参数accessOrder，当它为true时，LinkedHashMap会以访问顺序为序排列元素，否则以插入顺序为序排序元素。DiskLruCache与LruCache原理相似，只是多了一个journal文件来做磁盘文件的管理和迎神，如下所示： libcore.io.DiskLruCache111 DIRTY 1517126350519CLEAN 1517126350519 5325928REMOVE 1517126350519123456789101112注：这里的缓存目录是应用的缓存目录/data/data/pckagename/cache，未root的手机可以通过以下命令进入到该目录中或者将该目录整体拷贝出来：```java//进入/data/data/pckagename/cache目录adb shellrun-as com.your.packagename cp /data/data/com.your.packagename///将/data/data/pckagename目录拷贝出来adb backup -noapk com.your.packagename 我们来分析下这个文件的内容： 第一行：libcore.io.DiskLruCache，固定字符串。 第二行：1，DiskLruCache源码版本号。 第三行：1，App的版本号，通过open()方法传入进去的。 第四行：1，每个key对应几个文件，一般为1. 第五行：空行 第六行及后续行：缓存操作记录。 第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以下三点： DIRTY 表示一个entry正在被写入。写入分两种情况，如果成功会紧接着写入一行CLEAN的记录；如果失败，会增加一行REMOVE记录。注意单独只有DIRTY状态的记录是非法的。 当手动调用remove(key)方法的时候也会写入一条REMOVE记录。 READ就是说明有一次读取的记录。 CLEAN的后面还记录了文件的长度，注意可能会一个key对应多个文件，那么就会有多个数字。 Android 中跨进程通讯的几种方式 Android 跨进程通信，像 Intent，contentProvider，broadcast，service 都可以跨进程通信。 Intent：这种跨进程方式并不是访问内存的形式，它需要传递一个 uri，比如打电话 contentProvider：这种形式是使用数据共享的方式进行数据共享 service：远程服务，aidl 广播： 保存 Activity 状态onSaveInstanceState(Bundle)会在 activity 转入后台状态之前调用，也就是 onStop()方法之前，onPause 方法之后被调用； Android 中的几种动画 帧动画：指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果，比如音乐的律动条 补间动画：指通过指定 View 的初始状态、变化时间、方式，通过一系列的算法去进行图形变换，从而形成动画效果，主要有 Alpha、Scale、Translate、Rotate 四种效果。注意：只是在视图层实现了动画效果，并没有真正改变 View 的属性，比如滑动列表，改变标题栏的透明度。 属性动画：在 Android3.0 的时候才支持，通过不断的改变 View 的属性，不断的重绘而形成动画效果。相比于视图动画，View 的属性是真正改变了。比如 View 的旋转，放大，缩小。 PathClassLoader与DexClassLoader有什么区别？ PathClassLoader：只能加载已经安装到Android系统的APK文件，即/data/app目录，Android默认的类加载器。 DexClassLoader：可以加载任意目录下的dex、jar、apk、zip文件。 WebView优化了解吗，如何提高WebView的加载速度？为什么WebView加载会慢呢？ 这是因为在客户端中，加载H5页面之前，需要先初始化WebView，在WebView完全初始化完成之前，后续的界面加载过程都是被阻塞的。 优化手段围绕着以下两个点进行： 预加载WebView。 加载WebView的同时，请求H5页面数据。 因此常见的方法是： 全局WebView。 客户端代理页面请求。WebView初始化完成后向客户端请求数据。 asset存放离线包。 除此之外还有一些其他的优化手段： 脚本执行慢，可以让脚本最后运行，不阻塞页面解析。 DNS与链接慢，可以让客户端复用使用的域名与链接。 React框架代码执行慢，可以将这部分代码拆分出来，提前进行解析。 保存 Activity 状态Java和JS的相互调用怎么实现，有做过什么优化吗？jockeyjs：https://github.com/tcoulter/jockeyjs 对协议进行统一的封装和处理。 JNI了解吗，Java与C++如何相互调用？Java调用C++ 在Java中声明Native方法（即需要调用的本地方法） 编译上述 Java源文件javac（得到 .class文件） 通过 javah 命令导出JNI的头文件（.h文件） 使用 Java需要交互的本地代码 实现在 Java中声明的Native方法 编译.so库文件 通过Java命令执行 Java程序，最终实现Java调用本地代码 C++调用Java 从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。 获取类的默认构造方法ID。 查找实例方法的ID。 创建该类的实例。 调用对象的实例方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod (JNIEnv *env, jclass cls) &#123; jclass clazz = NULL; jobject jobj = NULL; jmethodID mid_construct = NULL; jmethodID mid_instance = NULL; jstring str_arg = NULL; // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象 clazz = (*env)-&gt;FindClass(env, "com/study/jnilearn/ClassMethod"); if (clazz == NULL) &#123; printf("找不到'com.study.jnilearn.ClassMethod'这个类"); return; &#125; // 2、获取类的默认构造方法ID mid_construct = (*env)-&gt;GetMethodID(env,clazz, "&lt;init&gt;","()V"); if (mid_construct == NULL) &#123; printf("找不到默认的构造方法"); return; &#125; // 3、查找实例方法的ID mid_instance = (*env)-&gt;GetMethodID(env, clazz, "callInstanceMethod", "(Ljava/lang/String;I)V"); if (mid_instance == NULL) &#123; return; &#125; // 4、创建该类的实例 jobj = (*env)-&gt;NewObject(env,clazz,mid_construct); if (jobj == NULL) &#123; printf("在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法"); return; &#125; // 5、调用对象的实例方法 str_arg = (*env)-&gt;NewStringUTF(env,"我是实例方法"); (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,200); // 删除局部引用 (*env)-&gt;DeleteLocalRef(env,clazz); (*env)-&gt;DeleteLocalRef(env,jobj); (*env)-&gt;DeleteLocalRef(env,str_arg); &#125; 了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？ 插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。 热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。 利用PathClassLoader和DexClassLoader去加载与bug类同名的类，替换掉bug类，进而达到修复bug的目的，原理是在app打包的时候阻止类打上CLASS_ISPREVERIFIED标志，然后在热修复的时候动态改变BaseDexClassLoader对象间接引用的dexElements，替换掉旧的类。 目前热修复框架主要分为两大类： Sophix：修改方法指针。 Tinker：修改dex数组元素。 如何做性能优化？ 节制的使用Service，当启动一个Service时，系统总是倾向于保留这个Service依赖的进程，这样会造成系统资源的浪费，可以使用IntentService，执行完成任务后会自动停止。 当界面不可见时释放内存，可以重写Activity的onTrimMemory()方法，然后监听TRIM_MEMORY_UI_HIDDEN这个级别，这个级别说明用户离开了页面，可以考虑释放内存和资源。 对图片本身进行操作。尽量不要使用 setImageBitmap、setImageResource、BitmapFactory.decodeResource 来设置一张大图，因为这些方法在完成 decode 后，最终都是通过 java 层的 createBitmap 来完成的，需要消耗更多内存。 避免在Bitmap浪费过多的内存，使用压缩过的图片，也可以使用Fresco等库来优化对Bitmap显示的管理。不用的图片记得调用图片的 recycle()方法回收。 使用优化过的数据集合SparseArray代替HashMap，HashMap为每个键值都提供一个对象入口，使用SparseArray可以免去基本对象类型转换为引用数据类想的时间。 ANRANR 全名 Application Not Responding，也就是“应用无响应”。当操作在一段时间内系统无法处理时，系统层面会弹出 ANR 对话框产生原因&amp;解决方法： 5s 内无响应用户输入事件(例如键盘输入，触摸屏幕等)。 不要在主线程中做耗时操作，而应在子线程中来实现。如 onCreate()和 onResume()里尽可能少的去做创建操作。 BroadcastReceiver 在 10s 内无法结束 应用程序应该避免在 BroadcastReceiver 里做耗时操作或计算。 避免在 IntentReceiver 里启动一个 Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点 Service 20s 内无法结束 service 是运行在主线程的，所以再 service 中做耗时操作，必须要放在子线程中。 如果防止过度绘制，如何做布局优化？ 使用include复用布局文件。 使用merge标签避免嵌套布局。 使用stub标签仅在需要的时候在展示出来。 如何提交代码质量？ 避免创建不必要的对象，尽可能避免频繁的创建临时对象，例如在for循环内，减少GC的次数。 尽量使用基本数据类型代替引用数据类型。 静态方法调用效率高于动态方法，也可以避免创建额外对象。 对于基本数据类型和String类型的常量要使用static final修饰，这样常量会在dex文件的初始化器中进行初始化，使用的时候可以直接使用。 多使用系统API，例如数组拷贝System.arrayCopy()方法，要比我们用for循环效率快9倍以上，因为系统API很多都是通过底层的汇编模式执行的，效率比较高。 有没有遇到64k问题，为什么，如何解决？ 在DEX文件中，method、field、class等的个数使用short类型来做索引，即两个字节（65535），method、field、class等均有此限制。 APK在安装过程中会调用dexopt将DEX文件优化成ODEX文件，dexopt使用LinearAlloc来存储应用信息，关于LinearAlloc缓冲区大小，不同的版本经历了4M/8M/16M的限制，超出缓冲区时就会抛出INSTALL_FAILED_DEXOPT错误。 解决方案是Google的MultiDex方案，具体参见：配置方法数超过 64K 的应用。 MVC、MVP与MVVM之间的对比分析？ MVC：PC时代就有的架构方案，在Android上也是最早的方案，Activity/Fragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到耦合过重，Activity/Fragment类过大等问题。 MVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。 MVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享ViewModel数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础汇总]]></title>
    <url>%2F2018%2F03%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[计算机网络体系分类：计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。 OSI七层模型 TCP/IP四层模型 应用层 —- 表示层 应用层 会话层 —- 传输层 传输层 网络层 网络层 数据链路层 物理接入层 物理层 —- 物理层：物理层主要是实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。 通信方式： 单工通信：只能由A主机向B主机发送消息，通信是单向的。 半双工通信：同一时间只能是由A主机向B主机或者是B主机向A主机发送信息，不能同时发送消息。 全双工通信： A主机和B主机可以实现在同一时间内既接收消息，又发送消息，极大的提升了通信效率。 常见引导型传输媒体：双绞线：分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP），屏蔽双绞线就是在非屏蔽双绞线外边又加了一层屏蔽层 tips：为什么双绞线要两根线绞起来，两个线绞起来可以有效的减少相互之间的电磁干扰。 同轴电缆：由内导体铜制芯线，绝缘层，网状编织的外导体屏蔽层，以及塑料保护外层组成。有良好的抗干扰性，被广泛用于较高速率的传输。 光缆：由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通讯柱。可以分为单模光纤和多模光纤。 信道复用技术： 频分复用：根据传输的波的频率的不同，将不同频段的波用于不同的通信。 时分复用：将时间分割为时间段，规定在某个时间段内发送什么样的信息，根据时间段来进行信息类别的区分。也称为同步时分复用 统计时分复用：基于时分复用的一种改进，由于基本的时分复用并没有考虑到每个时间段内是否有信息发出，例如说每个时间段是20，但是发送消息只占用其中的2，那么剩下的18就处于空闲时间。统计时分复用就是基于这种考虑而设计的，他允许用户有数据时就将数据发送到缓存中，然后会依次扫描输入缓存，把缓存中的数据放入到STMD帧中，若没有就跳过，每当一个帧满了就把这个帧发出去。STMD帧不是分配的固定时序，而是根据需要动态的分配时隙，也称之为异步时分复用 光分复用：就是光的频分复用，根据光谱中频率的不同，用不同频率的光来携带不同的信息。 数据链路层：数据链路层主要是将上层的数据转化为数据帧发送到链路上，以及把接受到的帧中的数据取出并交给网络层。 通信方式： 点对点通信：通信方式是点到点的，也就是只能是两个点之间的通信。常见的就是PPP协议 广播通信：广播通讯，也就是可以同时实现一对多的通信。常见的就是CSMA/CD（载波监听多点访问/冲突检测） 核心要解决的问题： 封装成帧：在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在接受到后就可以方便准确的确定帧的首尾，也称为帧定界符。同时定义出了最大传输单元（MTU）–表示一次可以传输的最大长度上限。 透明传输： 由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的转义字符，这种方法称为字符填充或者是字节填充。 差错检测： 比特在传输过程中可能产生差错，差错检测就是用于检测出现的差错，以便及时的重传，最常用的差错检测算法就是CRC（循环冗余检验） 网络层网络层主要是向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。 IP协议（网际协议）：IP协议是TCP/IP体系中最主要的协议之一，一切在IP之下，一切又在IP之上。我们常说的应该是IP协议族，还包含配套的协议： ARP（地址解析协议）：将网络的IP地址转化为实际的物理地址（MAC地址），并存储在MAC地址表中。 ICMP（网际控制报文协议）：用于进行差错情况和异常情况的反馈，分为询问报文和差错报告报文。 IGMP（网际组管理协议）：用于控制和管理多播和组播的协议。 网络地址（IP地址）主要分为五类： A类：前8位为网络位，后24位为主机位，首位为0 B类：前16位为网络位，后16位为主机位，前两位为10 C类：前24位为网络位，后8位位主机位，前三位为110 D类：前四位为1110，用于多播地址 E类：前四位为1111，保留为以后使用 路由选择协议：路由选择协议分为内部网关协议（IGP）和外部网关协议（EGP） 内部网关协议：主要是有RIP协议和OSPF协议 RIP协议（路由信息协议）：基于距离矢量的协议 OSPF（开放最短路径优先协议）：基于链路状态的协议 外部网关协议：主要是边界网关协议（BGP），将一个大的网络分为多个小的自治域，每个自治域内有一个网关路由负责和其他的自治域的网关进行通讯。 传输层网络层主要是为主机之间提供逻辑通讯，而传输层为应用程序之间提供端到端的逻辑通讯。主要是两种类型的通讯方式，面向连接的TCP协议和面向无连接的UDP。 端口号：端口号按照使用地方的不同分为两大类：服务端端口号，客户端端口号。按照占用时长又可以分为熟知端口号（0~1023），登记端口号（1024~49151），短暂端口号（49152~65535） 常见端口： FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制 Telnet（远程登录协议）：23 DNS（域名解析服务）：53 TFTP（简单文件传输协议）：69 HTTP（超文本传输协议）：80 两种协议： UDP（用户数据报协议）： UDP是无连接的 UDP使用尽最大努力交付，但是不保证可靠交付 UDP是面向报文的 UDP没有拥塞控制 UDP支持一对一，一对多，多对一，多对一的交互通讯 UDP首部的开销小 TCP（传输控制协议）： TCP是面向连接的 每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的$TCP连接：：= { socket_1,socket_2 } ={ (IP_1:port_1),(IP_2:port_2)}$ TCP提供可靠交付的服务 TCP提供全双工通信 面向字节流 可靠传输的实现机制： 停止等待协议： 每发完一个分组就停止发送，直到收到上一个分组的确认信息。若超过规定时间没有接收到确认信息，边认为是分组丢失，开始重传。 连续ARQ协议： 发送方采用滑动窗口的形式，处于滑动窗口的分组可以直接发送出去；接收方一般采用累积确认的方式，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认，而发送方每接收到一个确认，窗口就向前滑动一定距离。 流量控制：协调发送方和接收方的收发速率，利用滑动窗口来协调，使用探测报文来探测当前应该发送的速率，采用Nagle算法 拥塞控制：当网络中某一资源的需求超出了该资源所能提供的可用部分，这时网络的性能就要开始变坏，这种情况就叫做拥塞。而拥塞控制就是为了减少或者避免拥塞对网络性能的影响而做出的一种控制手段。 拥塞控制思路：发送方维持一个叫做拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化。发送方让自己的发送窗口等于拥塞窗口，如果在考虑接收方的接收能力，一般发送窗口还要小于拥塞窗口。 慢开始：当主机开始发送数据的时候，由小到大的增大发送窗口，也就是由小到大的增大拥塞窗口。接收方接收到一个报文之后就回传一个确认报文，发送方每接收到一个确认报文，就将拥塞窗口加1，这样每经过一个传输轮次之后，拥塞窗口就增大一倍。 拥塞避免：思路是让拥塞窗口缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，而不是加倍，这样拥塞窗口就是线性缓慢增加，比慢开始的增长速率缓慢的多。 慢开始门限：为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限 拥塞窗口&lt;慢开始门限时，使用慢开始算法 拥塞窗口&gt;慢开始门限时，使用拥塞避免算法 拥塞窗口=慢开始门限时，两种算法都可以 快重传：要求收到方每收到一个时序的报文段之后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。而发送方只要一连收到三个重复确认就应当立即重传对方尚未接受到的报文，而不必等待为报文设置的重传计时器到期。 快回复：与快重传配合使用，当发送方连续收到三个重复确认的时候，就执行“乘法减小”算法，将慢开始门限减半。将拥塞窗口设置为慢开始门限减半之后的值，并开始指向拥塞避免算法。 TCP的连接管理：连接三次握手： 客户端请求建立连接：SYN=1，seq=x； 服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1 客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1 注： SYN为同步信息，在建立连接过程中始终为1 断开连接四次握手： 客户端请求断开连接： FIN=1，seq = u； 服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1； 服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1； 客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1； 应用层应用层有多种协议，常用到的就是HTTP以及HTTPS。 HTTP协议报文格式 请求报文 相应报文 请求行（用于区分是请求报文还是响应报文，在响应报文中为状态行） 状态行 首部行（用来说明浏览器，服务器或者是报文主体的一些信息） 首部行 空行（用于隔开请求实体和首部行） 空行 实体主体（用于一些请求或者是响应的的参数内容等） 实体主体 常见状态码 1xx：表示通知信息，例如表示收到或者是正在处理2xx：表示成功，例如表示接受或知道了3xx：表示重定向，例如表示完成请求还需要采取进一步的行动4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成5xx：表示服务器端的差错：例如表示服务器失效无法完成请求 HTTPS协议就是对HTTP协议的加密，更加安全可靠，采用HTTP+SSL（安全套接字层）来保证数据的安全性。]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个图片从读取到显示在屏幕上的整个渲染过程]]></title>
    <url>%2F2018%2F03%2F29%2F%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E4%BB%8E%E8%AF%BB%E5%8F%96%E5%88%B0%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[显示流程整个过程可分为三步 得到位图（Bitmap）的内存数据，即从相应的图片文件解码，得到数据放并放到内存。 使用某种2D引擎，将位图内存按一定方式，渲染到可用于显示的图形内存（GraphicBuffer）上。 由一个中心显示控制器（Surfaceflinger），将相应的图形内存投放到显示屏（LCD）。 显示流程 从图片文件到位图 找到合适的图片文件当把风景图片放在drawable目录时，Android系统中会根据设备的分辨率，去相应分辨率的目录选择图片文件。然而，我们把图片放在asset目录下，用 asset manager 去打开时，或者放在sdcard下，就不存在这个一个适配过程，系统会忠实地读取指定路径的文件。 将图片文件解码到内存，形成位图（Bitmap）解码器一般使用系统的，Android中是以Skia主导解码的过程。具体往下用硬件解码还是软件解码，就由芯片厂商决定了。不过，绝大部分Android设备的硬解码和硬编码都用于自家的应用（比如拍照），对第三方应用开放的只有软件编解码。 图像编解码都是很复杂的算法，google提供的Android版本里对此也是不断进行着优化，导致系统的编解码库性能一般来说是很优秀的。如果没有专业的算法优化人员，就不要指望靠移植第三方库打败系统的解码器了。 load 就更一般的场景而言，图片原始来源于磁盘、网络或图形内存（Android部分系统图片预加载）。如何在导入大量图片时不致出现内存溢出，如何快速导入一个页面的图片以免用户产生等待感，是个复杂的事情。许多开源图片缓存框架（如imageloader）就在这一过程做文章，不多述。 从位图到图形内存Android向应用开发者开放的惟一一条显示的路径是View。不管想显示什么，都必须先弄个布局，然后把要显示的内容和布局中的View关联起来。 布局，确定View本身位置在上面的UI显示图中，我们发现，图并没有横向填满手机屏幕，这是由于布局中设置了留白造成的： 1234android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; 布局就是每个View的measure和layout过程，Android图形系统的framework层解析布局文件，去计算每个View的位置。本文的例子中，是 RelativeLayout —— ImageView 的解析过程。 布局解析的一般流程参考以下文章：http://blog.csdn.net/qinjuning/article/details/8074262 渲染，把位图画上图形内存不考虑SurfaceView的非主线渲染，只考虑主线渲染的两个分支：软件绘制（skia）与硬件加速绘制（hwui）。软件绘制下，由位图直接画上去。硬件加速绘制，实际上是GPU绘制的情况下，需要先把位图上传到GPU形成纹理，再基于纹理采样，渲染到图形内存上。 draw 看上去，GPU绘图需要先上传为Texture，明显多了一步，但请考虑如下的问题： 大部分情况，把位图画上图形内存，不是简单的memcpy。如本处的风景照，很明显就需要缩小。这种情况下，CPU绘制需要先采样，这是很慢的。 绘制不是一次性的工作，它是要刷帧的。使用GPU绘制时，纹理上传固然在第一次时增加了启动时间，但后续并不需要重做，可以继续使用GPU强大的渲染能力。 从图形内存到显示屏这一套流程便是Android的下层显示内容。SurfaceFlinger汇集所有图层的信息，采用离线合成或在线合成的方式，将图形内存的内容送达显示屏LCD。 参见 http://blog.csdn.net/jxt1234and2010/article/details/46057267 更好的方案？1. 既然到图形内存才能显示，为什么不直接解码到图形内存？当然可以，开机动画就是这么搞的，解到图形内存直接显示。不过，由于图形内存是一种进程间共享内存，需要作很多额外的同步、映射等管理工作。对于一般的应用场景，在自己的进程空间申请内存，无疑是更方便管理的，也不会造成系统的额外负担。 2. 解码图片需要时间，可不可以一开始就用原始位图，跳过这一过程？当然可以，Android的系统图库会为每一张照片创建一张缩略图，这一张缩略图就是无压缩的位图格式，以便用户快速看到预览的照片。但当像素值比较大时，原始位图实在是太大了，相机拍出来一张800w像素的图片接近32M，存储设备和网络传输都吃不消。 一种更好的方法是使用压缩纹理，这样既能省去解码图片的时间，又能减少渲染时所需要的读取内存量。但这个存在如下问题：第一个问题是，Android的硬件加速机制是基于软件绘制流程修改而来的，它需要与软件绘制有相同的上层接口，这就意味着，软件绘制也要设法支持这种模式。让软件绘制支持压缩纹理的解压是不大现实的，不过呢，可以考虑副本的模式，即同时提供jpg/png和压缩纹理的资源。第二个问题更加棘手，移动设备的GPU是分散的，所提供的压缩纹理格式也互不相同，虽然有ETC1和ETC2作为标准格式，但其显示效果差强人意。 3. 就显示一张图片，为什么要合成，直接传给LCD不可以么？当然可以，这就是所谓的Overlay技术，进一步，是在线合成。据说，ios的图库显示照片时正是这么做的。不过，使用这个技术有很多坑。第一个坑是Buffer循环机制，处理不好，就容易出现裂屏。第二个坑是千奇百怪的布局位置，单个图层辅满显示屏好处理，但纯大部分情况是多个图层各占屏幕的一部分，另外还会有重叠的情况。第三个坑则是后处理需求，有时候缩放和旋转会延迟到合成阶段做处理，直接传给LCD时如何做这些处理也是个问题。 在理解清楚原理后，找到性能瓶颈并发现优化点，并不是件难事，但怎么针对性地实施优化并兼容原有系统这么一个宏大的体系，就不是那么好做了 。不过，解决问题的关键还是原理要正确，要相信，只要原理是正确的，流程上即便千般阻碍，最终也能达到目标的。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView为什么会替代scrollView]]></title>
    <url>%2F2018%2F03%2F22%2FRecyclerView%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9B%BF%E4%BB%A3scrollView%2F</url>
    <content type="text"><![CDATA[2018-03-21 19:35 广州腾讯视频Android岗打来了面试电话…此次面试中发现了自己的薄弱与不足…甚至被问到一个从来也没有想过需要去比较的View…最后一个问题： 问：请问在项目开发中用过哪些布局？ 答：LinearLayout、RelativeLayout、自定义ViewGroup、FrameLayout、TableLayout、AbsoluteLayout六种布局 问：自定义布局用过哪些？ 答：最常用的应该是RecyclerView 问：能告诉我scollView和RecyclerView的区别吗？为什么RecyclerView可以替代scollView？ 我一脸茫然… 这的确是我的知识漏洞…也曾比较过ListView和RecyclerView可从来没有想过要和scollview来做类比…面试后就做了这方面的功课..终于找到了一篇可以解决我心中困惑的文章 以前我们开发一个页面，几乎都是采用ScrollView作为父容器，然后在ScrollView中包含各个模块View。以如下页面携程为例，我将对这个编程框架进行讲解。 拿到一个需要新开发的页面，首先我们需要给这个页面分功能模块。把页面中每一个模块作为RecyclerView的一个item。在listView中把每个item设计为不同的结构时，代码写起来会特别冗余，结构会非常乱。而RecyclView本身一个很重要的特点就是可以实现多种类ITEM。给张图来解释一下， 使用RecyclerView来设计这样一个页面能解决加载慢和内存紧张的问题，因为RecyclerView本身就具有回收和延迟加载的特性。然而，对于这样功能复杂的RecyclerView，如果要是不设计一下结构，可想而知，这个代码维护起来得有多乱！！！因为RecyclerView的业务逻辑都是写在MainAdapter.java，要把这几种type的item都写在MainAdapter.java中，维护起来得多费劲！！ 于是，我设计了这样一种结构。 我用红色圆圈圈起来的是程序的3个核心类：MainActivity、MainAdapter、AdapterViewHolderManager。 MainAcitivity用于组织业务逻辑。 MainAdapter是RecyclerView对应的Adapter。 AdapterViewHolderManager来管理所有的ViewHolder。可想而知，Adapter中有多少个type的item，就有多少个ViewHolder。 从思维导图中可以看到有个delegate文件夹，里面有每一种viewholder的delegate。其中，AdapterDelegate是每一种delegate都要实现的接口。由于现在编写程序都是数据驱动业务逻辑，model文件夹里就是每一种delegate对应的数据，而最终需要把每一种delegate的数据都放到一个list中，这就需要让每一个数据类都实现IIndependentTravelData接口。这里给出demo工程的文件结构。 现在，你无法想象本该代码很复杂的主Adapter中的代码结构有多清晰。 这里onBindViewHolder等方法里再也不需要写switch来判断不同的type，根据不同的type做相应操作了。为什么结构会如此清晰？这里用到了java的多态。在MainAdapter的构造方法里把每一个delegate的引用add到manager中，在四个实现方法里只需要调用manger.*对应的方法就可以了。 这样设计程序不光有结构清晰的特点，维护起来也非常容易。比如，我现在要调整一下每一个item的展示顺序，我只需要调整list中每个item的model顺序就可以了。 总结：在日常开发中的类似List长列表加载展示的使用非常多..并且不仅仅是单一的一种view进行循环加载数据填充..这时scollview相对于RecyclerView就变得非常不适用…当对scollview中进行不同view的填充就会影响整体性能和资源占用…对于scollview这样的编程框架有以下两个缺点：1、加载时间长。2、占用内存大。因为进入页面需要把全部模块都加载出来，这不但会需要很长的加载时间，而且单个页面如果占用内存过大，会使得页面非常卡顿，影响用户体验。而我将RecyclerView代替ScrollView，并以RecyclerView作为基础，以增强可扩展性、灵活性为目标，并使得各模块间完全解耦。所以说，这个编程框架非常值得你来应用一下，目前我也在多个线上页面中采用了这种框架。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哪些情况下的对象会被垃圾回收机制处理掉？]]></title>
    <url>%2F2018%2F03%2F03%2F%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%A4%84%E7%90%86%E6%8E%89%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Java对象符合以下条件便会被垃圾回收：1.所有实例都没有活动线程访问。2.没有被其他任何实例访问的循环引用实例。3.Java 中有不同的引用类型。判断实例是否符合垃圾收集的条件都依赖于它的引用类型。[ 点击查看大图 123456789101112在编译过程中作为一种优化技术，Java 编译器能选择给实例赋 null 值，从而标记实例为可回收。class Animal &#123; public static void main(String[] args) &#123; Animal lion =new Animal(); System.out.println("Main is completed."); &#125; protected void finalize() &#123; System.out.println("Rest in Peace!"); &#125;&#125;]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2F2018%2F03%2F01%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[昨天投了阿里Android开发的内推简历…今天结束了一面…对于面试官提问volatile关键字的意义回答得比较含糊…当时只有之前用过以及在Java技术书上的模糊记忆作答…特以此文来弥补自己知识的漏洞一、Java内存模型想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。举个简单的例子：在java中，执行下面这个语句：1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。 最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 那么如何确保共享变量在多线程访问时能够正确输出结果呢？ 在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。 二、原子性1.定义原子性：即一个操作或者多个操作，要么全部执行，并且执行的过程不会被任何因素打断，要么就都不执行。 2.实例一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？1234567891011121314151617i = 9;``` 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。### 3.Java中的原子性在Java中，**对基本数据类型的变量的读取和赋值操作是原子性操作**，即这些操作是不可被中断的，要么执行，要么不执行。上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：请分析以下哪些操作是原子性操作：```javax = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存，这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 三、可见性1.定义可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 2.实例举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i; 由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 3.Java中的可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 四、有序性1.定义有序性：即程序执行的顺序按照代码的先后顺序执行。 2.实例举个简单的例子，看下面这段代码： 123456int i = 0;boolean flag = false;i = 1; //语句1flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 12345678910//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 3.Java中的有序性在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）：①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 ②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作 ③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 ④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C ⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 ⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 ⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 ⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 五、深入理解volatile关键字1.volatile保证可见性一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行：12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 2.volatile不能确保原子性下面看一个例子： 123456789101112131415161718192021222324252627282930313233343536public class Nothing &#123; private volatile int inc = 0; private volatile static int count = 10; private void increase() &#123; ++inc; &#125; public static void main(String[] args) &#123; int loop = 10; Nothing nothing = new Nothing(); while (loop-- &gt; 0) &#123; nothing.operation(); &#125; &#125; private void operation() &#123; final Nothing test = new Nothing(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000000; j++) &#123; test.increase(); &#125; --count; &#125;).start(); &#125; // 保证前面的线程都执行完 while (count &gt; 0) &#123; &#125; System.out.println("最后的数据为：" + test.inc); &#125;&#125; 运行结果为： 12345678910最后的数据为：5919956最后的数据为：3637231最后的数据为：2144549最后的数据为：2403538最后的数据为：1762639最后的数据为：2878721最后的数据为：2658645最后的数据为：2534078最后的数据为：2031751最后的数据为：2924506 大家想一下这段程序的输出结果是多少？也许有些朋友认为是1000000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于1000000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000000次操作，那么最终inc的值应该是1000000*10=10000000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。 可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新， 所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile保证有序性在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678// x、y为非volatile变量// flag为volatile变量x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2//线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 六、volatile的实现原理1.可见性处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。 如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。 但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期， 当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。 2.有序性Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。 七、volatile的应用场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 下面列举几个Java中使用volatile的几个场景。 ①.状态标记量 123456789volatile boolean flag = false; //线程1while(!flag)&#123; doSomething();&#125; //线程2public void setFlag() &#123; flag = true;&#125; 根据状态标记，终止线程。 ②.单例模式中的double check 1234567891011121314151617class Singleton &#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要使用volatile 修饰instance？主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存 2.调用 Singleton 的构造函数来初始化成员变量 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized和ReentrantLock的比较]]></title>
    <url>%2F2018%2F01%2F20%2Fsynchronized%E5%92%8CReentrantLock%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[一、线程同步问题的产生及解决方案问题的产生： Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突。 如下例：假设有一个卖票系统，一共有100张票，有4个窗口同时卖。 1234567891011121314151617public class Ticket implements Runnable &#123; // 当前拥有的票数 private int num = 100; public void run() &#123; while (true) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; // 输出卖票信息 System.out.println(Thread.currentThread().getName() + ".....sale...." + num--); &#125; &#125; &#125;&#125; 12345678910111213141516public class Nothing &#123; public static void main(String[] args) &#123; Ticket t = new Ticket();//创建一个线程任务对象。 //创建4个线程同时卖票 Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); //启动线程 t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 输出部分结果： Thread-1…..sale….2Thread-0…..sale….3Thread-2…..sale….1Thread-0…..sale….0Thread-1…..sale….0Thread-3…..sale….1 显然上述结果是不合理的，对于同一张票进行了多次售出。这就是多线程情况下，出现了数据“脏读”情况。即多个线程访问余票num时，当一个线程获得余票的数量，要在此基础上进行-1的操作之前，其他线程可能已经卖出多张票，导致获得的num不是最新的，然后-1后更新的数据就会有误。这就需要线程同步的实现了。 问题的解决： 因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 一共有两种锁，来实现线程同步问题，分别是：synchronized和ReentrantLock。下面我们就带着上述问题，看看这两种锁是如何解决的。 二、synchronized关键字1.synchronized简介 synchronized实现同步的基础：Java中每个对象都可以作为锁。当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。 Synchronzied实现同步的表现形式分为：代码块同步 和 方法同步。 2.synchronized原理JVM基于进入和退出Monitor对象来实现 代码块同步 和 方法同步 ，两者实现细节不同。 代码块同步： 在编译后通过将monitorenter指令插入到同步代码块的开始处，将monitorexit指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个monitor与之关联，线程执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获得对象的锁。 方法同步： synchronized方法在method_info结构有ACC_synchronized标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。 两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor）的获取。任意一个对象都拥有自己的监视器，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为BLOCKED。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。 对象、监视器、同步队列和执行线程间的关系如下图： 3.synchronized的使用场景①方法同步 1public synchronized void method1 锁住的是该对象,类的其中一个实例，当该对象(仅仅是这一个对象)在不同线程中执行这个同步方法时，线程之间会形成互斥。达到同步效果，但如果不同线程同时对该类的不同对象执行这个同步方法时，则线程之间不会形成互斥，因为他们拥有的是不同的锁。 ②代码块同步 1synchronized(this)&#123; //TODO &#125; 描述同① ③方法同步 1public synchronized static void method3 锁住的是该类，当所有该类的对象(多个对象)在不同线程中调用这个static同步方法时，线程之间会形成互斥，达到同步效果。 ④代码块同步1synchronized(Test.class)&#123; //TODO&#125; 同③ ⑤代码块同步1synchronized(o) &#123;&#125; 这里面的o可以是一个任何Object对象或数组，并不一定是它本身对象或者类，谁拥有o这个锁，谁就能够操作该块程序代码。 4.解决线程同步的实例针对上述方法，具体的解决方式如下： 1234567891011121314151617181920public class Ticket implements Runnable &#123; // 当前拥有的票数 private int num = 100; public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; synchronized (this) &#123; // 输出卖票信息 if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + ".....sale...." + num--); &#125; &#125; &#125; &#125;&#125; 输出部分结果： Thread-2…..sale….10Thread-1…..sale….9Thread-3…..sale….8Thread-0…..sale….7Thread-2…..sale….6Thread-1…..sale….5Thread-2…..sale….4Thread-1…..sale….3Thread-3…..sale….2Thread-0…..sale….1 可以看出实现了线程同步。同时改了一下逻辑，在进入到同步代码块时，先判断现在是否有没有票，然后再买票，防止出现没票还要售出的情况。通过同步代码块实现了线程同步，其他方法也一样可以实现该效果。 三、ReentrantLock锁ReentrantLock，一个可重入的互斥锁，它具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。（重入锁后面介绍） 1.Lock接口Lock，锁对象。在Java中锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有的锁可以允许多个线程并发访问共享资源，比如读写锁，后面我们会分析）。在Lock接口出现之前，Java程序是靠synchronized关键字（后面分析）实现锁功能的，而JAVA SE5.0之后并发包中新增了Lock接口用来实现锁的功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁，缺点就是缺少像synchronized那样隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。 Lock接口的主要方法（还有两个方法比较复杂，暂不介绍）： void lock(): 执行此方法时，如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。boolean tryLock()： 如果锁可用，则获取锁，并立即返回true，否则返回false. 该方法和lock()的区别在于，tryLock()只是”试图”获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码。而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前,当前线程并不继续向下执行. 通常采用如下的代码形式调用tryLock()方法：void unlock()： 执行此方法时，当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生.Condition newCondition()： 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将缩放锁。 2.ReentrantLock的使用关于ReentrantLock的使用很简单，只需要显示调用，获得同步锁，释放同步锁即可。 12345678ReentrantLock lock = new ReentrantLock(); //参数默认false，不公平锁.....................lock.lock(); //如果被其它资源锁定，会在此等待锁释放，达到暂停的效果try &#123; //操作&#125; finally &#123; lock.unlock(); //释放锁&#125; 3.解决线程同步的实例针对上述方法，具体的解决方式如下： 12345678910111213141516171819202122public class Ticket implements Runnable &#123; // 当前拥有的票数 private int num = 100; ReentrantLock lock = new ReentrantLock(); public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; lock.lock(); // 输出卖票信息 if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + ".....sale...." + num--); &#125; lock.unlock(); &#125; &#125;&#125; 四、重入锁当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。 具体概念就是：自己可以再次获取自己的内部锁。 Java里面内置锁(synchronized)和Lock(ReentrantLock)都是可重入的。 12345678910111213141516public class SynchronizedTest &#123; public void method1() &#123; synchronized (SynchronizedTest.class) &#123; System.out.println("方法1获得ReentrantTest的锁运行了"); method2(); &#125; &#125; public void method2() &#123; synchronized (SynchronizedTest.class) &#123; System.out.println("方法1里面调用的方法2重入锁,也正常运行了"); &#125; &#125; public static void main(String[] args) &#123; new SynchronizedTest().method1(); &#125;&#125; 上面便是synchronized的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取。 1234567891011121314151617181920212223public class ReentrantLockTest &#123; private Lock lock = new ReentrantLock(); public void method1() &#123; lock.lock(); try &#123; System.out.println("方法1获得ReentrantLock锁运行了"); method2(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void method2() &#123; lock.lock(); try &#123; System.out.println("方法1里面调用的方法2重入ReentrantLock锁,也正常运行了"); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; new ReentrantLockTest().method1(); &#125;&#125; 上面便是ReentrantLock的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时， 由于本身已经具有该锁，所以可以再次获取。 五、公平锁CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。 ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; 以下是使用公平锁实现的效果： 123456789101112131415161718192021public class LockFairTest implements Runnable&#123; //创建公平锁 private static ReentrantLock lock=new ReentrantLock(true); public void run() &#123; while(true)&#123; lock.lock(); try&#123; System.out.println(Thread.currentThread().getName()+"获得锁"); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; LockFairTest lft=new LockFairTest(); Thread th1=new Thread(lft); Thread th2=new Thread(lft); th1.start(); th2.start(); &#125;&#125; 输出结果： Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁 这是截取的部分执行结果，分析结果可看出两个线程是交替执行的，几乎不会出现同一个线程连续执行多次。 六、synchronized和ReentrantLock的比较1.区别：1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 总结：ReentrantLock相比synchronized，增加了一些高级的功能。但也有一定缺陷。 在ReentrantLock类中定义了很多方法，比如： 1234567isFair() //判断锁是否是公平锁isLocked() //判断锁是否被任何线程获取了isHeldByCurrentThread() //判断锁是否被当前线程获取了hasQueuedThreads() //判断是否有线程在等待该锁 2.两者在锁的相关概念上区别：1)可中断锁 顾名思义，就是可以响应中断的锁。 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。 lockInterruptibly()的用法体现了Lock的可中断性。 2)公平锁 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。ReentrantLock可以设置成公平锁。 3)读写锁 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。 正因为有了读写锁，才使得多个线程之间的读操作可以并发进行，不需要同步，而写操作需要同步进行，提高了效率。 ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。 可以通过readLock()获取读锁，通过writeLock()获取写锁。 4)绑定多个条件 一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这么做，只需要多次调用new Condition()方法即可。 3.性能比较在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而 当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized 。所以说，在具体使用时要根据适当情况选择。 在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建线程的三种方式]]></title>
    <url>%2F2018%2F01%2F15%2FJava%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。12345678910111213141516171819202122public class FirstThreadTest extends Thread &#123; int i = 0; //重写run方法，run方法的方法体就是现场执行体 public void run() &#123; for (; i &lt; 100; i++) &#123; System.out.println(getName() + " " + i); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); if (i == 20) &#123; new FirstThreadTest().start(); new FirstThreadTest().start(); &#125; &#125; &#125;&#125; 上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。 二、通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。 12345678910111213141516171819202122public class RunnableThreadTest implements Runnable &#123; private int i; public void run() &#123; for (i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); if (i == 20) &#123; RunnableThreadTest rtt = new RunnableThreadTest(); new Thread(rtt, "新线程1").start(); new Thread(rtt, "新线程2").start(); &#125; &#125; &#125;&#125; 三、通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用get()方法会阻塞线程。 1234567891011121314151617181920212223242526272829public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i); if (i == 20) &#123; new Thread(ft, "有返回值的线程").start(); &#125; &#125; try &#123; System.out.println("子线程的返回值：" + ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for (; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; return i; &#125;&#125; 四、创建线程的三种方式的对比采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】亚马逊高级工程师：平凡是程序员唯一的答案吗？]]></title>
    <url>%2F2017%2F09%2F18%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E4%BA%9A%E9%A9%AC%E9%80%8A%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%9A%E5%B9%B3%E5%87%A1%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E5%94%AF%E4%B8%80%E7%9A%84%E7%AD%94%E6%A1%88%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[【转载】亚马逊高级工程师：平凡是程序员唯一的答案吗？本文作者：故胤道长 CMU 硕士毕业，常年居住于美国的 iOS 开发者。Github累计 4000 星，前 Uber 核心架构组成员，现亚马逊担任项目技术负责人。 以下为正文： 我在 Facebook 有一位好友。他本科国内 Top 2 大学毕业，在美国拿了最顶尖大学的硕士学位，然后年纪轻轻就做到了技术负责人，拿着超高的薪水。就是这么一个开了挂一般的天才，每个星期六晚上的夜里，他是永远是睡不着的。 我问他为什么失眠。他的回答是焦虑。 他说，他马上就要30岁了。他的老板扎克伯格在30岁时时已经缔造了 Facebook；贝佐斯辞去了华尔街的副总裁职位，开始了 Amazon 的创业旅程；丁磊已经成为了中国首富；李彦宏也在这一年放弃了财务自由的硅谷生活，转身回到中国，创立了百度。远的不说，近处他有几个认识的同龄人在国内创业风生水起，千万投资，还有几个被评为 Forbes 30 Under 30。 而他呢，不过一个程序员。30岁的时候依然在硅谷租着房子，至今没有感觉做出什么改变世界的产品。每当看到硅谷大华超市里面拖家带口的华人老工程师，他就觉得可以看穿未来 —— 十年后他也会是这样：挺着大肚子，带着孩子，为柴米油盐斤斤计较。 我当时笑着说，你哪会那样。你现在只不过是少年维特的烦恼，你之前的生命如夏花般灿烂，这之后平凡也不会是唯一的答案。 现在想想，我也许过于乐观了。现在超市里看到的华人工程师，他们当年都是国内数一数二的学霸，大多在没有父母支持的情况下，漂洋过海，学成毕业，留在硅谷（那个时候恐怕谷歌还没上市），真是比我们这代留学生优秀太多。即使这样，在我们这帮不知天高地厚的年轻人看来，他们也老了、无聊了、泯然众人矣了。十年之后，我们这代程序员，是否也会被后辈所鄙弃？ 这个问题我想无数人思考过，无论是国内的还是硅谷的，无论是不是程序员。当年扎克伯格一直为自己极客的身份感到自豪，也惧怕最后被世俗裹挟，成为所谓职场上指手画脚的老油条——于是他在自己名片上的职位 CEO 前加上了个“他妈的”；超级极客约翰卡马克在成为 Oculus CTO 之后，依然坚持每天写代码，一天不写就觉得浑身不舒服，要在推特上吐槽自己。 这两个人直到今天依然很酷，依然是程序员心中的偶像。 有人说，这两个人天赋异禀，骨骼惊奇，是万中无一的程序员。然而主流世界观就是，我们终将老去。科技行业的日新月异更是决定了，我们的代码终将被覆盖，我们做的产品终将会落寞，我们讨论的技术终将会淘汰，那我们程序员还剩下什么？ 神龟虽寿，犹有竟时。腾蛇乘雾，终为土灰。 要回答这个问题，我想谈两位艺术家。一位是音乐之父巴赫，另一位是音乐神童莫扎特。前者生前是一位宫廷乐手，为王宫贵族谱曲，死后80年，他伟大的作品才在极其偶然的情况下被门德尔松发现；后者生前亦不受待见，英年早逝后无人送葬。 这两个人在生前都是普普通通，绝不像迈克尔杰克逊那样家喻户晓，身前身后都粉丝无数。他们的平常工作，与我们程序员一样，不过我们写代码，他们写乐谱。 我想，巴赫和莫扎特，在安安静静的谱写一首又一首曲目的时候，从来没有考虑过，他们以后会成为西方音乐的代名词。 我们程序员也一样，也许在他人看来我们只是螺丝钉。但是我们敲下来的每一行代码，也许都将缔造不凡。 史上最伟大的女程序员玛格丽特·汉密尔顿在为 NASA 写代码的时候，她负责的项目只是为了应对万分之一的意外事件，而她仍然兢兢业业地完成了工作。最后，她的程序真的发挥了作用，拯救了阿波罗计划。 所以，我们程序员一定要功成名就吗？一定要荣耀显达吗？这才算是不平凡才是幸福吗？虽然写代码确实赚钱，但如果多年后退休的我回到公司，发现年轻时候我写的代码或者库依然在被广泛的使用，我会由衷的欣慰。 作为一名年轻的程序员，我还想做出一些很酷的产品；还想在 Github 上开源一些程序供大家参考或者使用；我还想再写出一段段代码，让很多人的体验因为我的工作而不同。 李开复老师前段时间在哥大演讲。看着他思维活跃，跟毕业生们畅谈人工智能，我依然觉得他是一位很酷的程序员。也许这就是程序员这份工作意义的所在：数十年之后，我们依然可以通过技术紧跟年轻人的世界，而年轻人依然觉得我们是一群很酷的极客。 本文是故胤道长《硅谷问道》专栏的发刊词，《硅谷问道》核心内容是对美国最新 iOS 产品介绍的和分析；硅谷公司先进的管理方法和职场之道；科技论坛和大会如 WWDC，Facebook F8，Google IO的深度回顾；Facebook，Google，Amazon，Apple等美国一流互联网公司的科技动态。]]></content>
      <tags>
        <tag>Inspire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow_Cifar_10]]></title>
    <url>%2F2017%2F07%2F15%2FTensorFlow_Cifar10%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[The examples of image recognition with the dataset CIFAR10 via tensorflow.1 CIFAR-10 数据集CIFAR-10数据集是机器学习中的一个通用的用于图像识别的基础数据集，官网链接为：The CIFAR-10 dataset cifar10 下载使用的版本是： version 将其解压后（代码中包含自动解压代码），内容为： cifar10 data2 2 测试代码测试代码公布在GitHub：EdwardZhang 主要代码及作用： 文件 作用 cifar10_input.py 读取本地或者在线下载CIFAR-10的二进制文件格式数据集 cifar10.py 建立CIFAR-10的模型 cifar10_train.py 在CPU或GPU上训练CIFAR-10的模型 cifar10_multi_gpu_train.py 在多个GPU上训练CIFAR-10的模型 cifar10_eval.py 评估CIFAR-10模型的预测性能 $ $ 该部分的代码，介绍了如何使用TensorFlow在CPU和GPU上训练和评估卷积神经网络（convolutional neural network, CNN）。 ###3 相关网页及教程更加详细地介绍说明，请浏览网页：Convolutional Neural Networks 中文网站极客学院也有该部分的汉译版：卷积神经网络 代码源自tensorflow官网：tensorflow/models/image/cifar10 4 代码修改说明GitHub公布代码相对源码，主要进行了以下修正： cifar10.py 12345#indices = tf.reshape(tf.range(FLAGS.batch_size), [FLAGS.batch_size, 1])indices = tf.reshape(range(FLAGS.batch_size), [FLAGS.batch_size, 1])# orindices = tf.reshape(tf.range(0, FLAGS.batch_size, 1), [FLAGS.batch_size, 1]) 此处，源码编译时会出现以下错误： 1234 ... File ".../cifar10.py", line 271, in loss indices = tf.reshape(tf.range(FLAGS.batch_size), [FLAGS.batch_size, 1])TypeError: range() takes at least 2 arguments (1 given) cifar10_input_test.py 123456#self.assertEqual("%s:%d" % (filename, i), tf.compat.as_text(key))import compat as cp...self.assertEqual("%s:%d" % (filename, i), cp.as_text(key)) 不然的话，我测试的时候就会出现这的错误： 1AttributeError: 'module' object has no attribute 'compat' cifar10_train.py和cifar10_multi_gpu_train.py 源代码里的最大迭代次数max_steps为1000000，如使用CPU训练需要好几个小时，推荐大家使用GPU训练，GPU训练环境安装教程。]]></content>
      <tags>
        <tag>TensorFlow</tag>
        <tag>Cifar-10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DeepLearning 怒发教程！！！Ubuntu16.04系统搭建TensorFlowGPU]]></title>
    <url>%2F2017%2F06%2F30%2FDeepLearning%20%20%20%E6%80%92%E5%8F%91%E6%95%99%E7%A8%8B%EF%BC%81%EF%BC%81%EF%BC%81Ubuntu16.04%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BATensorFlowGPU%2F</url>
    <content type="text"><![CDATA[​大概在一个月前开始接触模式识别、人工神经网络、图像识别方向。 从Matlab开始一边理解神经网络层一边看代码跑了最基础的MNIST识别手写数字的代码，中间遇到了很多问题，比如说在图像处理方面CPU远不及GPU强而在IO读写上CPU又很占优势。当我在进一步学习卷积神经网络的过程中发现了Matlab的强大和不足。在两年前Google爸爸出品了TensorFlow这一深度学习开源框架。历经2天1夜13次重装系统。。。所以为什么要怒发教程，你懂的。话不多说直接开配！ requirements Ubuntu-16.04 python-2.7 cuda-8 cuDNN-5.1 tensorflow GPU 版本 安装nvidia driver 经过不断踩坑的安装，终于google到了靠谱的方法，首先检查你的NVIDIA VGA card model Ctrl+Alt+T 打开终端 输入： 1sudo lshw -numeric -C display 可以看到你的显卡信息，比如我的就是 product: GM107M [GeForce GTX 960M] [10DE:139B] 找到 系统设置-&gt;软件更新-&gt;附加驱动 查看和上面GPU型号相对应的显卡 选择最新的显卡驱动并点击应用更改 然后喝杯咖啡静候应用更改完成 输入以下命令： 1sudo apt-get install mesa-common-devsudo apt-get install freeglut3-dev 安装完成之后，重启电脑，驱动应该就完成了！ 你可以在dashboard上搜索nvidia 看到像 NVIDIA X Server Settings的东西 就说明安装驱动成功了 接下来就该安装cuda8 安装cuda8首先也是去下载cuda toolkit 8.0 老铁！看我的教程就按我的来！照着图好好选！ 一定要选择runfile.下载完成之后，执行 1sudo sh cuda_8.0.44_linux.run 然后就进入安装过程 开始都是End User License Agreement 你可以CTRL +C 跳过 然后accept，下面就是安装的交互界面 开始的Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 375.66? 选择n，因为你已经安装驱动了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Using more to view the EULA.End User License AgreementPrefaceThe following contains specific license terms and conditionsfor four separate NVIDIA products. By accepting thisagreement, you agree to comply with all the terms andconditions applicable to the specific product(s) includedherein.NVIDIA CUDA ToolkitDescriptionThe NVIDIA CUDA Toolkit provides command-line and graphicaltools for building, debugging and optimizing the performanceof applications accelerated by NVIDIA GPUs, runtime and mathlibraries, and documentation including programming guides,user manuals, and API references. The NVIDIA CUDA ToolkitLicense Agreement is available in Chapter 1.Default Install Location of CUDA ToolkitWindows platform:Do you accept the previously read EULA?accept/decline/quit: acceptInstall NVIDIA Accelerated Graphics Driver for Linux-x86_64 367.48?(y)es/(n)o/(q)uit: nInstall the CUDA 8.0 Toolkit?(y)es/(n)o/(q)uit: yEnter Toolkit Location [ default is /usr/local/cuda-8.0 ]: Do you want to install a symbolic link at /usr/local/cuda?(y)es/(n)o/(q)uit: yInstall the CUDA 8.0 Samples?(y)es/(n)o/(q)uit: y Enter CUDA Samples Location [ default is /home/kinny ]: Installing the CUDA Toolkit in /usr/local/cuda-8.0 ...Missing recommended library: libXmu.soInstalling the CUDA Samples in /home/kinny ...Copying samples to /home/kinny/NVIDIA_CUDA-8.0_Samples now...Finished copying samples.============ Summary ============Driver: Not SelectedToolkit: Installed in /usr/local/cuda-8.0Samples: Installed in /home/kinny, but missing recommended librariesPlease make sure that - PATH includes /usr/local/cuda-8.0/bin - LD_LIBRARY_PATH includes /usr/local/cuda-8.0/lib64, or, add /usr/local/cuda-8.0/lib64 to /etc/ld.so.conf and run ldconfig as rootTo uninstall the CUDA Toolkit, run the uninstall script in /usr/local/cuda-8.0/binPlease see CUDA_Installation_Guide_Linux.pdf in /usr/local/cuda-8.0/doc/pdf for detailed information on setting up CUDA.***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 361.00 is required for CUDA 8.0 functionality to work.To install the driver using this installer, run the following command, replacing &lt;CudaInstaller&gt; with the name of this run file: sudo &lt;CudaInstaller&gt;.run -silent -driverLogfile is /tmp/cuda_install_17494.log 配置cuda环境变量1export PATH=&quot;$PATH:/usr/local/cuda-8.0/bin&quot;export LD_LIBRARY_PATH=&quot;/usr/local/cuda-8.0/lib64&quot;nvidia-smi 结果出现以下输出，说明配置成功 安装深度学习库cuDNN-v5.1首先下载cuDNN5.1，直接下载，注意前提是你已经注册为开发者了！ 解压： 1tar xvzf cudnn-8.0-linux-x64-v5.1.tgz 然后将库头文件Copy到cuda目录 123sudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* 安装tensorflow gpu enable python 2.7 版本，详见官网123456789101112131415export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.11.0-cp27-none-linux_x86_64.whlsudo pip install --upgrade $TF_BINARY_URL验证$python Python 2.7.12 (default, Jul 1 2016, 15:12:24) [GCC 5.4.0 20160609] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import tensorflowI tensorflow/stream_executor/dso_loader.cc:111] successfully opened CUDA library libcublas.so locallyI tensorflow/stream_executor/dso_loader.cc:111] successfully opened CUDA library libcudnn.so locallyI tensorflow/stream_executor/dso_loader.cc:111] successfully opened CUDA library libcufft.so locallyI tensorflow/stream_executor/dso_loader.cc:111] successfully opened CUDA library libcuda.so.1 locallyI tensorflow/stream_executor/dso_loader.cc:111] successfully opened CUDA library libcurand.so locally&gt;&gt;&gt; quit()大功告成！ 全部结束 谢谢观看！ 现在就可以放心的开始你的深度学习之路了 不要觉得好容易。。。都是几十遍血的教训成就的！ 之后我会继续更新个人公众号，发布一些自己在深度学习方面的见闻。 CreatedbyEdwardZhang∣一个不只做技术的公众号 长按，识别二维码，加关注 0.gif]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Chapter III. Android四大组件的生命周期]]></title>
    <url>%2F2017%2F06%2F11%2FAndroid%20Chapter%20III.%20%20%20Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[​Hello everybody,上一次我们讲完了Android四大组件那么伴随四大组件必不可少的就是他们的生命周期了，那么今天我们就再叨叨生命周期的三两事吧。 介绍生命周期之前，先提一下任务的概念 任务其实就是activity 的栈它由一个或多个Activity组成的共同完成一个完整的用户体验， 换句话说任务就是” 应用程序” （可以是一个也可以是多个，比如假设你想让用户看到某个地方的街道地图。而已经存在一个具有此功能的activity 了，那么你的activity 所需要做的工作就是把请求信息放到一个Intent 对象里面，并把它传递给startActivity()。于是地图浏览器就会显示那个地图。而当用户按下BACK 键的时候，你的activity 又会再一次的显示在屏幕上，此时任务是由2个应用程序中的相关activity组成的）栈底的是启动整个任务的Activity，栈顶的是当前运行的用户可以交互的Activity，当一个activity 启动另外一个的时候，新的activity 就被压入栈，并成为当前运行的activity。而前一个activity 仍保持在栈之中。当用户按下BACK 键的时候，当前activity 出栈，而前一个恢复为当前运行的activity。栈中保存的其实是对象，栈中的Activity 永远不会重排，只会压入或弹出，所以如果发生了诸如需要多个地图浏览器的情况，就会使得一个任务中出现多个同一Activity 子类的实例同时存在。 任务中的所有activity 是作为一个整体进行移动的。整个的任务（即activity 栈）可以移到前台，或退至后台。举个例子说，比如当前任务在栈中存有四个activity──三个在当前activity 之下。当用户按下HOME 键的时候，回到了应用程序加载器，然后选择了一个新的应用程序（也就是一个新任务）。则当前任务遁入后台，而新任务的根activity 显示出来。然后，过了一小会儿，用户再次回到了应用程序加载器而又选择了前一个应用程序（上一个任务）。于是那个任务，带着它栈中所有的四个activity，再一次的到了前台。当用户按下BACK 键的时候，屏幕不会显示出用户刚才离开的activity（上一个任务的根activity）。取而代之，当前任务的栈中最上面的activity 被弹出，而同一任务中的上一个activity 显示了出来。 Activity栈：先进后出规则 Android系统是一个多任务(Multi-Task)的操作系统，可以在用手机听音乐的同时，也执行其他多个程序。每多执行一个应用程序，就会多耗费一些系统内存，当同时执行的程序过多，或是关闭的程序没有正确释放掉内存，系统就会觉得越来越慢，甚至不稳定。 为了解决这个问题， Android 引入了一个新的机制– 生命周期(Life Cycle)。 Android 应用程序的生命周期是由Android 框架进行管理，而不是由应用程序直接控 制。通常，每一个应用程序（入口一般会是一个Activity 的onCreate 方法），都会产生 一个进程(Process)。当系统内存即将不足的时候，会依照优先级自动进行进程(process)的回收。不管是使用者或开发者， 都无法确定的应用程序何时会被回收。所以为了很好的防止数据丢失和其他问题，了解生命周期很重要。 Activity生命周期： 图3.1activity生命周期图 Activity整个生命周期的4种状态、7个重要方法和3个嵌套循环 1&gt; 四种状态 活动（Active/Running）状态 当Activity运行在屏幕前台(处于当前任务活动栈的最上面),此时它获取了焦点能响应用户的操作,属于运行状态，同一个时刻只会有一个Activity 处于活动(Active)或运行 (Running)状态 暂停(Paused)状态 当Activity失去焦点但仍对用户可见(如在它之上有另一个透明的Activity或Toast、AlertDialog等弹出窗口时)它处于暂停状态。暂停的Activity仍然是存活状态(它保留着所有的状态和成员信息并保持和窗口管理器的连接),但是当系统内存极小时可以被系统杀掉 停止(Stopped)状态 完全被另一个Activity遮挡时处于停止状态,它仍然保留着所有的状态和成员信息。只是对用户不可见,当其他地方需要内存时它往往被系统杀掉 非活动（Dead）状态 Activity 尚未被启动、已经被手动终止，或已经被系统回收时处于非活动的状态，要手动终止Activity，可以在程序中调用”finish”方法。 如果是（按根据内存不足时的回收规则）被系统回收，可能是因为内存不足了 内存不足时，Dalvak 虚拟机会根据其内存回收规则来回收内存： 1. 先回收与其他Activity 或Service/Intent Receiver 无关的进程(即优先回收独立的Activity)因此建议,我们的一些(耗时)后台操作，最好是作成Service的形式 2.不可见(处于Stopped状态的)Activity 3.Service进程(除非真的没有内存可用时会被销毁) 4.非活动的可见的(Paused状态的)Activity 5.当前正在运行（Active/Running状态的）Activity 2&gt; 7个重要方法,当Activity从一种状态进入另一状态时系统会自动调用下面相应的方 法来通知用户这种变化 当Activity第一次被实例化的时候系统会调用, 整个生命周期只调用1次这个方法 通常用于初始化设置: 1、为Activity设置所要使用的布局文件2、为按钮绑定监听器等静态的设置操作 onCreate(Bundle savedInstanceState); 当Activity可见未获得用户焦点不能交互时系统会调用 onStart(); 当Activity已经停止然后重新被启动时系统会调用 onRestart(); 当Activity可见且获得用户焦点能交互时系统会调用 onResume(); 当系统启动另外一个新的Activity时,在新Activity启动之前被系统调用保存现有的Activity中的持久数据、停止动画等,这个实现方法必须非常快。当系统而不是用户自己出于回收内存时，关闭了activity 之后。用户会期望当他再次回到这个activity 的时候，它仍保持着上次离开时的样子。此时用到了onSaveInstanceState()，方法onSaveInstanceState()用来保存Activity被杀之前的状态,在onPause()之前被触发,当系统为了节省内存销毁了Activity(用户本不想销毁)时就需要重写这个方法了,当此Activity再次被实例化时会通过onCreate(Bundle savedInstanceState)将已经保存的临时状态数据传入因为onSaveInstanceState()方法不总是被调用,触发条件为(按下HOME键,按下电源按键关闭屏幕,横竖屏切换情况下),你应该仅重写onSaveInstanceState()来记录activity的临时状态，而不是持久的数据。应该使用onPause()来存储持久数据。 onPause(); 当Activity被新的Activity完全覆盖不可见时被系统调用 onStop(); 当Activity(用户调用finish()或系统由于内存不足)被系统销毁杀掉时系统调用,（整个生命周期只调用1次）用来释放onCreate ()方法中创建的资源,如结束线程等 onDestroy(); 3&gt; 3个嵌套循环 1.Activity完整的生命周期:从第一次调用onCreate()开始直到调用onDestroy()结束 2.Activity的可视生命周期:从调用onStart()到相应的调用onStop() 在这两个方法之间,可以保持显示Activity所需要的资源。如在onStart()中注册一个广播接收者监听影响你的UI的改变,在onStop() 中注销。 3.Activity的前台生命周期:从调用onResume()到相应的调用onPause()。 举例说明: 例1：有3个Acitivity,分别用One,Two(透明的),Three表示,One是应用启动时的主Activity 启动第一个界面Activity One时,它的次序是 onCreate (ONE) - onStart (ONE) - onResume(ONE) 点&quot;打开透明Activity&quot;按钮时,这时走的次序是 onPause(ONE) - onCreate(TWO) - onStart(TWO) - onResume(TWO) 再点back回到第一个界面,Two会被杀这时走的次序是 onPause(TWO) - onActivityResult(ONE) - onResume(ONE) - onStop(TWO) - onDestroy(TWO) 点&quot;打开全屏Activity&quot;按钮时,这时走的次序是 onPause(ONE) - onCreate(Three) - onStart(Three) - onResume(Three) - onStop(ONE) 再点back回到第一个界面,Three会被杀这时走的次序是 onPause(Three) - onActivityResult(ONE) - onRestart(ONE) - onStart(ONE)- onResume(ONE) - onStop(Three) - onDestroy(Three) 再点back退出应用时,它的次序是 onPause(ONE) - onStop(ONE) - onDestroy(ONE) 例2：横竖屏切换时候Activity的生命周期 他切换时具体的生命周期是怎么样的： 1、新建一个Activity，并把各个生命周期打印出来 2、运行Activity，得到如下信息 onCreate–&gt;onStart–&gt;onResume–&gt; 3、按crtl+f12切换成横屏时 onSaveInstanceState–&gt;onPause–&gt;onStop–&gt;onDestroy–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState–&gt;onResume–&gt; 4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log onSaveInstanceState–&gt;onPause–&gt;onStop–&gt;onDestroy–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState–&gt;onResume–&gt;onSaveInstanceState–&gt;onPause–&gt;onStop–&gt;onDestroy–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState–&gt;onResume–&gt; 5、修改AndroidManifest.xml，把该Activity添加android:configChanges=”orientation”，执行步骤3 onSaveInstanceState–&gt;onPause–&gt;onStop–&gt;onDestroy–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState–&gt;onResume–&gt; 6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged onSaveInstanceState–&gt;onPause–&gt;onStop–&gt;onDestroy–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState–&gt;onResume–&gt;onConfigurationChanged–&gt; 7、把步骤5的android:configChanges=”orientation” 改成 android:configChanges=”orientation|keyboardHidden”，执行步骤3，就只打印onConfigChanged onConfigurationChanged–&gt; 8、执行步骤4 onConfigurationChanged–&gt;onConfigurationChanged–&gt; 总结： 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 总结一下整个Activity的生命周期 补充一点，当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变 Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop，再次进入激活状态时： onRestart –&gt;onStart—&gt;onResume BroadcastReceive广播接收器生命周期： 生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息 它的生命周期为从回调onReceive()方法开始到该方法返回结果后结束 Service服务生命周期： 图3.2service生命周期图 Service完整的生命周期:从调用onCreate()开始直到调用onDestroy()结束 Service有两种使用方法： 1&gt;以调用Context.startService()启动，而以调用Context.stopService()结束 2&gt;以调用Context.bindService()方法建立，以调用Context.unbindService()关闭 service重要的生命周期方法 当用户调用startService （）或bindService（）时，Service第一次被实例化的时候系统会调用,整个生命周期只调用1次这个方法，通常用于初始化设置。注意：多次调用startService（）或bindService（）方法不会多次触发onCreate（）方法 void onCreate() 当用户调用stopService()或unbindService（）来停止服务时被系统调用,（整个生命周期只调用1次）用来释放onCreate()方法中创建的资源 void onDestroy() 通过startService()方法启动的服务 初始化结束后系统会调用该方法，用于处理传递给startService()的Intent对象。如音乐服务会打开Intent 来探明将要播放哪首音乐，并开始播放。注意：多次调用startService（）方法会多次触发onStart（）方法 void onStart(Intent intent) 通过bindService ()方法启动的服务 初始化结束后系统会调用该方法，用来绑定传递给bindService 的Intent 的对象。注意：多次调用bindService（）时，如果该服务已启动则不会再触发此方法 IBinder onBind(Intent intent) 用户调用unbindService()时系统调用此方法，Intent 对象同样传递给该方法 boolean onUnbind(Intent intent) 如果有新的客户端连接至该服务，只有当旧的调用onUnbind()后，新的才会调用该方法 void onRebind(Intent intent) 补充：onCreate(Bundle savedInstanceState)与onSaveInstanceState(Bundle savedInstanceState)配合使用，见如下代码，达到显示activity被系统杀死前的状态 @Overridepublic void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState); if (null != savedInstanceState) { String _userid = savedInstanceState.getString(“StrUserId”); String _uid = savedInstanceState.getString(“StrUid”); String _serverid = savedInstanceState.getString(“StrServerId”); String _servername = savedInstanceState.getString(“StrServerName”); int _rate = savedInstanceState.getInt(“StrRate”); //updateUserId(_userid); //updateUId(_uid); //updateServerId(_serverid); //updateUserServer(_servername); //updateRate(_rate); } } @Overrideprotected void onSaveInstanceState(Bundle savedInstanceState) {super.onSaveInstanceState(savedInstanceState); savedInstanceState.putString(&quot;StrUserId&quot;, getUserId()); savedInstanceState.putString(&quot;StrUid&quot;, getUId()); savedInstanceState.putString(&quot;StrServerId&quot;, getServerId()); savedInstanceState.putString(&quot;StrServerName&quot;, getServerName()); savedInstanceState.putInt(&quot;StrRate&quot;, getRate()); } 如果大家对这有趣实用的技术贴感兴趣 我后期会继续努力的！ 请大家扫描二维码！ 关注我！]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Chapter II. Android四大组件]]></title>
    <url>%2F2017%2F06%2F10%2FAndroid%20Chapter%20II.%20%20%20Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[​学习Android最重要的莫过于对于四大组件、五大布局以及生命周期的学习，这一期我们就一起来叨叨Android四大基本组件相关的知识。Android四大基本组件分别是Activity，Service服务,Content Provider内容提供者，BroadcastReceiver广播接收器。 了解四大基本组件 Activity** :** 应用程序中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 Activity之间通过Intent进行通信。在Intent 的描述结构中，有两个最重要的部分：动作和动作对应的数据。 典型的动作类型有：M AIN（activity的门户）、VIEW、PICK、EDIT 等。而动作对应的数据则以URI 的形式进行表示。例如：要查看一个人的联系方式，你需要创建一个动作类型为VIEW 的intent，以及一个表示这个人的URI。 与之有关系的一个类叫IntentFilter。相对于intent 是一个有效的做某事的请求，一个intentfilter 则用于描述一个activity（或者IntentReceiver）能够操作哪些intent。一个activity 如果要显示一个人的联系方式时，需要声明一个IntentFilter，这个IntentFilter 要知道怎么去处理VIEW 动作和表示一个人的URI。IntentFilter 需要在AndroidManifest.xml 中定义。通过解析各种intent，从一个屏幕导航到另一个屏幕是很简单的。当向前导航时，activity 将会调用startActivity(Intent myIntent)方法。然后，系统会在所有安装的应用程序中定义的IntentFilter 中查找，找到最匹配myIntent 的Intent 对应的activity。新的activity 接收到myIntent 的通知后，开始运行。当startActivity 方法被调用将触发解析myIntent 的动作，这个机制提供了两个关键好处： A、Activities 能够重复利用从其它组件中以Intent 的形式产生的一个请求； B、Activities 可以在任何时候被一个具有相同IntentFilter 的新的Activity 取代。 AndroidManifest文件中含有如下过滤器的Activity组件为默认启动类当程序启动时系统自动调用它 BroadcastReceive广播接收器: 你的应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 广播类型： 普通广播，通过Context.sendBroadcast(Intent myIntent)发送的 有序广播，通过Context.sendOrderedBroadcast(intent, receiverPermission)发送的，该方法第2个参数决定该广播的级别，级别数值是在 -1000 到 1000 之间 , 值越大 , 发送的优先级越高；广播接收者接收广播时的级别级别（可通过intentfilter中的priority进行设置设为2147483647时优先级最高），同级别接收的先后是随机的， 再到级别低的收到广播，高级别的或同级别先接收到广播的可以通过abortBroadcast()方法截断广播使其他的接收者无法收到该广播，还有其他构造函数 异步广播，通过Context.sendStickyBroadcast(Intent myIntent)发送的，还有sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)方法，该方法具有有序广播的特性也有异步广播的特性；发送异步广播要： 权限，接收并处理完Intent后，广播依然存在，直到你调用removeStickyBroadcast(intent)主动把它去掉 注意：发送广播时的intent参数与Contex.startActivity()启动起来的Intent不同,前者可以被多个订阅它的广播接收器调用,后者只能被一个(Activity或service)调用 监听广播Intent步骤: 1&gt;写一个继承BroadCastReceiver的类,重写onReceive()方法,广播接收器仅在它执行这个方法时处于活跃状态。当onReceive()返回后，它即为失活状态,注意:为了保证用户交互过程的流畅,一些费时的操作要放到线程里,如类名SMSBroadcastReceiver 2&gt;注册该广播接收者,注册有两种方法程序动态注册和AndroidManifest文件中进行静态注册（可理解为系统中注册）如下： 静态注册,注册的广播，下面的priority表示接收广播的级别&quot;2147483647&quot;为最高优先级 1&lt;receiver android:name=&quot;.SMSBroadcastReceiver&quot; &gt; &lt;intent-filter android:priority = &quot;2147483647&quot; &gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver &gt; 动态注册，一般在Activity可交互时onResume()内注册BroadcastReceiver IntentFilter intentFilter=new IntentFilter(“android.provider.Telephony.SMS_RECEIVED”);registerReceiver(mBatteryInfoReceiver ,intentFilter);//反注册unregisterReceiver(receiver); 注意： 1.生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 Service, 由Service 来完成 . 这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的 2. 动态注册广播接收器还有一个特点，就是当用来注册的Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭,只要设备是开启状态,广播接收器也是打开着的。也就是说哪怕app本身未启动,该app订阅的广播在触发时也会对它起作用 系统常见广播Intent,如开机启动、电池电量变化、时间改变等广播 Service 服务: 一个Service 是一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。 比较好的一个例子就是一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。然而，音乐重放这个功能并没有对应的activity，因为使用者当然会认为在导航到其它屏幕时音乐应该还在播放的。在这个例子中，媒体播放器这个activity 会使用Context.startService()来启动一个service，从而可以在后台保持音乐的播放。同时，系统也将保持这个service 一直执行，直到这个service 运行结束。另外，我们还可以通过使用Context.bindService()方法，连接到一个service 上（如果这个service 还没有运行将启动它）。当连接到一个service 之后，我们还可以service 提供的接口与它进行通讯。拿媒体播放器这个例子来说，我们还可以进行暂停、重播等操作。 Service使用步骤如下 1&gt;继承service类 2&gt;AndroidManifast.xml配置清单文件中&lt;application&gt;节点里对服务进行配置 &lt;service name=&quot;.SMSService&quot;/&gt; 服务不能自己运行,需要通过Contex.startService()或Contex.bindService()启动服务 通过startService()方法启动的服务于调用者没有关系,即使调用者关闭了,服务仍然运行想停止服务要调用Context.stopService(),此时系统会调用onDestory(),使用此方法启动时,服务首次启动系统先调用服务的onCreate()–&gt;onStart(),如果服务已经启动再次调用只会触发onStart()方法 使用bindService()启动的服务与调用者绑定,只要调用者关闭服务就终止,使用此方法启动时,服务首次启动系统先调用服务的onCreate()–&gt;onBind(),如果服务已经启动再次调用不会再触发这2个方法,调用者退出时系统会调用服务的onUnbind()–&gt;onDestory(),想主动解除绑定可使用Contex.unbindService(),系统依次调用onUnbind()–&gt;onDestory(); Content Provider内容提供者 : android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。这些数据可以存储在文件系统中、在一个SQLite数据库、或以任何其他合理的方式, 其他应用可以通过ContentResolver类(见ContentProviderAccessApp例子)从该内容提供者中获取或存入数据.(相当于在应用外包了一层壳), 只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中 它的好处:统一数据访问方式。 android系统自带的内容提供者(顶级的表示数据库名,非顶级的都是表名)这些内容提供者在SDK文档的android.provider Java包中都有介绍。见：http://developer.android.com/reference/android/provider/package-summary.html ├────Browser ├────CallLog ├────Contacts │ ├────Groups │ ├────People │ ├────Phones │ └────Photos ├────Images │ └────Thumbnails ├────MediaStore │ ├────Albums │ ├────Artists │ ├────Audio │ ├────Genres │ └────Playlists ├────Settings └────Video CallLog：地址和接收到的电话信息 Contact.People.Phones：存储电话号码 Setting.System：系统设置和偏好设置 使用Content Provider对外共享数据的步骤 1&gt;继承ContentProvider类并根据需求重写以下方法: public boolean onCreate();//处理初始化操作 /** * 插入数据到内容提供者(允许其他应用向你的应用中插入数据时重写) * @param uri * @param initialValues 插入的数据 * @return */ public Uri insert(Uri uri, ContentValues initialValues); /** * 从内容提供者中删除数据(允许其他应用删除你应用的数据时重写) * @param uri * @param selection 条件语句 * @param selectionArgs 参数 * @return */ public int delete(Uri uri, String selection, String[] selectionArgs); /** * 更新内容提供者已存在的数据(允许其他应用更新你应用的数据时重写) * @param uri * @param values 更新的数据 * @param selection 条件语句 * @param selectionArgs 参数 * @return */ public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs); /** * 返回数据给调用者(允许其他应用从你的应用中获取数据时重写) * @param uri * @param projection 列名 * @param selection 条件语句 * @param selectionArgs 参数 * @param sortOrder 排序 * @return */ public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) ; /** * 用于返回当前Uri所代表数据的MIME类型 * 如果操作的数据为集合类型(多条数据),那么返回的类型字符串应该为vnd.android.cursor.dir/开头 * 例如要得到所有person记录的Uri为content://com.bravestarr.provider.personprovider/person, * 那么返回的MIME类型字符串应该为”vnd.android.cursor.dir/person” * 如果操作的数据为单一数据,那么返回的类型字符串应该为vnd.android.cursor.item/开头 * 例如要得到id为10的person记录的Uri为content://com.bravestarr.provider.personprovider/person/10, * 那么返回的MIME类型字符串应该为”vnd.android.cursor.item/person” * @param uri */ public String getType(Uri uri) 这些方法中的Uri参数,得到后需要进行解析然后做对应处理,Uri表示要操作的数据,包含两部分信息: 1.需要操作的contentprovider 2.对contentprovider中的什么数据进行操作,一个Uri格式:结构头://authorities(域名)/路径(要操作的数据,根据业务而定) content://com.bravestarr.provider.personprovider/person/10 说明:contentprovider的结构头已经由android规定为content:// authorities用于唯一标识这个contentprovider程序,外部调用者可以根据这个找到他 路径表示我们要操作的数据,路径的构建根据业务而定.路径格式如下: 要操作person表行号为10的记录,可以这样构建/person/10 要操作person表的所有记录,可以这样构建/person 2&gt;在AndroidManifest.xml中使用对ContentProvider进行配置注册(内容提供者注册它自己就像网站注册域名),ContentProvider采用authoritie(原意授权,可理解为域名)作为唯一标识,方便其他应用能找到 … 关于四大基本组件的一个总结： 1&gt; 4大组件的注册 4大基本组件都需要注册才能使用,每个Activity、service、Content Provider内容提供者都需要在AndroidManifest文件中进行配置AndroidManifest文件中未进行声明的activity、服务以及内容提供者将不为系统所见，从而也就不可用，而BroadcastReceive广播接收者的注册分静态注册（在AndroidManifest文件中进行配置）和通过代码动态创建并以调用Context.registerReceiver()的方式注册至系统。需要注意的是在AndroidManifest文件中进行配置的广播接收者会随系统的启动而一直处于活跃状态,只要接收到感兴趣的广播就会触发（即使程序未运行） AndroidManifest文件中进行注册格式如下： 元素的name 属性指定了实现了这个activity 的Activity 的子类。icon 和label 属性指向了包含展示给用户的此activity 的图标和标签的资源文件。 元素用于声明服务 元素用于声明广播接收器 元素用于声明内容提供者 2&gt; 4大组件的激活 • 容提供者的激活：当接收到ContentResolver 发出的请求后，内容提供者被激活。而其它三种组件──activity、服务和广播接收器被一种叫做intent 的异步消息所激活 • Activity的激活通过传递一个Intent 对象至Context.startActivity()或Activity.startActivityForResult()以载入（或指定新工作给）一个activity。相应的activity 可以通过调用getIntent() 方法来查看激活它的intent。如果它期望它所启动的那个activity 返回一个结果，它会以调用startActivityForResult()来取代startActivity()。比如说，如果它启动了另外一个Activity 以使用户挑选一张照片，它也许想知道哪张照片被选中了。结果将会被封装在一个Intent 对象中，并传递给发出调用的activity 的onActivityResult() 方法。 • 服务的激活可以通过传递一个Intent 对象至Context.startService()或Context.bindService()前者Android 调用服务的onStart()方法并将Intent 对象传递给它，后者Android 调用服务的onBind()方法将这个Intent 对象传递给它 • 发送广播可以通过传递一个Intent 对象至给Context.sendBroadcast() 、 Context.sendOrderedBroadcast()或Context.sendStickyBroadcast()Android 会调用所有对此广播有兴趣的广播接收器的onReceive()方法，将intent 传递给它们 3&gt; 四大组件的关闭 内容提供者仅在响应ContentResolver 提出请求的时候激活。而一个广播接收器仅在响应广播信息的时候激活。所以，没有必要去显式的关闭这些组件。 Activity关闭：可以通过调用它的finish()方法来关闭一个activity 服务关闭：对于通过startService()方法启动的服务要调用Context.stopService()方法关闭服务，使用bindService()方法启动的服务要调用Contex.unbindService ()方法关闭服务 CreatedbyEdwardZhang∣一个不只做技术的公众号 长按，识别二维码，加关注]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Chapter I. 磨人的不是 Android 而是 AndroidStudio :（]]></title>
    <url>%2F2017%2F06%2F09%2FAndroid%20Chapter%20I.%20%E7%A3%A8%E4%BA%BA%E7%9A%84%E4%B8%8D%E6%98%AF%20Android%20%E8%80%8C%E6%98%AF%20AndroidStudio%2F</url>
    <content type="text"><![CDATA[解决 Android Studio 创建项目时极其的慢的尴尬Android Studio 创建新项目的时候，会在进度条的界面滞留很久。 有时候一天都卡在这. 打开其它项目有些时候,也会出现这种情况。 这里写图片描述 ♦创建工程 原因：在创建新项目的时候导致进度条一直停在 Gradle:Project: 的主要原因就是，你导入的项目与你的IDE版本不匹配，此过程正在下载对应版本的 gradle。如果网络杯具的话， 呵呵 … 这里写图片描述 按照下面的步骤来就能完美解决这个问题，只要两步就OK了，Here we go ! 查看对应的 Gradle 版本找到你创建项目时的保存路径，项目根目录下的 gradle 文件夹 这里写图片描述 ♦找到 gradle 文件夹 接着双击进入 gradle 文件夹下找到 wrapper\gradle-wrapper.properties 文件 这里写图片描述 ♦gradle-wrapper.properties 打开这个文件 distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip在最后一行可以看到，当前项目使用的版本是 gradle-3.3-all，如果你的电脑上，已经下载了这个版本，那么项目很快就打开了。当然， 如果不存在的话，肯定是需要下载的 … 呵呵 你可以在以下位置找到电脑上安装了什么版本的 Gradle： 1%USERPROFILE%\.gradle\wrapper\dists 这里写图片描述 查看当前已安装的 Gradle 版本注意：有些时候，你会发现你创建的项目中根本没有 gradle 文件夹。 (我擦，那岂不是瞎比比了？) 当项目中不存在 gradle 文件夹的时候， 这种情况和创建新的项目是一样的。都默认使用 Android Studio 版本对应的 gradle 版本；也就是如果你的 Android Studio 版本越高, 对应的 gradle 版本就越高 … 具体的需要在 Android 官网 查看，或者查看 Android Studio 安装目录下的 gradle 文件夹。2. 手动下载对应的 Gradle 版本很多时候，自动下载会 很慢 很慢 很慢（重要的事情要说几遍来着？这就是创建项目时卡半天的原因），毕竟不是所有人的网络都那么吊 … 总有痛苦的人群 … 这个时候，就需要手动下载了。 手动下载之前，需要知道当前 Android Studio 对应的 Gradle 版本是多少 … 怎么看呢？ 方法1：官网查看 … (不推荐)方法2：在我们上面查看当前项目对应的 Gradle 版本时（项目名\gradle\wrapper\gradle-wrapper.properties ），这里的就是我们需要的版本，使用这个链接下载即可。 1distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip 那么我们下载好了，要保存在哪里呢，不急，我们结合下面这个方法一起看 方法3：（未创建项目的兄弟）打开 Android Studio，创建一个新项目，当出现进度条的时候. (一般来说会卡在这里.) 此时莫慌， 重点来了 打开这个路径： %USERPROFILE%\.gradle\wrapper\dists ，不出意外, 你会看到一个包含版本信息的文件夹.( 如果没有看到，那就等等 … ) 这里写图片描述 打开这个版本文件夹，你会看到一个随机生成的文件夹：( 这个文件夹特别需要注意，因为这是关键 。有些时候，你会发现，明明已经下载了对应版本的 Gradle，但是莫名其妙的又下载了一次。就是因为这个随机文件夹不对导致的。解决方法是，在每个随机文件夹中都 拷贝 一份你下载好的 gradle-版本-all.zip 就行了 ) 这里写图片描述 随机生成的文件夹如果上面的随机文件夹没有生成, 那就等等 …. 通过以上翻山越岭，我们只需要这个包含随机文件夹的路径 … 因为手动下载的 Gradle 必须放在这个苛刻的路径下，才有效 。 一定要按照对应的版本下载哦，并且一定要放在刚刚千辛万苦生成的随机文件夹的路径中… 之后，重启 Android Studio，再次创建新项目，你就会发现 … 哇塞，这么快 ??? 这里写图片描述 相见恨晚 hhh如果大家对这有趣实用的技术贴感兴趣我后期会继续努力的！请大家扫描二维码！关注我！ 这里写图片描述 这里写图片描述]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Access denied for user 'root'@'localhost' (using password YES)]]></title>
    <url>%2F2017%2F06%2F09%2FAccess%20denied%20for%20user%20'root'%40'localhost'%20(using%20password%20YES)%2F</url>
    <content type="text"><![CDATA[Access denied for user ‘root’@’localhost’ (using password:YES)安装成功的MySQL，再次登录问题。 1.登录出现Access denied for user ‘root’@’localhost’ (using password:YES)问题 认准登录命令是否写正确，请一定看仔细了。 1mysql -hlocalhost -uroot -p 然后输入密码。用户名一定为root。输错就是如上问题。 2.找不到默认的C：//pragramdata下MySQL数据库文件问题 在win10中programdata文件夹是被隐藏了的，显示隐藏即可。 如果要将已存在的数据库存放路径改为自己想要的，把原文件剪切到目标路径下。 然后，更改my.ini配置文件中的datadir值为目标路径。 重启MySQL即可。 注意： 如果修改了datadir路径，但是没有将原文件拷贝过来，会出现无法启动MySQL。 CreatedbyEdwardZhang∣一个不只做技术的公众号 长按，识别二维码，加关注]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Github+Hexo 搭建Blog]]></title>
    <url>%2F2016%2F06%2F08%2F%E5%88%A9%E7%94%A8%20Github%2BHexo%20%E6%90%AD%E5%BB%BABlog%2F</url>
    <content type="text"><![CDATA[Blog 就是用来记录自己的生活或是发表自己的见解的一种网络日记。既然一切互联网的初衷是 Free（自由） Free（免费），那我们又何必为了记日记而斥巨资呢？ wikipedia ♠♥♦♣ （From.wikipedia） So 干货 coming!今天EdwardZhang就来带大家看看如何0费用搭建符合自己审美的Blog！Here we go ~ 利用 Github+Hexo 进行搭建（以下过程基于Windows系统）准备工作：&emsp;1.安装Node.js&emsp;&ensp;&ensp;下载地址：传送门&emsp;&ensp;&ensp;去 NodeJs 官网下载相应版本，进行安装即可。&emsp;&ensp;&ensp;可以通过node -v的命令来测试NodeJS是否安装成功 这里写图片描述 &emsp;2.安装Git&emsp;&ensp;&ensp;下载地址：传送门&emsp;&ensp;&ensp;去 Git 官网下载相应版本，进行安装即可。 git1 git2 git3 git4 git5 &emsp;&ensp;&ensp;可以通过git –version的命令来测试git是否安装成功 gitcmd &emsp;3.注册Github账号&emsp;&ensp;&ensp;去 Github 官网进行注册即可。&emsp;&ensp;&ensp;注册完之后记得添加 SSH Key。&emsp;&ensp;&ensp;这个 SSH Key是一个认证，让github识别绑&emsp;&ensp;&ensp;这台机器，允许这台机器提交。执行如下命令：&emsp;&ensp;&ensp;cd ~/.ssh&emsp;&ensp;&ensp;~这个符号，表示在用户目录下&emsp;&ensp;&ensp;执行代码如果提示：No such file or directory 说明你是第一次使用git。&emsp;&ensp;&ensp;下面就说下怎么配置SSH Key。&emsp;&ensp;&ensp;生产新的SSH Key配置&emsp;&ensp;&ensp;在Git Bash执行代码：（此处有坑！要注意运行Git Bash时右键使用管理员身份运行）&emsp;&ensp;&ensp;ssh-keygen -t rsa -C &quot;your email address&quot;&emsp;&ensp;&ensp;记得修改成你自己邮箱地址。&emsp;&ensp;&ensp;成功后会生成两个文件id_rsa 以及id_rsa.pub。&emsp;&ensp;&ensp;这两个文件在刚才用户的.ssh目录下&emsp;&ensp;&ensp;如图： 12345 &emsp;&ensp;&ensp;id_rsa&emsp;&ensp;&ensp;id_rsa.pub 0 &emsp;&ensp;&ensp;之后在github添加SSH Key,在任意界面右上角&emsp;&ensp;&ensp;点击你的头像，选择Settings-&gt; SSH keys-&gt;New SSH key 这里写图片描述&emsp;&ensp;&ensp;Congratulations！&emsp;&ensp;&ensp;添加成功！ 搭建博客：&emsp;1.安装Hexo&emsp;&ensp;&ensp;在本地新建一个Blog文件夹，文件右键，选择Git Bash。 这里写图片描述 输入指令安装hexo：npm install -g hexo&emsp;&ensp;&ensp;等安装完毕，通过输入hexo的命令来测试Hexo是否安装成功，成功如下图展示： 这里写图片描述 接着初始化Hexo：hexo init hexo&emsp;&ensp;&ensp;初始化成功会显示Start blogging with Hexo! 1 &emsp;&ensp;&ensp;这时在你刚才创建的Blog里面会多出一个hexo文件 这里写图片描述 &emsp;&ensp;&ensp;进入到hexo目录，输入指令npm install&emsp;&ensp;&ensp;安装依赖文件以及部署形成文件&emsp;&ensp;&ensp;打开hexo目录 cd hexo&emsp;&ensp;&ensp;安装依赖文件 npm install&emsp;&ensp;&ensp;部署形成文件 hexo generatehexo generate 123 &emsp;&ensp;&ensp;最后只剩下运行server&emsp;&ensp;&ensp;跑起hexo服务&emsp;&ensp;&ensp;hexo server 这里写图片描述 &emsp;&ensp;&ensp;这时提示&emsp;&ensp;&ensp;Hexo is running at http://loalhost:4000/.&emsp;&ensp;&ensp;接着我们打开浏览器，输入http://localhost:4000&emsp;&ensp;&ensp;便可看到默认的博客，如图： 12 &emsp;&ensp;&ensp;至此，hexo已经安装完毕。&emsp;配置githubPage：&emsp;&ensp;&ensp;登录github，点击“New respository” &emsp;&ensp;&ensp;新建一个仓库&emsp;&ensp;&ensp;输入仓库名：你的github名称,github.io&emsp;&ensp;&ensp;（这里千万不要心存侥幸随意输域名。。。后果你懂）&emsp;&ensp;&ensp;然后点击Create repository。 这里写图片描述 &emsp;&ensp;&ensp;注意：这边的创建名字&emsp;&ensp;&ensp;一定要用的github的用户名！&emsp;&ensp;&ensp;一定要用的github的用户名！&emsp;&ensp;&ensp;一定要用的github的用户名！&emsp;启用GitHub Page&emsp;&ensp;&ensp;点击右边的“Setting”菜单进入设置 这里写图片描述 &emsp;&ensp;&ensp;拉到最下面&emsp;&ensp;&ensp;点击 Choose a theme&emsp;&ensp;&ensp;随便选择一个样式 之后会用自己的hexo覆盖&emsp;&ensp;&ensp;点击”Publish page”&emsp;&ensp;&ensp;发布github默认生成的一个静态站点&emsp;&ensp;&ensp;试着打开自己在github的静态网址，&emsp;&ensp;&ensp;我的https://Edward7Zhang.github.io ，&emsp;&ensp;&ensp;你会发现，&emsp;&ensp;&ensp;打开是你自己刚才选择静态站点模版。&emsp;&ensp;&ensp;将本地hexo项目托管到Github&emsp;&ensp;&ensp;打开修改hexo目录下配置文件_config.yml 这里写图片描述 &emsp;&ensp;&ensp;编辑最后面的deploy属性，加入代码： 1234type: gitrepository: git@github.com:your-github-name/your-github-name.github.io.gitbranch: master type使用是git。 &emsp;&ensp;&ensp;repository属性改成你的刚才创建仓库git地址。&emsp;&ensp;&ensp;分支branch填写master。&emsp;&ensp;&ensp;这边说下本地网站配置文件 _config.yml&emsp;&ensp;&ensp;网站的配置文件，&emsp;&ensp;&ensp;你可以在这里配置一些基本信息。&emsp;&ensp;&ensp;（只要你过了四级应该都懂 /// ///）&emsp;&ensp;&ensp;根据自己的需要修改即可！&emsp;&ensp;&ensp;安装hexo-deployer-git插件 1cnpm install hexo-deployer-git --save 这里写图片描述 &emsp;&ensp;&ensp;部署你本地的主题到github上 &emsp;&ensp;&ensp;代码如下，每次修改本地主题，都需要执行以下代码： 123hexo cleanhexo generator #简写 hexo ghexo deploy #简写 hexo d 这里写图片描述 这里写图片描述 这里写图片描述 &emsp;&ensp;&ensp;最后看下，部署到github上的效果！ 这里写图片描述 &emsp;&ensp;&ensp;Congratulation!!!Finished this project! ​&emsp;&ensp;&ensp;是不是瞬间感觉自己强的不行 这里写图片描述 &emsp;&ensp;&ensp;OK,以上为Windows下使用Hexo+Github搭建个人博客。 怎么样No Pay，More Gain 这里写图片描述]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to EdwardZhang’s Blog! This is my first step,there are more about my codingLife and insLife.You can ask me on GitHub or Weibo. -haveaniceday.]]></content>
  </entry>
</search>