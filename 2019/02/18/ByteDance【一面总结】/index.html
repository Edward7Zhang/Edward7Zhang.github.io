<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    
    
    
    <title>ByteDance【一面总结】 | EdwardZhang&#39;s Blog | Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Interview">
    <meta name="description" content="大概在数天前投递了字节跳动-抖音方向的实习生岗位昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题） 1.Java中的引用类型有没有什么了解？Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。 StrongReference（强引用） SoftReference（软引">
<meta name="keywords" content="Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="ByteDance【一面总结】">
<meta property="og:url" content="https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/index.html">
<meta property="og:site_name" content="EdwardZhang&#39;s Blog">
<meta property="og:description" content="大概在数天前投递了字节跳动-抖音方向的实习生岗位昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题） 1.Java中的引用类型有没有什么了解？Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。 StrongReference（强引用） SoftReference（软引">
<meta property="og:updated_time" content="2019-03-02T14:28:47.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ByteDance【一面总结】">
<meta name="twitter:description" content="大概在数天前投递了字节跳动-抖音方向的实习生岗位昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题） 1.Java中的引用类型有没有什么了解？Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。 StrongReference（强引用） SoftReference（软引">
    
        <link rel="alternate" type="application/atom+xml" title="EdwardZhang&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">EdwardZhang</h5>
          <a href="mailto:super7edwardzhang@gmail.com" title="super7edwardzhang@gmail.com" class="mail">super7edwardzhang@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Homepage
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/photo"  >
                <i class="icon icon-lg icon-photo"></i>
                Album
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Edward7Zhang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/3100298257/home?wvr=5" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.instagram.com/major7edward/" target="_blank" >
                <i class="icon icon-lg icon-instagram"></i>
                Instagram
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/link"  >
                <i class="icon icon-lg icon-link"></i>
                Friends&#39; Link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">ByteDance【一面总结】</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">ByteDance【一面总结】</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-02-18T11:07:14.000Z" itemprop="datePublished" class="page-time">
  2019-02-18
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-Java中的引用类型有没有什么了解？"><span class="post-toc-number">1.</span> <span class="post-toc-text">1.Java中的引用类型有没有什么了解？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#引用类型对比"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">引用类型对比</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-StrongReference（强引用）"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">1.StrongReference（强引用）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-SoftReference（软引用）"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">2.SoftReference（软引用）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-WeakReference（弱引用）"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">3.WeakReference（弱引用）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-PhantomReference（虚引用）"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">4.PhantomReference（虚引用）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-Java中创建线程的方式有哪些"><span class="post-toc-number">2.</span> <span class="post-toc-text">2.Java中创建线程的方式有哪些</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-继承Thread类创建线程类"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">1.继承Thread类创建线程类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-通过Runnable接口创建线程类"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2.通过Runnable接口创建线程类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-通过Callable和Future创建线程"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">3.通过Callable和Future创建线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建线程的三种方式的对比"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">创建线程的三种方式的对比</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-Object类对象含有的方法有哪些？"><span class="post-toc-number">3.</span> <span class="post-toc-text">3.Object类对象含有的方法有哪些？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-Android中的进程间通信有哪些方式？具体说说Binder"><span class="post-toc-number">4.</span> <span class="post-toc-text">4.Android中的进程间通信有哪些方式？具体说说Binder</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-使用Intent"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">1.使用Intent</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-使用文件共享"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">2.使用文件共享</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem.</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"><span class="post-toc-number">4.2.3.</span> <span class="post-toc-text">3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-使用Messenger"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">3.使用Messenger</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-使用AIDL"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">4.使用AIDL</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-Android中的AsyncTask的作用？"><span class="post-toc-number">5.</span> <span class="post-toc-text">5.Android中的AsyncTask的作用？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-Android中的消息机制？"><span class="post-toc-number">6.</span> <span class="post-toc-text">6.Android中的消息机制？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-Android中的事件分发机制了解多少？如何解决滑动冲突"><span class="post-toc-number">7.</span> <span class="post-toc-text">7.Android中的事件分发机制了解多少？如何解决滑动冲突</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-Java中的抽象类和接口的区别？"><span class="post-toc-number">8.</span> <span class="post-toc-text">8.Java中的抽象类和接口的区别？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#理解抽象"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">理解抽象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#语法定义理解"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">语法定义理解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-抽象类"><span class="post-toc-number">8.2.1.</span> <span class="post-toc-text">1.抽象类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-接口"><span class="post-toc-number">8.2.2.</span> <span class="post-toc-text">2.接口</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#编程角度理解"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">编程角度理解</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一般性理解"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">一般性理解</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-Java设计模式了解多少？观察者模式在哪里使用过？"><span class="post-toc-number">9.</span> <span class="post-toc-text">9.Java设计模式了解多少？观察者模式在哪里使用过？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？"><span class="post-toc-number">10.</span> <span class="post-toc-text">10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？</span></a></li></ol>
        </nav>
    </aside>


<article id="post-ByteDance【一面总结】"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">ByteDance【一面总结】</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-02-18 19:07:14" datetime="2019-02-18T11:07:14.000Z"  itemprop="datePublished">2019-02-18</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>大概在数天前投递了字节跳动-抖音方向的实习生岗位<br>昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题）</p>
<h2 id="1-Java中的引用类型有没有什么了解？"><a href="#1-Java中的引用类型有没有什么了解？" class="headerlink" title="1.Java中的引用类型有没有什么了解？"></a>1.Java中的引用类型有没有什么了解？</h2><p>Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。</p>
<pre><code>StrongReference（强引用）
SoftReference（软引用）
WeakReference（弱引用）
PhantomReference（虚引用）
</code></pre><h3 id="引用类型对比"><a href="#引用类型对比" class="headerlink" title="引用类型对比"></a>引用类型对比</h3><table>
<thead>
<tr>
<th>序号</th>
<th>引用类型</th>
<th>取得目标对象方式</th>
<th>垃圾回收条件</th>
<th>是否可能内存泄漏</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>强引用</td>
<td>直接调用</td>
<td>不回收</td>
<td>可能</td>
</tr>
<tr>
<td>2</td>
<td>软引用</td>
<td>通过 get()方法</td>
<td>视内存情况回收</td>
<td>不可能</td>
</tr>
<tr>
<td>3</td>
<td>弱引用</td>
<td>通过 get()方法</td>
<td>永远回收</td>
<td>不可能</td>
</tr>
<tr>
<td>4</td>
<td>虚引用</td>
<td>无法取得</td>
<td>不回收</td>
<td>可能</td>
</tr>
</tbody>
</table>
<h4 id="1-StrongReference（强引用）"><a href="#1-StrongReference（强引用）" class="headerlink" title="1.StrongReference（强引用）"></a>1.StrongReference（强引用）</h4><p>如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</div></pre></td></tr></table></figure>
<h4 id="2-SoftReference（软引用）"><a href="#2-SoftReference（软引用）" class="headerlink" title="2.SoftReference（软引用）"></a>2.SoftReference（软引用）</h4><p>如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p>
<h4 id="3-WeakReference（弱引用）"><a href="#3-WeakReference（弱引用）" class="headerlink" title="3.WeakReference（弱引用）"></a>3.WeakReference（弱引用）</h4><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>    弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>    <br><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">WeakReference&lt;String[]&gt; weakBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">WeakReference&lt;String[]&gt; softBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p>
<h4 id="4-PhantomReference（虚引用）"><a href="#4-PhantomReference（虚引用）" class="headerlink" title="4.PhantomReference（虚引用）"></a>4.PhantomReference（虚引用）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">PhantomReference&lt;String[]&gt; referent = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p>
<h2 id="2-Java中创建线程的方式有哪些"><a href="#2-Java中创建线程的方式有哪些" class="headerlink" title="2.Java中创建线程的方式有哪些"></a>2.Java中创建线程的方式有哪些</h2><h3 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h3><pre><code>(1) 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
(2) 创建Thread子类的实例，即创建了线程对象。
(3) 调用线程对象的start()方法来启用该线程。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">FirstThreadTest</span>  <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>  i  =  <span class="number">0</span>; <span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">			System.out.println(getName() +  <span class="string">" "</span>  + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>  i  =  <span class="number">0</span>; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() +  <span class="string">" : "</span>  + i);</div><div class="line">			<span class="keyword">if</span> (i ==  <span class="number">20</span>) &#123;</div><div class="line">				<span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line">				<span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName() 方法返回调用该方法的线程的名字。</p>
<h3 id="2-通过Runnable接口创建线程类"><a href="#2-通过Runnable接口创建线程类" class="headerlink" title="2.通过Runnable接口创建线程类"></a>2.通过Runnable接口创建线程类</h3><pre><code>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法 体同样是该线程的线程执行体。
（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread 对象，该Thread对象才是真正的线程对象。
（3）调用线程对象的start()方法来启动该线程。
</code></pre><h3 id="3-通过Callable和Future创建线程"><a href="#3-通过Callable和Future创建线程" class="headerlink" title="3.通过Callable和Future创建线程"></a>3.通过Callable和Future创建线程</h3><pre><code>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行 体，并且有返回值。
（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该 FutureTask对象封装了该Callable对象的call()方法的返回值。
（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。
（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用 get()方法会阻塞线程。
</code></pre><h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><p>采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程 来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型， 较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接 使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<h2 id="3-Object类对象含有的方法有哪些？"><a href="#3-Object类对象含有的方法有哪些？" class="headerlink" title="3.Object类对象含有的方法有哪些？"></a>3.Object类对象含有的方法有哪些？</h2><p>Java中的Object类是所有类的父类，它提供了以下11个方法：</p>
<pre><code>1.public final native Class&lt;?&gt;getClass()
2.public native int hashCode()
3.public boolean equals(Object obj)
4.protected native Object clone() throws CloneNotSupportedException
5.public String toString()
6.public final native void notify()
7.public final native void notifyAll()
8.public final native void wait(long timeout) throws InterruptedException
9.public final void wait(long timeout,int nanos)throws InterruptedException
10.public final void wait() throws InterruptedException
11.protected void finalize() throws Throwable{}
</code></pre><h2 id="4-Android中的进程间通信有哪些方式？具体说说Binder"><a href="#4-Android中的进程间通信有哪些方式？具体说说Binder" class="headerlink" title="4.Android中的进程间通信有哪些方式？具体说说Binder"></a>4.Android中的进程间通信有哪些方式？具体说说Binder</h2><p>Android中的IPC方式</p>
<pre><code>使用Intent
使用文件共享
使用Messenger
使用AIDL
使用ContentProvider
使用Socket
</code></pre><h3 id="1-使用Intent"><a href="#1-使用Intent" class="headerlink" title="1.使用Intent"></a>1.使用Intent</h3><h4 id="1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"><a href="#1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。" class="headerlink" title="1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"></a>1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。</h4><h4 id="2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"><a href="#2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。" class="headerlink" title="2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"></a>2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。</h4><h3 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2.使用文件共享"></a>2.使用文件共享</h3><h4 id="1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem"><a href="#1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem" class="headerlink" title="1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem."></a>1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem.</h4><h4 id="2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"><a href="#2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）" class="headerlink" title="2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"></a>2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）</h4><h4 id="3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"><a href="#3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。" class="headerlink" title="3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"></a>3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。</h4><h3 id="3-使用Messenger"><a href="#3-使用Messenger" class="headerlink" title="3.使用Messenger"></a>3.使用Messenger</h3><p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，可以在不同进程中传递Message对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形</p>
<ul>
<li><p>服务端进程：服务端创建一个Service来处理客户端请求，同时通过一个Handler对象来实例化一个Meaaenger对象，然后在Servive的onBind中返回这个Messenger对象底层的Binder即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerSercive</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MessengerSercive.class.getSimpleName();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> msg</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</div><div class="line">                    Log.d(TAG, <span class="string">"receive msg from client: msg = ["</span></div><div class="line">                    + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>);</div><div class="line">                    Toast.makeText(MessengerService.<span class="keyword">this</span>, <span class="string">"receive msg from client: msg = ["</span> + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                    Messenger client = msg.replyTo;</div><div class="line">                    Message replyMsg = Message.obtain(<span class="keyword">null</span>, Constants.MSG_FROM_SERVICE);</div><div class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">                    bundle.putString(Constants.MSG_KEY, <span class="string">"我已经收到你的消息，稍后回复你！"</span>);</div><div class="line">                    replyMsg.setData(bundle);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        client.send(replyMsg);</div><div class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> mMessenger.getBinder();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客户端进程：首先绑定服务端Service，绑定成功之后用服务端的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，消息类型是Message。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个Messenger（和服务端一样），并通过Message的replyTo参数传递给服务端。服务端通过Message的replyTo参数就可以回应客户端了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity&#123;</div><div class="line">    private static final String TAG = MainActivity.class.getSimpleName();</div><div class="line">    private Messenger mGetReplyMessenger = new Messenger(new MessageHandler());</div><div class="line">    private Messenger mService;</div><div class="line">    private class MessageHandler extends Handler&#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg)&#123;</div><div class="line">            switch(msg.what)&#123;</div><div class="line">                case Constants.MSG_FROM_SERVICE:</div><div class="line">                Log.d(TAG, "received msg form service: msg = </div><div class="line">                [" + msg.getData().getString(Constants.MSG_KEY) + "]");</div><div class="line">                Toast.makeText(MainActivity.this, "received vice: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                super.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInsttanceState)&#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">    public void bindService(View v)&#123;</div><div class="line">        Intent mIntent = new Intent(thia,MessengerService.class);</div><div class="line">        bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">    public void sendMessage(View v)&#123;</div><div class="line">        Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);</div><div class="line">        Bundle data = new Bunle();</div><div class="line">        data.putString(Constants.MSG_KEY, "Hello! This is client.");</div><div class="line">        msg.setData(data);</div><div class="line">        msg.replyTo = mGetReplyMessenger;</div><div class="line">        try&#123;</div><div class="line">            mService.send(mag);</div><div class="line">        &#125;catch(RemoteException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDestroy()&#123;</div><div class="line">        unbindService(mServiceConnection);</div><div class="line">        super.onDestroy();</div><div class="line">    &#125;</div><div class="line">    private ServiceConnection mServiceConnection = new ServiceConnection()&#123;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         * @param service</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder service)&#123;</div><div class="line">            mService = new Messenger(service);</div><div class="line">            Message msg = Message.obtain(null, Constants.MSG_FROM_CLIENT);</div><div class="line">            Bundle data = new Bundle();</div><div class="line">            data.putString(Constants.MSG_KEY,"Hello! This is cient.");</div><div class="line">            msg.setData(data);</div><div class="line">            mag.replyTo = mGetReplyMessenger;</div><div class="line">            try&#123;</div><div class="line">                mService.send(msg);</div><div class="line">            &#125;catch(RemoteException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceDiscommected(ComponentName name)&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意： 客户端和服务端是通过通过拿到对方的Messenger来发送Message的。只不过客户端通过bindService onServiceConnected而服务端通过message.replyTo来获得对方的Messenger。Messenger中有一个Hanlder以串行的方式处理队列中的消息。不存在并发执行，因此我们不考虑线程同步的问题。</p>
<h3 id="4-使用AIDL"><a href="#4-使用AIDL" class="headerlink" title="4.使用AIDL"></a>4.使用AIDL</h3><p>Messenger是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用Messenger，而且Messenger只适合传递消息，不能跨进程调用方法的问题，要知道Messenger本质上也是AIDL，只不过系统做了封装方便上层的调用而已。</p>
<p><strong>AIDL文件支持的数据类型</strong></p>
<ul>
<li>基本数据类型；</li>
<li>String和CharSequence；</li>
<li>ArrayList，里面的元素必须能够被AIDL支持；</li>
<li>HashMap，实现Parcelable接口的对象；注意：如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件。</li>
<li>AIDL，AIDL接口本身也可以在AIDL文件中使用。<br><strong>服务端</strong><br>服务端创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。<br><strong>客户端</strong><br>绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，然后就可以调用AIDL中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致ANR。客户端的onServiceConnected和onServiceDisconnected方法都在UI线程中。</li>
</ul>
<h2 id="5-Android中的AsyncTask的作用？"><a href="#5-Android中的AsyncTask的作用？" class="headerlink" title="5.Android中的AsyncTask的作用？"></a>5.Android中的AsyncTask的作用？</h2><h2 id="6-Android中的消息机制？"><a href="#6-Android中的消息机制？" class="headerlink" title="6.Android中的消息机制？"></a>6.Android中的消息机制？</h2><h2 id="7-Android中的事件分发机制了解多少？如何解决滑动冲突"><a href="#7-Android中的事件分发机制了解多少？如何解决滑动冲突" class="headerlink" title="7.Android中的事件分发机制了解多少？如何解决滑动冲突"></a>7.Android中的事件分发机制了解多少？如何解决滑动冲突</h2><h2 id="8-Java中的抽象类和接口的区别？"><a href="#8-Java中的抽象类和接口的区别？" class="headerlink" title="8.Java中的抽象类和接口的区别？"></a>8.Java中的抽象类和接口的区别？</h2><h3 id="理解抽象"><a href="#理解抽象" class="headerlink" title="理解抽象"></a>理解抽象</h3><p>abstract class 和 interface 是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract calss和interface之间对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。</p>
<p>其实，两者之间还是有很大区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p>
<h3 id="语法定义理解"><a href="#语法定义理解" class="headerlink" title="语法定义理解"></a>语法定义理解</h3><h4 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修饰的数据成员（也就是必须是<strong>static final</strong>的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract calss。</p>
<h3 id="编程角度理解"><a href="#编程角度理解" class="headerlink" title="编程角度理解"></a>编程角度理解</h3><p>首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多继承的支持方面的一种折中考虑吧。</p>
<p>其次，在abstract class的定义中，我们可以赋予方法的默认行为。</p>
<p>但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用<strong>default</strong>关键字实现默认方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 Java 8 之前，接口与其实现类之间的<strong>耦合度</strong>太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在lambda表达式作为Java8语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。</p>
<h3 id="一般性理解"><a href="#一般性理解" class="headerlink" title="一般性理解"></a>一般性理解</h3><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是“like-a”关系，抽象类反映的是“is-a”关系。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（if they are class），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它，所以，在高级语言上，一个类只能继承一个类（抽象类）（正如人不可能同时是生物和非生物），但是可以实现多个接口（吃饭接口、走路接口）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
2.抽象类要被子类继承，接口要被类实现。
3.接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
4.抽象类里可以没有抽象方法。
5.接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。
6.接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。
7.抽象类不能在Java 8的 lambda 表达式中使用。
</code></pre><h2 id="9-Java设计模式了解多少？观察者模式在哪里使用过？"><a href="#9-Java设计模式了解多少？观察者模式在哪里使用过？" class="headerlink" title="9.Java设计模式了解多少？观察者模式在哪里使用过？"></a>9.Java设计模式了解多少？观察者模式在哪里使用过？</h2><h2 id="10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？"><a href="#10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？" class="headerlink" title="10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？"></a>10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？</h2>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-03-02T14:28:47.932Z" itemprop="dateUpdated">2019-03-02 22:28:47</time>
</span><br>


        
        Original Link：<a href="/2019/02/18/ByteDance【一面总结】/" target="_blank" rel="external">https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/</a>
        
    </div>
    
    <footer>
        <a href="https://edward7zhang.github.io">
            <img src="/img/avatar.jpg" alt="EdwardZhang">
            EdwardZhang
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/">Interview</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/&title=《ByteDance【一面总结】》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/&title=《ByteDance【一面总结】》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ByteDance【一面总结】》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/03/01/记一道简单的Java面试题/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">记一道简单的Java面试题【转载自 知乎——方志宏】</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/01/26/深度学习模型的转换/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">深度学习模型的转换 [学习&amp;转载]</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'EdwardZhang777';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>EdwardZhang &copy; 2016 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/&title=《ByteDance【一面总结】》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/&title=《ByteDance【一面总结】》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ByteDance【一面总结】》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACqElEQVR42u3aQXLjMAwEQP//09kHpGTPEETWh+bJpZIlNg8kBOD1isfPw3i68/2/8qf9fs5rY+Dh4eFdmnoy0feTeLryfjmS/xbLhIeHh7fGS7b4jUPl1jI9XsfDw8P7St77qeTHwN378fDw8L6Tl4e2Zxg8PDy8b+bNA988LJ6Hyyu5Fjw8PLyTStMrD5r/7++V+h4eHh7euKrelvbztMUkEC9mi4eHh7fAyzfcNsWQtx20sHqeeHh4eAu8ZPuuk6dvUxhnhbS22QsPDw9vg9e68xecIduA/sPM8fDw8BZ4eZF+AmtLU+2BVNT38PDw8K7yzl68F0DnBblrt+Lh4eEFdyZJh7b1atK62ha3PswfDw8Pb4F3N/xNEq9nU2zbF4pDAg8PD6/ktenRjamfpXqjQB8PDw9vgdeOWy1Wd9O1k6QGHh4eXvvMtlX0rAyWHBLzdquo6QoPDw9vgddu0235vw3Bz95V9ETg4eHhnVT8o4/8vLlqEmTPy2yPSDw8PLxLvDwzkbcCtAnis00/Cq/x8PDwFngTTJueyAtj7dvzjwE8PDy8Dd4Z7G7YPUl/vObnGx4eHl7AO2O07QVnrQntwj2mJPDw8PAu8XLApDB2luS9EEzj4eHh/cl3+iQIzq+0YXR7JDx2SeDh4eFd4rUJ1jbDkSzcrTvrOB0PDw/vEi/PZEy2/nxxR81heHh4eMu85MrkkEgW5fLAw8PDW4C1DQFnKdd501Xb5oWHh4e3wTvbY+eHSvI7L3RdOFTw8PDwSl5+GCTheBuCnxXYiuYGPDw8vDVeWzlqU6vzFMlhMgUPDw/vy3jtAXBWTps0GeDh4eF9M2+evDhrS/1w/ODh4eGt8SZbdptybQP0s7QvHh4e3h6v/eCfBLj5VPIluzDw8PDwUt4/oScNAZ8GfboAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '42';
            clearTimeout(titleTime);
        } else {
            document.title = 'Don‘t Panic！';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
