<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    
    
    
    <title>Android中的内存泄漏总结 | EdwardZhang&#39;s Blog | Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Android,Interview,Java">
    <meta name="description" content="内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。我会从 Java 内存泄漏的基础知识开始，并且通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。篇幅略长，大家可以分几节来看！  Jav">
<meta name="keywords" content="Android,Interview,Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Android中的内存泄漏总结">
<meta property="og:url" content="https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/index.html">
<meta property="og:site_name" content="EdwardZhang&#39;s Blog">
<meta property="og:description" content="内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。我会从 Java 内存泄漏的基础知识开始，并且通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。篇幅略长，大家可以分几节来看！  Jav">
<meta property="og:image" content="https://i.loli.net/2019/03/11/5c8674f523b99.jpg">
<meta property="og:image" content="https://i.loli.net/2019/03/12/5c871a5d9d98d.jpg">
<meta property="og:image" content="https://i.loli.net/2019/03/12/5c874d760fdfd.png">
<meta property="og:updated_time" content="2019-03-12T07:21:37.394Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android中的内存泄漏总结">
<meta name="twitter:description" content="内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。我会从 Java 内存泄漏的基础知识开始，并且通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。篇幅略长，大家可以分几节来看！  Jav">
<meta name="twitter:image" content="https://i.loli.net/2019/03/11/5c8674f523b99.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="EdwardZhang&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">EdwardZhang</h5>
          <a href="mailto:super7edwardzhang@gmail.com" title="super7edwardzhang@gmail.com" class="mail">super7edwardzhang@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Homepage
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/photo"  >
                <i class="icon icon-lg icon-photo"></i>
                Album
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Edward7Zhang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/3100298257/home?wvr=5" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.instagram.com/major7edward/" target="_blank" >
                <i class="icon icon-lg icon-instagram"></i>
                Instagram
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/link"  >
                <i class="icon icon-lg icon-link"></i>
                Friends&#39; Link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android中的内存泄漏总结</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Android中的内存泄漏总结</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-03-11T04:07:14.000Z" itemprop="datePublished" class="page-time">
  2019-03-11
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java-内存分配策略"><span class="post-toc-number">1.</span> <span class="post-toc-text">Java 内存分配策略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#栈与堆的区别："><span class="post-toc-number">1.1.</span> <span class="post-toc-text">栈与堆的区别：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java-是如何管理内存"><span class="post-toc-number">2.</span> <span class="post-toc-text">Java 是如何管理内存</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#什么是-Java-中的内存泄漏"><span class="post-toc-number">3.</span> <span class="post-toc-text">什么是 Java 中的内存泄漏</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Android-中常见的内存泄漏汇总"><span class="post-toc-number">4.</span> <span class="post-toc-text">Android 中常见的内存泄漏汇总</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Android中的内存泄漏总结"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Android中的内存泄漏总结</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-03-11 12:07:14" datetime="2019-03-11T04:07:14.000Z"  itemprop="datePublished">2019-03-11</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。<br>我会从 Java 内存泄漏的基础知识开始，并且通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。<br>篇幅略长，大家可以分几节来看！</p>
</blockquote>
<h1 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h1><p>Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配、堆式分配，对应的三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p>
<ul>
<li>静态存储区(方法区)：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</li>
<li>栈区：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆区：又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</li>
</ul>
<h2 id="栈与堆的区别："><a href="#栈与堆的区别：" class="headerlink" title="栈与堆的区别："></a>栈与堆的区别：</h2><p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。挡在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。<br>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。<br>举个🌰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Sample</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> s1 = <span class="number">0</span>;</div><div class="line">  Sample mSample1 = <span class="keyword">new</span> Sample();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> s2 = <span class="number">1</span>;</div><div class="line">    Sample mSample2 = <span class="keyword">new</span> Sample();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sample mSample3 = <span class="keyword">new</span> Sample();</div></pre></td></tr></table></figure></p>
<p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。<br>结论：</p>
<ul>
<li>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。因为它们属于方法中的变量，生命周期随方法而结束。</li>
<li>成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）。因为它们属于类，类对象终究是要被 new 出来使用的。</li>
</ul>
<p>了解了 Java 的内存分配之后，我们来看看 Java 是怎么管理内存的。</p>
<h1 id="Java-是如何管理内存"><a href="#Java-是如何管理内存" class="headerlink" title="Java 是如何管理内存"></a>Java 是如何管理内存</h1><p>Java 的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存（基本类型除外），所有的对象都在堆（Heap）中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了 JVM 的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。</p>
<p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p>
<p>为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用这指向被引用对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点科大的对象都是有效对象，GC 将不回收这些对象。如果某个对象（连通子图）与这个根顶点不可达（注意，该图为有向图），那么我们认为这个（这些）对象不再被引用，可以被 GC 回收。一下，我们举一个例子说明 JVM 的内存分配情况。以下右图，就是左边程序运行到第 6 行的示意图。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/03/11/5c8674f523b99.jpg" alt="1552315574(1).jpg" title="">
                </div>
                <div class="image-caption">1552315574(1).jpg</div>
            </figure><br>Java 使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如 COM 模型采用计数器方式管理构建，它与有向图相比，精度很低（很难处理循环引用的问题），但执行效率很高。</p>
<h1 id="什么是-Java-中的内存泄漏"><a href="#什么是-Java-中的内存泄漏" class="headerlink" title="什么是 Java 中的内存泄漏"></a>什么是 Java 中的内存泄漏</h1><p>在 Java 中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即 程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。<br>在 C++ 中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于 C++ 中没有 GC，这些内存将永远回收不回来。在 Java 中，这些不可达的对象都是由 GC 负责回收，因此程序员不需要考虑这部分的内存泄漏。<br>通过分析，我们得知，对于 C++，程序员需要自己管理边和顶点，而对于 Java 程序员只要管理边就可以了（不需要管理顶点的释放）。通过这种方式，Java 提高了编程的效率。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/03/12/5c871a5d9d98d.jpg" alt="1552357959(1).jpg" title="">
                </div>
                <div class="image-caption">1552357959(1).jpg</div>
            </figure>
<p>因此，通过以上分析，我们知道在 Java 中也有内存泄漏，但范围比 C++ 要小一些。因为 Java 从语言上保证，任何对象都是可达，所有的不可达对象都是由 GC 管理。</p>
<p>对于程序员来说，GC 基本是透明的，不可见的。虽然我们只有几个函数可以访问 GC，例如运行 GC 的函数 System.gc()，但是根据 Java 语言规范定义，该函数不保证 JVM 的垃圾收集器一定会执行。因为，不同的 JVM 实现者可能使用不同的算法管理 GC。通常，GC 的线程的优先级别较低。JVM 调用 GC 的策略也有很多种，有的是内存使用达到一定程度时，GC 才开始工作，也有定时执行的，有的是平缓执行 GC，有的是中断式执行 GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC 的执行影响应用程序的性能，例如对于基本 Web 的实时系统，如网络游戏等，用户不希望 GC 突然中断应用程序执行而进行垃圾回收，那么我们需要调整 GC 的参数，让 GC 能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun 提供的 HotSpot JVM 就支持这一特性。<br>同样给出一个 Java 内存泄漏的典型例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)&#123;</div><div class="line">  Object o = <span class="keyword">new</span> Object();</div><div class="line">  v.add</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p>
<h1 id="Android-中常见的内存泄漏汇总"><a href="#Android-中常见的内存泄漏汇总" class="headerlink" title="Android 中常见的内存泄漏汇总"></a>Android 中常见的内存泄漏汇总</h1><ul>
<li><p>集合类泄漏<br>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量（比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它），那么没有相应的删除机制，很可能导致集合锁占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况要多留一些心眼。</p>
</li>
<li><p>单例造成的内存泄漏<br>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">  <span class="keyword">private</span> Context context;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = context;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">      instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context，所以这个 Context 的生命周期的长短至关重要：</p>
<ol>
<li>如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</li>
<li>如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，友谊当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</li>
</ol>
<p>正确的方式应该改为下面这种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">  <span class="keyword">private</span> Context context;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = context.getApplicationContext();<span class="comment">//使用Application的context</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">      instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者这样写，连 Context 都不用传过来了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在你的Application中添加一个静态方法，getContext() 返回 Application 的 context</span></div><div class="line">···</div><div class="line">context = getApplicationContext();</div><div class="line">···</div><div class="line"><span class="comment">/** </span></div><div class="line">  * 获取全局的context </div><div class="line">  * <span class="doctag">@return</span> 返回全局context对象 </div><div class="line">  */</div><div class="line">  <span class="function">pulic <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">  <span class="keyword">private</span> Context context;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = MyApplication.getContext();<span class="comment">//使用Application的context</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">      instance = <span class="keyword">new</span> AppManager();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>匿名内部类/非静态内部类和异步线程<ul>
<li>非静态内部类创建静态实例造成的内存泄漏<br>有时候我们为了避免可能会在启动频繁的 Activity 中，为了避免重复创建相同的数据资源，可能会出现这种写法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">     setContentView(R.layout.activity_main);</div><div class="line">     <span class="keyword">if</span>(mManager == <span class="keyword">null</span>)&#123;</div><div class="line">       mManager = <span class="keyword">new</span> TestResource();</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//···</span></div><div class="line">   &#125;</div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span></span>&#123;</div><div class="line">   <span class="comment">//···</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法会造成内存泄漏，因为非静态内部类默认会有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或者将该内部类抽取出来封装成一个单例，如果需要使用 Context，请按照上面推荐的使用 Application 的 context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于 Application，Service，Activity 三者的 Context 的应用场景如下：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>Application</th>
<th style="text-align:right">Service</th>
<th style="text-align:right">Acativity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start an Activity</td>
<td>NO1</td>
<td style="text-align:right">NO1</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>Show a Dialog</td>
<td>NO</td>
<td style="text-align:right">NO</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>Layout Inflation</td>
<td>YES</td>
<td style="text-align:right">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>Start a Service</td>
<td>YES</td>
<td style="text-align:right">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>Bind to a Service</td>
<td>YES</td>
<td style="text-align:right">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>Send a Broadcast</td>
<td>YES</td>
<td style="text-align:right">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>Register BroadcastReceiver</td>
<td>YES</td>
<td style="text-align:right">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>Load Resource Values</td>
<td>YES</td>
<td style="text-align:right">YES</td>
<td style="text-align:right">YES</td>
</tr>
</tbody>
</table>
<p>  其中：NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建</p>
<ul>
<li>匿名内部类<br>Android 开发经常会继承实现 Activity/Fragment/View,此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄漏<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line">  ···</div><div class="line">  Runnable ref1 = <span class="keyword">new</span> MyRunnable();</div><div class="line">  Runnable ref2 = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>ref1 和 ref2 的区别是，ref2 使用了匿名内部类。我们来看看运行时这两个引用的内存：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/03/12/5c874d760fdfd.png" alt="1552370991(1).png" title="">
                </div>
                <div class="image-caption">1552370991(1).png</div>
            </figure><br>可以看到，ref1 没有什么特别的。但 ref2 这个匿名类的实现对象里面多了一个引用：<br>this$0 这个引用指向 MainActivity.this，也就是说当前的 MainActivity 实例会被 ref2 持有，如果将这个引用再传入一个异步线程，此线程和此 Activity 生命周期不一致的时候，就造成了 Activity 的泄漏。</p>
<ul>
<li>Handler 造成的内存泄漏<br>Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等 api 都借助 Handler 来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象被线程 MessageQueue 一直持有。由于 Handler 属于 TLS（Thread Local Storage）变量，生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正常释放。<br>举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="comment">// Post a message and delay its execution for 10 minutes.</span></div><div class="line">    mLeakyHandler.postDdelayed(<span class="keyword">new</span> Runnable &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">/** ... */</span>&#125;</div><div class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</div><div class="line">    <span class="comment">//Go back to the previous Activity.</span></div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在该 SampleActivity 中声明了一个延迟 10 分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish()掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。<br>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * Instances of static inner classes do not hold an implicit</div><div class="line">    * reference to their outer class</div><div class="line">    */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;SampleActivity&gt; mActivity;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(SampleActivity activity)</span></span>&#123;</div><div class="line">      mActivity = <span class="keyword">new</span> WeakReference&lt;SampleActivity&gt;(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">      SampleActivity activity = mActivity.get();</div><div class="line">      <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * Instances of anonymous classes do not hold an implicit</div><div class="line">    * reference to their outer class when they are "static"</div><div class="line">    */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable sRunnable = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-03-12T07:21:37.394Z" itemprop="dateUpdated">2019-03-12 15:21:37</time>
</span><br>


        
        Original Link：<a href="/2019/03/11/Android中的内存泄漏总结/" target="_blank" rel="external">https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/</a>
        
    </div>
    
    <footer>
        <a href="https://edward7zhang.github.io">
            <img src="/img/avatar.jpg" alt="EdwardZhang">
            EdwardZhang
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/">Interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/&title=《Android中的内存泄漏总结》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/&title=《Android中的内存泄漏总结》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android中的内存泄漏总结》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/03/10/Java深入源码/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Java深入源码</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'EdwardZhang777';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>EdwardZhang &copy; 2016 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/&title=《Android中的内存泄漏总结》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/&title=《Android中的内存泄漏总结》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android中的内存泄漏总结》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACoElEQVR42u3aQU7DQAwF0N7/0rBFgibf9rgF9LKqQprMSyWPsf14xMfHlyM/8/38s+Prldf3f2wceHh4eIOlXz+4+vj8miovWTMeHh7eNu9ZRL3+fComP7s+Wc+NBQ8PD++P8Kr3zF8WHh4e3v/jzcN6voXg4eHhvZfXu3WPPV/6Sq0FDw8PL+ZN0tl3fV7p7+Hh4eGNy6xJEE8Cd2+MoLoZ/HAfPDw8vAVetSw7SbvzoYT8ZUWlEDw8PLyjvGorqxfKr8usky3h2R3w8PDwXsPrlW6rhYx5wTdZbbS34OHh4Q14vXJANWT3SL1mGB4eHt5reNUFndoA8uurI1x4eHh4G7zkMb2CQq9gUR2rajbA8PDw8Aa8SbnhVCtrXhou1Frw8PDwDvGqzadJ4M5J1VT+ZqYMDw8P7xAvD7WT8sS87NtL8fHw8PD2eJMtIS/+Vpth8xkAPDw8vD3evGA6fynVF1HYqPDw8PCO8nq36LW15ol7ecPAw8PDW+MlQTkfF+i10HpJ9s1PgoeHh7fAmw8E5JtHr1xb/QHw8PDwXsPLg/jZkF0tcPRWiIeHh3eWlwf3yehAL1GeJPd4eHh427yzC83T6zz059tGOZnGw8PDK/LyxeXp8rygUJ19uPkWHh4e3hovH3WqpranmmS95hkeHh7eNi8vGeQt/2rRoTekNZosw8PDw2vxqrA89laT6cmBh4eHt837KB55CaBXeE2+VXjFeHh4eAu8yX5SfXCvMDH5Lh4eHt4erzow2vvrNbu32UQlZjw8PLw1XrXd1Ss6TDpTyegAHh4e3u/n5eF+Xp5I8D+cx8PDw/sFvDzc94ZNq/WEm2fh4eHhrfF6zafJmWqK3GuM4eHh4W3wev/wT8awEnCCfJw68PDw8FLeJ8cQxTqeyR1xAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '42';
            clearTimeout(titleTime);
        } else {
            document.title = 'Don‘t Panic！';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
