<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    
    
    
    <title>论：线程、多线程和线程池 | EdwardZhang&#39;s Blog | Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Java,Interview">
    <meta name="description" content="关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原 理、⑨ReentranLock源码，设计原理，整体过程 等等问题。   开启线程的三种方式？ 继承">
<meta name="keywords" content="Java,Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="论：线程、多线程和线程池">
<meta property="og:url" content="https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/index.html">
<meta property="og:site_name" content="EdwardZhang&#39;s Blog">
<meta property="og:description" content="关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原 理、⑨ReentranLock源码，设计原理，整体过程 等等问题。   开启线程的三种方式？ 继承">
<meta property="og:updated_time" content="2019-03-09T15:09:41.815Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="论：线程、多线程和线程池">
<meta name="twitter:description" content="关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原 理、⑨ReentranLock源码，设计原理，整体过程 等等问题。   开启线程的三种方式？ 继承">
    
        <link rel="alternate" type="application/atom+xml" title="EdwardZhang&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">EdwardZhang</h5>
          <a href="mailto:super7edwardzhang@gmail.com" title="super7edwardzhang@gmail.com" class="mail">super7edwardzhang@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Homepage
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/photo"  >
                <i class="icon icon-lg icon-photo"></i>
                Album
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Edward7Zhang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/3100298257/home?wvr=5" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.instagram.com/major7edward/" target="_blank" >
                <i class="icon icon-lg icon-instagram"></i>
                Instagram
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/link"  >
                <i class="icon icon-lg icon-link"></i>
                Friends&#39; Link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">论：线程、多线程和线程池</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">论：线程、多线程和线程池</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-03-06T04:07:14.000Z" itemprop="datePublished" class="page-time">
  2019-03-06
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#开启线程的三种方式？"><span class="post-toc-number">1.</span> <span class="post-toc-text">开启线程的三种方式？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#run-和-start-方法的区别"><span class="post-toc-number">2.</span> <span class="post-toc-text">run() 和 start() 方法的区别</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#如何控制某个方法允许并发访问的线程数？"><span class="post-toc-number">3.</span> <span class="post-toc-text">如何控制某个方法允许并发访问的线程数？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#在-Java-中-wait-和-sleep-方法的不同"><span class="post-toc-number">4.</span> <span class="post-toc-text">在 Java 中 wait 和 sleep 方法的不同</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#谈谈-wait-notfiy-方法的理解"><span class="post-toc-number">5.</span> <span class="post-toc-text">谈谈 wait()/notfiy() 方法的理解</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#什么导致线程阻塞？"><span class="post-toc-number">6.</span> <span class="post-toc-text">什么导致线程阻塞？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#线程如何关闭？"><span class="post-toc-number">7.</span> <span class="post-toc-text">线程如何关闭？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#讲一下-Java-中的同步的方法"><span class="post-toc-number">8.</span> <span class="post-toc-text">讲一下 Java 中的同步的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#synchronized-修饰同步代码块或方法"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">synchronized 修饰同步代码块或方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#volatile-修饰变量"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">volatile 修饰变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ReentrantLock-重入锁，它常用的方法有-ReentrantLock-：创建一个-ReentrantLock-实例"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用局部变量-ThreadLocal-实现线程同步"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">使用局部变量 ThreadLocal 实现线程同步</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用原子变量"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">使用原子变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用阻塞队列实现线程同步"><span class="post-toc-number">8.6.</span> <span class="post-toc-text">使用阻塞队列实现线程同步</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#如何保证线程安全？"><span class="post-toc-number">9.</span> <span class="post-toc-text">如何保证线程安全？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#static-synchronized-方法的多线程访问和作用"><span class="post-toc-number">10.</span> <span class="post-toc-text">static synchronized 方法的多线程访问和作用</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#面试中关于-synchronized-关键字的-5-连击"><span class="post-toc-number">11.</span> <span class="post-toc-text">面试中关于 synchronized 关键字的 5 连击</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#说一说自己对于-synchronized-关键字的了解"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">说一说自己对于 synchronized 关键字的了解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#说一说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#讲一下-synchronized-关键字的底层原理"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">讲一下 synchronized 关键字的底层原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#说一说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><span class="post-toc-number">11.4.</span> <span class="post-toc-text">说一说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#谈谈-synchronized-和-ReenTrantLock-的区别"><span class="post-toc-number">11.5.</span> <span class="post-toc-text">谈谈 synchronized 和 ReenTrantLock 的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#面试中关于线程池的-2-连击"><span class="post-toc-number">12.</span> <span class="post-toc-text">面试中关于线程池的 2 连击</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#讲一下-Java-内存模型"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">讲一下 Java 内存模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#说说-synchronized-关键字和-volatile-关键字的区别"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">说说 synchronized 关键字和 volatile 关键字的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#面试中关于线程池的-2-连击-1"><span class="post-toc-number">13.</span> <span class="post-toc-text">面试中关于线程池的 2 连击</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#为什么要用线程池"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">为什么要用线程池</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实现-Runnable-接口和-Callable-接口的区别"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">实现 Runnable 接口和 Callable 接口的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#执行-execute-方法和-submit-方法的区别是什么？"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">执行 execute()方法和 submit()方法的区别是什么？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何创建线程池"><span class="post-toc-number">13.4.</span> <span class="post-toc-text">如何创建线程池</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-论：线程、多线程和线程池"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">论：线程、多线程和线程池</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-03-06 12:07:14" datetime="2019-03-06T04:07:14.000Z"  itemprop="datePublished">2019-03-06</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原 理、⑨ReentranLock源码，设计原理，整体过程 等等问题。 </p>
</blockquote>
<h1 id="开启线程的三种方式？"><a href="#开启线程的三种方式？" class="headerlink" title="开启线程的三种方式？"></a>开启线程的三种方式？</h1><ul>
<li><p>继承 Thread 类，重写 run()方法，在 run()方法中编写要完成的任务 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread().start();</div></pre></td></tr></table></figure>
</li>
<li><p>实现 Runnable 接口，实现 run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</div></pre></td></tr></table></figure>
</li>
<li><p>实现 Callable 接口 MyCallable 类，实现 call()方法，使用 FutureTask 类来包装 Callable 对象，使用 FutureTask 对象作为 Thread 对象的 target 创建并启动线程；调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> MyCallable());</div><div class="line"><span class="keyword">new</span> Thread(ft).start();</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="run-和-start-方法的区别"><a href="#run-和-start-方法的区别" class="headerlink" title="run() 和 start() 方法的区别"></a>run() 和 start() 方法的区别</h1><p>run()方法只是线程的主方法体，和普通方法一样，不会创建新的线程。只有调用 start()方法，才会启动一个新的线程，新线程才会调用 run()方法，线程才会开始执行。</p>
<h1 id="如何控制某个方法允许并发访问的线程数？"><a href="#如何控制某个方法允许并发访问的线程数？" class="headerlink" title="如何控制某个方法允许并发访问的线程数？"></a>如何控制某个方法允许并发访问的线程数？</h1><p>创建 Semaphore 变量，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<p>当方法进入时，请求一个信号，如果信号被用完则等待，方法运行完，释放一个信号，释放的信号新的线程就可以使用。</p>
<h1 id="在-Java-中-wait-和-sleep-方法的不同"><a href="#在-Java-中-wait-和-sleep-方法的不同" class="headerlink" title="在 Java 中 wait 和 sleep 方法的不同"></a>在 Java 中 wait 和 sleep 方法的不同</h1><ul>
<li>wait()方法属于 Object 类，调用该方法时，线程会放弃对象锁，只有该对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
<li>sleep()方法属于 Thread 类，sleep 导致程序暂停执行指定的时间，让出 CPU，但他的监控状态依然保存着，当指定时间到了又会回到运行状态，sleep()方法中线程不会释放对象锁。<h1 id="谈谈-wait-notfiy-方法的理解"><a href="#谈谈-wait-notfiy-方法的理解" class="headerlink" title="谈谈 wait()/notfiy() 方法的理解"></a>谈谈 wait()/notfiy() 方法的理解</h1></li>
<li>notify()：唤醒在此对象监视器上等待的单个线程</li>
<li>notifyAll()：通知所有等待竞争该资源的线程</li>
<li>wait()：释放 obj 的锁，导致当前的线程等待，直接其他线程调用此对象的 notify()或 notifyAll();</li>
<li>当要调用 wait()或 notify()/notifyAll()方法时，一定要对竞争资源进行加锁，一般放到 synchronized(obj)代码中。当调用 obj.notify/notifyAll 后，调用线程依旧持有 obj 锁，因此等待线程虽被唤醒，但仍无法获得 obj 锁，知道调用线程退出 synchronized 块，释放 obj 锁后，其他等待线程才有机会获得锁继续执行。<h1 id="什么导致线程阻塞？"><a href="#什么导致线程阻塞？" class="headerlink" title="什么导致线程阻塞？"></a>什么导致线程阻塞？</h1></li>
<li>线程执行了 Thread.sleep(int millsecond)方法，放弃 CPU，睡眠一段时间，一段时间过后恢复执行；</li>
<li>线程执行一段同步代码，但无法获得相关的同步锁，只能进入阻塞状态，等到获取同步锁，才能恢复执行；</li>
<li>线程执行了一个对象的 wait()方法，直接进入阻塞态，等待其他线程执行 notify()/notifyAll()操作；</li>
<li>线程执行某些 IO 操作，因为等待相关资源而进入了阻塞态，如 System.in，但没有收到键盘的输入，则进入阻塞态。</li>
<li>线程礼让，Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程，但并不会使线程进入阻塞态，线程仍处于可执行态，随时可能再次分得 CPU 时间。线程自闭，join()方法，在当前线程调用另一个线程的 join()方法，则当前线程进入阻塞态，直到另一个线程运行结束，当前线程再由阻塞转为就绪态。</li>
<li>线程执行 suspend()使线程进入阻塞态，必须 resume()方法被调用，才能使线程重新进入可执行状态。<h1 id="线程如何关闭？"><a href="#线程如何关闭？" class="headerlink" title="线程如何关闭？"></a>线程如何关闭？</h1></li>
<li>使用标志位</li>
<li>使用 stop() 方法，但该方法就像关掉电脑电源一样，可能会发生预料不到的问题</li>
<li>使用中断 interrupt()<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="comment">//中断当前线程</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//判断当前线程是否被中断</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupt</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//清除当前线程的中断状态，并返回之前的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolen <span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>但调用 interrupt()方法只是传递中断请求消息，并不代表要立马停止目标线程</p>
<h1 id="讲一下-Java-中的同步的方法"><a href="#讲一下-Java-中的同步的方法" class="headerlink" title="讲一下 Java 中的同步的方法"></a>讲一下 Java 中的同步的方法</h1><p>之所以需要同步，因为在多线程并发控制，当多个线程同时操作一个可共享的资源时，如果没有采取同步机制，将会导致数据不准确，因此需要加入同步锁，确保在该线程没有完成操作前被其他线程调用，从而保证该变量的唯一性和准确性。</p>
<h2 id="synchronized-修饰同步代码块或方法"><a href="#synchronized-修饰同步代码块或方法" class="headerlink" title="synchronized 修饰同步代码块或方法"></a>synchronized 修饰同步代码块或方法</h2><p>由于 Java 的每个对象都有一个内置锁，用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需获得内置锁，否则就处于阻塞状态</p>
<h2 id="volatile-修饰变量"><a href="#volatile-修饰变量" class="headerlink" title="volatile 修饰变量"></a>volatile 修饰变量</h2><p>保证变量在线程间的可见性每次线程要访问 volatile 修饰的变量时都从主存中读取，而不是缓存中，这样每个线程访问到的变量都是一样的。且使用内存屏障。</p>
<h2 id="ReentrantLock-重入锁，它常用的方法有-ReentrantLock-：创建一个-ReentrantLock-实例"><a href="#ReentrantLock-重入锁，它常用的方法有-ReentrantLock-：创建一个-ReentrantLock-实例" class="headerlink" title="ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例"></a>ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例</h2><p>lock()获得锁 unlock()释放锁</p>
<h2 id="使用局部变量-ThreadLocal-实现线程同步"><a href="#使用局部变量-ThreadLocal-实现线程同步" class="headerlink" title="使用局部变量 ThreadLocal 实现线程同步"></a>使用局部变量 ThreadLocal 实现线程同步</h2><p>每个线程都会保存一份该变量的副本，副本之间相互独立，这样每个线程都可以随意修改自己的副本，而不影响其他线程。<br>常用方法：</p>
<ul>
<li>ThreadLocal()创建一个线程本地变量；</li>
<li>get()返回此线程就不懂当前线程副本变量；</li>
<li>initialValue()返回次线程局部变量的当前线程的出事值；</li>
<li>set(T value)将此线程变量的当前线程副本中的值设置为 value<h2 id="使用原子变量"><a href="#使用原子变量" class="headerlink" title="使用原子变量"></a>使用原子变量</h2>如 AtomicInteger<br>常用方法：</li>
<li>AtomicInteger(int value)创建个有给定初试值的 AtomicInteger 整数；</li>
<li>addAndGet(int data)以原子方式将给定值与当前值相加<h2 id="使用阻塞队列实现线程同步"><a href="#使用阻塞队列实现线程同步" class="headerlink" title="使用阻塞队列实现线程同步"></a>使用阻塞队列实现线程同步</h2>LinkedBlockingQueue<e></e></li>
</ul>
<h1 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h1><p><strong>线程安全性体现的三方法：</strong></p>
<ol>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作。JDK 中提供了很多 atomic 类，如 AtomicInteger\AtomicBoolean\AtomicLong，它们是通过 CAS 完成原子性。JDK 提供锁分为两种：synchronized 依赖 JVM 实现锁，该关键字对对象的作用范围内同一时刻只能有一个线程进行操作。另一种是 LOCK，是 JDK 提供的代码层面的锁，依赖 CPU 指令，代表性是 ReentrantLock。</li>
<li>可见性：一个线程对主内存的修改及时被其他线程看到。JVM 提供了 synchronized 和 volatile，volatile 的可见性是通过内存屏障和禁止重排序实现的，volatile 会在写操作时，在写操作后加一条 store 屏障指令，将本地内存中的共享变量刷新到主内存；会在读操作时，在读操作前加一条 load 指令，从内存中读取共享变量。</li>
<li>有序性：指令没有被编译器重排序。可通过 volatile、synchronized、Lock 保证有序性 4. </li>
</ol>
<h1 id="static-synchronized-方法的多线程访问和作用"><a href="#static-synchronized-方法的多线程访问和作用" class="headerlink" title="static synchronized 方法的多线程访问和作用"></a>static synchronized 方法的多线程访问和作用</h1><p>static synchronized 控制的是类的所有实例访问，不管 new 了多少对象，只有一份，所以对该类的所有对象都加了锁。限制多线程中该类的所有实例同时访问 JVM 中该类对应的代码。</p>
<h1 id="面试中关于-synchronized-关键字的-5-连击"><a href="#面试中关于-synchronized-关键字的-5-连击" class="headerlink" title="面试中关于 synchronized 关键字的 5 连击"></a>面试中关于 synchronized 关键字的 5 连击</h1><h2 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。<br>另外，在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙来完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h2 id="说一说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><a href="#说一说自己是怎么使用-synchronized-关键字，在项目中用到了吗？" class="headerlink" title="说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？"></a>说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h2><p>synchronized 关键字最主要的三种使用方式：</p>
<ul>
<li>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。也是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而 B 线程需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是给 Class 类上锁。这里再提醒一下：synchronized 关键字加到 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a)因为 JVM 中，字符串常量池具有缓冲功能。<br>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”<br>双重校验锁实现对象单例(线程安全)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></div><div class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="comment">//类对象加锁</span></div><div class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">          uniqueInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> uniqueInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分 为三步执行： </p>
<ol>
<li>为 uniqueInstance 分配内存空间 </li>
<li>初始化 uniqueInstance </li>
<li>将 uniqueInstance 指向分配的内存地址 </li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，但此时 uniqueInstance 还未被 初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h2 id="讲一下-synchronized-关键字的底层原理"><a href="#讲一下-synchronized-关键字的底层原理" class="headerlink" title="讲一下 synchronized 关键字的底层原理"></a>讲一下 synchronized 关键字的底层原理</h2><p>synchronized 关键字底层原理属于 JVM 层面。</p>
<ol>
<li>synchronized 同步语句块的情况 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</div><div class="line">    <span class="keyword">synchronized</span>（<span class="keyword">this</span>）&#123;</div><div class="line">      System.out.println(<span class="string">"synchronized 代码块"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的.class 文件，然后执行 <code>javap -c -s -v -l SynchronizedDemo.class</code>。<br>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程识图获取锁也是获取 monitor(monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因)的持有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1.相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<ol>
<li>synchronized 修饰方法的情况 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"synchronized 方法"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的却是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来 辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h2 id="说一说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><a href="#说一说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="说一说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"></a>说一说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h2><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减 少锁操作的开销。<br>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐 渐升级。<br>注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。<br>关于这几种优化的详细信息可以查看：synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和 ReenTrantLock 的对比</p>
<h2 id="谈谈-synchronized-和-ReenTrantLock-的区别"><a href="#谈谈-synchronized-和-ReenTrantLock-的区别" class="headerlink" title="谈谈 synchronized 和 ReenTrantLock 的区别"></a>谈谈 synchronized 和 ReenTrantLock 的区别</h2><p>① 两者都是可重入锁 两者都是可重入锁。<br>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时 这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死 锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。<br>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API<br>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多 优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。<br>③ ReenTrantLock 比 synchronized 增加了一些高级功能 相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁； ③可实现选择性通知（锁可以绑定多个条件）</p>
<ul>
<li>ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也 就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 </li>
<li>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等 待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过ReenTrantLock类的 ReentrantLock(boolean fair) 构造方法来制定是否是公平的。 </li>
<li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也 可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很 好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视 器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵 活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合 Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而 synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果 执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的 signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。<br>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</li>
<li>性能已不是选择标准<h1 id="面试中关于线程池的-2-连击"><a href="#面试中关于线程池的-2-连击" class="headerlink" title="面试中关于线程池的 2 连击"></a>面试中关于线程池的 2 连击</h1><h2 id="讲一下-Java-内存模型"><a href="#讲一下-Java-内存模型" class="headerlink" title="讲一下 Java 内存模型"></a>讲一下 Java 内存模型</h2></li>
</ul>
<h2 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h2><h1 id="面试中关于线程池的-2-连击-1"><a href="#面试中关于线程池的-2-连击-1" class="headerlink" title="面试中关于线程池的 2 连击"></a>面试中关于线程池的 2 连击</h1><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><h2 id="实现-Runnable-接口和-Callable-接口的区别"><a href="#实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="实现 Runnable 接口和 Callable 接口的区别"></a>实现 Runnable 接口和 Callable 接口的区别</h2><h2 id="执行-execute-方法和-submit-方法的区别是什么？"><a href="#执行-execute-方法和-submit-方法的区别是什么？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么？"></a>执行 execute()方法和 submit()方法的区别是什么？</h2><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-03-09T15:09:41.815Z" itemprop="dateUpdated">2019-03-09 23:09:41</time>
</span><br>


        
        Original Link：<a href="/2019/03/06/论：线程、多线程和线程池/" target="_blank" rel="external">https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/</a>
        
    </div>
    
    <footer>
        <a href="https://edward7zhang.github.io">
            <img src="/img/avatar.jpg" alt="EdwardZhang">
            EdwardZhang
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/">Interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/&title=《论：线程、多线程和线程池》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/&title=《论：线程、多线程和线程池》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《论：线程、多线程和线程池》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/03/10/Java深入源码/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java深入源码</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/03/04/Android端各类图片加载框架对比/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Android端各类图片加载框架对比</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'EdwardZhang777';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>EdwardZhang &copy; 2016 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/&title=《论：线程、多线程和线程池》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/&title=《论：线程、多线程和线程池》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《论：线程、多线程和线程池》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACv0lEQVR42u3aQW7jMAwF0Nz/0p1t0U7kT1JEs3heBW6s6KmAKJN8veLr69v1/c7v77x76vdf3418nsNr48LDw8MbTP3dhM6Y8zfP1POd86+c54yHh4e3zTtvxAm+d38yQhQ88PDw8D6Glx953z11PoIn88HDw8P7fF6yrefJiN44eHh4eJ/Dyw/N1U08DzPnRO16rgUPDw8v5uVVpM/5vFLfw8PDwxtX1ZNtd/uonQeD/zyFh4eHt8CrbsrzyDMPDPlxHw8PD2+PdwtZbbdKJtf7rdG64uHh4R3vV4v3Gy0C+RG8unB4eHh4G7xeIX/eONULD3nZ7KHKh4eHhzfm9doCqpv45PiehJaHdwU8PDy8S7z5a//d8lU+9VHpCw8PD+8qb5I2nRe0qmHmIaTh4eHhrfF6rVS3DsHVEQp7Ph4eHt4aLz8uTxalkFGOUyQPn/Hw8PDWeHnKIEnOJhv95HN+rMfDw8Pb4PWK93NSXh6rLmXzATw8PLyYV00QJBtxtag2+f7DAuHh4eEt8PJtt1cMq44wSYgUXgDw8PDwxrxqO1QeEvIwkx/WR2kIPDw8vDEvPzpXS1ZJ68B8IUY9ZXh4eHgDXq+B4BxUqlt5nj4upEvw8PDwFniTNEF+Z5J4rSaUH/4leHh4eGNeddBqGKiGkPNxPF/c5prh4eHhtSrpeQI3eeruwbp36MfDw8O7y+s1RSUp2qSgNRkzWko8PDy8BV5SgsoPr70Rquzkemi6wsPDwxvwvopXvmZ50qHXTNAMCXh4eHhjXnWrrU737uR6TQl4eHh4G7y7k5tv9JM5lKMfHh4e3oB3K5mbhJNm1qQXNvDw8PD+lNdbiCTJmzQH9NIieHh4eH/LyyeaLMfG0Xyl9QoPDw8v3nx7Q/eaDyblq6izDA8PD+8qbzJENST0YNXmg2srhIeHh/dznH99ZnOokkxj/QAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '42';
            clearTimeout(titleTime);
        } else {
            document.title = 'Don‘t Panic！';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
