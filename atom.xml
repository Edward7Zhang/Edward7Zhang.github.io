<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EdwardZhang&#39;s Blog</title>
  
  <subtitle>Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://edward7zhang.github.io/"/>
  <updated>2019-03-09T09:25:20.973Z</updated>
  <id>https://edward7zhang.github.io/</id>
  
  <author>
    <name>EdwardZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论：线程、多线程和线程池</title>
    <link href="https://edward7zhang.github.io/2019/03/06/%E8%AE%BA%EF%BC%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/</id>
    <published>2019-03-06T04:07:14.000Z</published>
    <updated>2019-03-09T09:25:20.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原 理、⑨ReentranLock源码，设计原理，整体过程 等等问题。 </p></blockquote><h1 id="开启线程的三种方式？"><a href="#开启线程的三种方式？" class="headerlink" title="开启线程的三种方式？"></a>开启线程的三种方式？</h1><ul><li><p>继承 Thread 类，重写 run()方法，在 run()方法中编写要完成的任务 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread().start();</div></pre></td></tr></table></figure></li><li><p>实现 Runnable 接口，实现 run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</div></pre></td></tr></table></figure></li><li><p>实现 Callable 接口 MyCallable 类，实现 call()方法，使用 FutureTask 类来包装 Callable 对象，使用 FutureTask 对象作为 Thread 对象的 target 创建并启动线程；调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> MyCallable());</div><div class="line"><span class="keyword">new</span> Thread(ft).start();</div></pre></td></tr></table></figure></li></ul><h1 id="run-和-start-方法的区别"><a href="#run-和-start-方法的区别" class="headerlink" title="run() 和 start() 方法的区别"></a>run() 和 start() 方法的区别</h1><p>run()方法只是线程的主方法体，和普通方法一样，不会创建新的线程。只有调用 start()方法，才会启动一个新的线程，新线程才会调用 run()方法，线程才会开始执行。</p><h1 id="如何控制某个方法允许并发访问的线程数？"><a href="#如何控制某个方法允许并发访问的线程数？" class="headerlink" title="如何控制某个方法允许并发访问的线程数？"></a>如何控制某个方法允许并发访问的线程数？</h1><p>创建 Semaphore 变量，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>当方法进入时，请求一个信号，如果信号被用完则等待，方法运行完，释放一个信号，释放的信号新的线程就可以使用。</p><h1 id="在-Java-中-wait-和-sleep-方法的不同"><a href="#在-Java-中-wait-和-sleep-方法的不同" class="headerlink" title="在 Java 中 wait 和 sleep 方法的不同"></a>在 Java 中 wait 和 sleep 方法的不同</h1><ul><li>wait()方法属于 Object 类，调用该方法时，线程会放弃对象锁，只有该对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li><li>sleep()方法属于 Thread 类，sleep 导致程序暂停执行指定的时间，让出 CPU，但他的监控状态依然保存着，当指定时间到了又会回到运行状态，sleep()方法中线程不会释放对象锁。<h1 id="谈谈-wait-notfiy-方法的理解"><a href="#谈谈-wait-notfiy-方法的理解" class="headerlink" title="谈谈 wait()/notfiy() 方法的理解"></a>谈谈 wait()/notfiy() 方法的理解</h1></li><li>notify()：唤醒在此对象监视器上等待的单个线程</li><li>notifyAll()：通知所有等待竞争该资源的线程</li><li>wait()：释放 obj 的锁，导致当前的线程等待，直接其他线程调用此对象的 notify()或 notifyAll();</li><li>当要调用 wait()或 notify()/notifyAll()方法时，一定要对竞争资源进行加锁，一般放到 synchronized(obj)代码中。当调用 obj.notify/notifyAll 后，调用线程依旧持有 obj 锁，因此等待线程虽被唤醒，但仍无法获得 obj 锁，知道调用线程退出 synchronized 块，释放 obj 锁后，其他等待线程才有机会获得锁继续执行。<h1 id="什么导致线程阻塞？"><a href="#什么导致线程阻塞？" class="headerlink" title="什么导致线程阻塞？"></a>什么导致线程阻塞？</h1></li><li>线程执行了 Thread.sleep(int millsecond)方法，放弃 CPU，睡眠一段时间，一段时间过后恢复执行；</li><li>线程执行一段同步代码，但无法获得相关的同步锁，只能进入阻塞状态，等到获取同步锁，才能恢复执行；</li><li>线程执行了一个对象的 wait()方法，直接进入阻塞态，等待其他线程执行 notify()/notifyAll()操作；</li><li>线程执行某些 IO 操作，因为等待相关资源而进入了阻塞态，如 System.in，但没有收到键盘的输入，则进入阻塞态。</li><li>线程礼让，Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程，但并不会使线程进入阻塞态，线程仍处于可执行态，随时可能再次分得 CPU 时间。线程自闭，join()方法，在当前线程调用另一个线程的 join()方法，则当前线程进入阻塞态，直到另一个线程运行结束，当前线程再由阻塞转为就绪态。</li><li>线程执行 suspend()使线程进入阻塞态，必须 resume()方法被调用，才能使线程重新进入可执行状态。<h1 id="线程如何关闭？"><a href="#线程如何关闭？" class="headerlink" title="线程如何关闭？"></a>线程如何关闭？</h1></li><li>使用标志位</li><li>使用 stop() 方法，但该方法就像关掉电脑电源一样，可能会发生预料不到的问题</li><li>使用中断 interrupt()<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="comment">//中断当前线程</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//判断当前线程是否被中断</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupt</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//清除当前线程的中断状态，并返回之前的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolen <span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>但调用 interrupt()方法只是传递中断请求消息，并不代表要立马停止目标线程</p><h1 id="讲一下-Java-中的同步的方法"><a href="#讲一下-Java-中的同步的方法" class="headerlink" title="讲一下 Java 中的同步的方法"></a>讲一下 Java 中的同步的方法</h1><p>之所以需要同步，因为在多线程并发控制，当多个线程同时操作一个可共享的资源时，如果没有采取同步机制，将会导致数据不准确，因此需要加入同步锁，确保在该线程没有完成操作前被其他线程调用，从而保证该变量的唯一性和准确性。</p><h2 id="synchronized-修饰同步代码块或方法"><a href="#synchronized-修饰同步代码块或方法" class="headerlink" title="synchronized 修饰同步代码块或方法"></a>synchronized 修饰同步代码块或方法</h2><p>由于 Java 的每个对象都有一个内置锁，用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需获得内置锁，否则就处于阻塞状态</p><h2 id="volatile-修饰变量"><a href="#volatile-修饰变量" class="headerlink" title="volatile 修饰变量"></a>volatile 修饰变量</h2><p>保证变量在线程间的可见性每次线程要访问 volatile 修饰的变量时都从主存中读取，而不是缓存中，这样每个线程访问到的变量都是一样的。且使用内存屏障。</p><h2 id="ReentrantLock-重入锁，它常用的方法有-ReentrantLock-：创建一个-ReentrantLock-实例"><a href="#ReentrantLock-重入锁，它常用的方法有-ReentrantLock-：创建一个-ReentrantLock-实例" class="headerlink" title="ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例"></a>ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例</h2><p>lock()获得锁 unlock()释放锁</p><h2 id="使用局部变量-ThreadLocal-实现线程同步"><a href="#使用局部变量-ThreadLocal-实现线程同步" class="headerlink" title="使用局部变量 ThreadLocal 实现线程同步"></a>使用局部变量 ThreadLocal 实现线程同步</h2><p>每个线程都会保存一份该变量的副本，副本之间相互独立，这样每个线程都可以随意修改自己的副本，而不影响其他线程。<br>常用方法：</p><ul><li>ThreadLocal()创建一个线程本地变量；</li><li>get()返回此线程就不懂当前线程副本变量；</li><li>initialValue()返回次线程局部变量的当前线程的出事值；</li><li>set(T value)将此线程变量的当前线程副本中的值设置为 value<h2 id="使用原子变量"><a href="#使用原子变量" class="headerlink" title="使用原子变量"></a>使用原子变量</h2>如 AtomicInteger<br>常用方法：</li><li>AtomicInteger(int value)创建个有给定初试值的 AtomicInteger 整数；</li><li>addAndGet(int data)以原子方式将给定值与当前值相加<h2 id="使用阻塞队列实现线程同步"><a href="#使用阻塞队列实现线程同步" class="headerlink" title="使用阻塞队列实现线程同步"></a>使用阻塞队列实现线程同步</h2>LinkedBlockingQueue<e></e></li></ul><h1 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h1><p><strong>线程安全性体现的三方法：</strong></p><ol><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作。JDK 中提供了很多 atomic 类，如 AtomicInteger\AtomicBoolean\AtomicLong，它们是通过 CAS 完成原子性。JDK 提供锁分为两种：synchronized 依赖 JVM 实现锁，该关键字对对象的作用范围内同一时刻只能有一个线程进行操作。另一种是 LOCK，是 JDK 提供的代码层面的锁，依赖 CPU 指令，代表性是 ReentrantLock。</li><li>可见性：一个线程对主内存的修改及时被其他线程看到。JVM 提供了 synchronized 和 volatile，volatile 的可见性是通过内存屏障和禁止重排序实现的，volatile 会在写操作时，在写操作后加一条 store 屏障指令，将本地内存中的共享变量刷新到主内存；会在读操作时，在读操作前加一条 load 指令，从内存中读取共享变量。</li><li>有序性：指令没有被编译器重排序。可通过 volatile、synchronized、Lock 保证有序性 4. </li></ol><h1 id="static-synchronized-方法的多线程访问和作用"><a href="#static-synchronized-方法的多线程访问和作用" class="headerlink" title="static synchronized 方法的多线程访问和作用"></a>static synchronized 方法的多线程访问和作用</h1><p>static synchronized 控制的是类的所有实例访问，不管 new 了多少对象，只有一份，所以对该类的所有对象都加了锁。限制多线程中该类的所有实例同时访问 JVM 中该类对应的代码。</p><h1 id="面试中关于-synchronized-关键字的-5-连击"><a href="#面试中关于-synchronized-关键字的-5-连击" class="headerlink" title="面试中关于 synchronized 关键字的 5 连击"></a>面试中关于 synchronized 关键字的 5 连击</h1><h2 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。<br>另外，在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙来完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h2 id="说一说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><a href="#说一说自己是怎么使用-synchronized-关键字，在项目中用到了吗？" class="headerlink" title="说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？"></a>说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h2><p>synchronized 关键字最主要的三种使用方式：</p><ul><li>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。也是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而 B 线程需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是给 Class 类上锁。这里再提醒一下：synchronized 关键字加到 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a)因为 JVM 中，字符串常量池具有缓冲功能。<br>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”<br>双重校验锁实现对象单例(线程安全)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></div><div class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="comment">//类对象加锁</span></div><div class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">          uniqueInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> uniqueInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分 为三步执行： </p><ol><li>为 uniqueInstance 分配内存空间 </li><li>初始化 uniqueInstance </li><li>将 uniqueInstance 指向分配的内存地址 </li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，但此时 uniqueInstance 还未被 初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h2 id="讲一下-synchronized-关键字的底层原理"><a href="#讲一下-synchronized-关键字的底层原理" class="headerlink" title="讲一下 synchronized 关键字的底层原理"></a>讲一下 synchronized 关键字的底层原理</h2><h2 id="说一说-JDK1-6-之后的-synchronized-关键字底层坐了哪些优化，可以详细介绍一下这些优化吗？"><a href="#说一说-JDK1-6-之后的-synchronized-关键字底层坐了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="说一说 JDK1.6 之后的 synchronized 关键字底层坐了哪些优化，可以详细介绍一下这些优化吗？"></a>说一说 JDK1.6 之后的 synchronized 关键字底层坐了哪些优化，可以详细介绍一下这些优化吗？</h2><h2 id="谈谈-synchronized-和-ReenTrantLock-的区别"><a href="#谈谈-synchronized-和-ReenTrantLock-的区别" class="headerlink" title="谈谈 synchronized 和 ReenTrantLock 的区别"></a>谈谈 synchronized 和 ReenTrantLock 的区别</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android端各类图片加载框架对比</title>
    <link href="https://edward7zhang.github.io/2019/03/04/Android%E7%AB%AF%E5%90%84%E7%B1%BB%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
    <id>https://edward7zhang.github.io/2019/03/04/Android端各类图片加载框架对比/</id>
    <published>2019-03-04T04:07:14.000Z</published>
    <updated>2019-03-04T01:13:13.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间的面试过程中被问到用过什么图片加载框架，我随口而出Glide，面试官继续追问下去是做过什么比较得出Glide比较高效吗？我就阻塞了…所以在此做一次复盘，针对Android端的各种加载框架进行对比</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ul><li>图片加载是Android开发中最最基础的功能，同时图片加载OOM也一直困扰着很多开发者，因此为了降低开发周期和难度，我们经常会选用一些图片加载的开源库。</li><li>老牌的有ImageLoader，UIL,  Volley，主流的有，Picasso，Glide，Fresco等等，选择一款好的图片加载裤就成了我们的首要问题。</li><li>接下来我们对比一下主流的三款 Picasso，Glide，Fresco框架的优缺点。</li></ul></blockquote><h1 id="Picasso，Glide，Fresco的前世今生"><a href="#Picasso，Glide，Fresco的前世今生" class="headerlink" title="Picasso，Glide，Fresco的前世今生"></a>Picasso，Glide，Fresco的前世今生</h1><h2 id="基本项对比"><a href="#基本项对比" class="headerlink" title="基本项对比"></a>基本项对比</h2><table><thead><tr><th>对比项</th><th>Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>地址</td><td><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fpicasso" target="_blank" rel="external">github.com/square/pica…</a></td><td><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fbumptech%2Fglide" target="_blank" rel="external">github.com/bumptech/gl…</a></td><td><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Ffresco" target="_blank" rel="external">github.com/facebook/fr…</a></td></tr><tr><td>发布时间</td><td>2013年5月</td><td>2014年9月</td><td>2015年5月</td></tr><tr><td>是否支持gif</td><td>false</td><td>true</td><td>true</td></tr><tr><td>是否支持webP</td><td>true</td><td>true</td><td>true</td></tr><tr><td>视频缩略图</td><td>false</td><td>true</td><td>true</td></tr><tr><td>大小</td><td>100k</td><td>500 KB</td><td>2～3M</td></tr><tr><td>加载速度</td><td>中</td><td>高</td><td>高</td></tr><tr><td>Disk+Men Cache</td><td>true</td><td>true</td><td>true</td></tr><tr><td>Easy of use</td><td>low</td><td>mediun</td><td>difficult</td></tr><tr><td>star</td><td>13160</td><td>14709</td><td>12444</td></tr><tr><td>开发者</td><td>Square主导</td><td>Google主导</td><td>Facebook主导</td></tr></tbody></table><h2 id="加载图片耗时及内存对比"><a href="#加载图片耗时及内存对比" class="headerlink" title="加载图片耗时及内存对比"></a>加载图片耗时及内存对比</h2><h3 id="without-animations"><a href="#without-animations" class="headerlink" title="without animations"></a>without animations</h3><table><thead><tr><th>对比项</th><th>Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>java heap／native heap/平均耗时（without animations）</td><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d4ab13d?imageslim" alt="Picasso加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d2b55e8?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d1496bb?imageslim) | ![Fresco加载无动画图片" title="">                </div>                <div class="image-caption">Picasso加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d2b55e8?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d1496bb?imageslim) | ![Fresco加载无动画图片</div>            </figure></td></tr><tr><td>max java heap</td><td>12.6MB</td><td>11.1MB</td><td>13.9MB</td></tr><tr><td>max native heap</td><td>43.8MB</td><td>43.8MB</td><td>43.8MB</td></tr><tr><td>avg wait time</td><td>241ms</td><td>34ms</td><td>44ms</td></tr></tbody></table><p>从上面的加载静态图片可以看出三大主流框架性能都不错，不过用数据说话整体而言Glide更胜一筹。</p><hr><h3 id="allow-animations"><a href="#allow-animations" class="headerlink" title="allow animations"></a>allow animations</h3><table><thead><tr><th>对比项</th><th>Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>java heap／native heap/平均耗时（allow animations）</td><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/5/14/1635f431b88df0e0?imageslim" alt="Picasso加载动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d57eddb?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f431b031be09?imageslim) | ![Fresco加载动画图片" title="">                </div>                <div class="image-caption">Picasso加载动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d57eddb?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f431b031be09?imageslim) | ![Fresco加载动画图片</div>            </figure></td></tr><tr><td>max java heap</td><td>6.8MB</td><td>74.8.1MB</td><td>36.1MB</td></tr><tr><td>max native heap</td><td>18.2MB</td><td>66.8MB</td><td>545.3MB</td></tr><tr><td>avg wait time</td><td>1707ms</td><td>33910ms</td><td>15142ms</td></tr></tbody></table><p><em>上面的数据我们可以忽略Picasso了，因为它根本不支持gif，那么Glide和Fresco可以看出Fresco的java heap基本保持较低平稳状态，而Glide的java heap基本为Fresco的一倍，所以OOM的风险也比fresco大一倍。</em><br><em>从时间上glide是有一定差距，不过fresco有两张图片没加载完成，所以时间不是完全可靠的数据</em><br><em>从native heap可以看出Fresco最高545MB，这个有点恐怖，下面我们看个知识点。</em></p><p><strong><em>知识点</em></strong></p><blockquote><ul><li>Java Heap是对于Java 虚拟机而说的，一般的大小上限是 16M 24M 48M 76M 具体视手机而定。</li><li>Native Heap是对于C/C++直接操纵的系统堆内存，所以它的上限一般是具体RAM的2/3左右。</li><li>所以对于2G的手机而言，Java Heap 大概76M，而Native Heap是760M左右，相差10倍。</li></ul></blockquote><p>所以Fresco也是存在一定风险的，因为native heap数据实在是太恐怖了。</p><h2 id="详细属性对比"><a href="#详细属性对比" class="headerlink" title="详细属性对比"></a>详细属性对比</h2><p>接下来只详细对比Fresco和Glide<br>Picasso从各方面都比这两个弱，这里就不浪费时间了。</p><table><thead><tr><th>对比项</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>配置</td><td><code>compile &#39;com.github.bumptech.glide:glide:XXX.XXX&#39;</code></td><td><code>compile &#39;com.facebook.fresco:fresco:XXX.XXX</code></td></tr><tr><td>初始化</td><td>直接使用</td><td><code>Fresco.initialize(this);</code></td></tr><tr><td>layout</td><td>普通ImageView</td><td>独有的SimpleDraweeView</td></tr><tr><td>圆角， 圆形</td><td>需要自己实现圆角，继承自BitmapTransformation操作bitmap对象实现</td><td>通过RoundingParams设置参数</td></tr><tr><td>缓存</td><td>Glide内存和磁盘缓存</td><td>三级缓存，分别是 Bitmap缓存，未解码图片缓存， 文件缓存。</td></tr><tr><td>缓存图像大小</td><td>Glide则会根据ImageView控件尺寸获得对应的大小的bitmap来展示，从而缓存也可以针对不同的对象：原始图像（source），结果图像(result)</td><td>缓存原始图像</td></tr><tr><td>加载策略</td><td>Glide只有占位图</td><td>先加载小尺寸图片，再加载大尺寸的</td></tr><tr><td>加载进度</td><td>false</td><td>true</td></tr></tbody></table><p>从上面的对比中可以看出来Fresco蛮强大的，不过使用起来相对Glide要复杂一点，而且需要自己的SimpleDraweeView，这一点在切换框架的时候最让人头疼了。而且Glide直接缓存相对大小的图片，节省空间的同时下场如果是同样大小的图片就不要再次请求，直接可以使用。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p><strong>Glide</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">  mavenCentral()</div><div class="line">  google()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.github.bumptech.glide:glide:4.9.0'</span></div><div class="line">  annotationProcessor <span class="string">'com.github.bumptech.glide:compiler:4.9.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Fresco</strong><br>要使用完整的Fresco功能就要导入如下的依赖<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.facebook.fresco:fresco:1.12.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="bitmap操作"><a href="#bitmap操作" class="headerlink" title="bitmap操作"></a>bitmap操作</h3><p><strong>Glide</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bitmap myBitmap = Glide.with(上下文)  </div><div class="line">    .load(url)  </div><div class="line">    .asBitmap() //必须    </div><div class="line">    .get()</div></pre></td></tr></table></figure><p><strong>Fresco</strong><br>Fresco要获取bitmap更加复杂， 而且使用起来也并不是那么顺畅。首先，Fresco为了更好地管理bitmap 对象（bitmap对象申请和释放会引起频繁的GC操作，从而引起界面卡顿）， 引入了可关闭的引用（CloseableReference）, 持有者在离开作用域的时候需要关闭该引用，而我们要获取的bitmap 对象就是可关闭的引用。也就是说，我们不能像上面Glide那样把bitmap 对象取出来传递给其它地方使用， 只能在Fresco提供的作用域范围内使用。<br>实际项目中会获取缓冲的文件对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//同样在DataSubscriber中获取</div><div class="line">FileBinaryResource resource = (FileBinaryResource) Fresco.getImagePipelineFactory().getMainFileCache().getResource(new SimpleCacheKey(url));</div><div class="line">if (resource != null &amp;&amp; resource.getFile() != null) &#123;           </div><div class="line">    setImage(ImageSource.uri(Uri.fromFile(resource.getFile())));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>Glide</strong></p><blockquote><ul><li>多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video）</li><li>生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）</li><li>高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）</li><li>高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）</li></ul></blockquote><p><strong>Fresco</strong></p><blockquote><ul><li>最大的优势在于5.0以下(最低2.3)的bitmap加载。在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem区)</li><li>大大减少OOM（在更底层的Native层对OOM进行处理，图片将不再占用App的内存）</li><li>适用于需要高性能加载大量图片的场景</li></ul></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>Glide</strong></p><blockquote><p>-没有文件缓存 -java heap比Fresco高</p></blockquote><p><strong>Fresco</strong></p><blockquote><ul><li>包较大（2~3M）</li><li>用法复杂</li><li>底层涉及c++领域，阅读源码深入学习难度大</li></ul></blockquote><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Fresco虽然很强大，但是包很大，依赖很多，使用复杂，而且还要在布局使用SimpleDraweeView控件加载图片。相对而言Glide会轻好多，上手快，使用简单，配置方便，而且从加载速度和性能方面不相上下。对于一般的APP来说Glide是一个不错的选择，如果是专业的图片APP那么Fresco还是必要的。</p><p><em><a href="https://juejin.im/entry/5af9aabf51882542bd69d0c0" target="_blank" rel="external">文章部分转载于</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前段时间的面试过程中被问到用过什么图片加载框架，我随口而出Glide，面试官继续追问下去是做过什么比较得出Glide比较高效吗？我就阻塞了…所以在此做一次复盘，针对Android端的各种加载框架进行对比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2.0 使用教程（与常见网络请求库对比）</title>
    <link href="https://edward7zhang.github.io/2019/03/03/Retrofit2.0%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
    <id>https://edward7zhang.github.io/2019/03/03/Retrofit2.0 使用教程（与常见网络请求库对比）/</id>
    <published>2019-03-03T04:07:14.000Z</published>
    <updated>2019-03-03T09:11:48.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在<strong>Android</strong>开发中，网络请求十分常用</li><li>当下的网络请求加载库中，<strong>Retrofit</strong>则是当下hottest的一个网络请求库</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-a3109ad0446b0540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>特别注意：</p><ul><li>准确来说，<strong>Retrofit是一个 RESTful 的 HTTP 网络请求框架的封装</strong></li><li>原因：网络请求的工作本质上是<code>OkHttp</code>完成的，而<code>Retrofit</code>仅负责网络请求接口的封装<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-b5194f1d16673589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>App应用程序通过 Retrofit 请求网络，实际上是使用Retrofit接口层封装请求参数、Header、Url等信息，之后由OkHttp完成后续的请求操作</li><li>在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析</li></ul><h1 id="与其他开源库对比"><a href="#与其他开源库对比" class="headerlink" title="与其他开源库对比"></a>与其他开源库对比</h1><p>除了 Retrofit，如今 Android 中主流的网络请求框架有：</p><ul><li>Android-Async-Http</li><li>Volly</li><li>OkHttp<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-3089d23889f04d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="介绍" title="">                </div>                <div class="image-caption">介绍</div>            </figure></li></ul><p>几种网络请求库之间的区别对比<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-58819416dfd2767a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>附：各个主流网络请求库的 Github 地址</p><ul><li><a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">Android-Async-Http</a></li><li><a href="https://github.com/stormzhang/AndroidVolley" target="_blank" rel="external">Volley</a></li><li><a href="https://github.com/square/okhttp" target="_blank" rel="external">OkHttp</a></li><li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a></li></ul><h1 id="Retrofit使用介绍"><a href="#Retrofit使用介绍" class="headerlink" title="Retrofit使用介绍"></a>Retrofit使用介绍</h1><p>使用Retrofit的步骤共有7个：</p><pre><code>步骤1：添加 Retrofit 库的依赖步骤2：创建 接受服务器返回数据 的类步骤3：创建 用于描述网络请求 的接口步骤4：创建 Retrofit 实例步骤5：创建 网络请求接口实例 并 配置网络请求参数步骤6：发送网络请求（异步\同步）    &gt; 封装了 数据转换、线程切换的操作步骤7：处理服务器返回的数据</code></pre><p>接下来我们将这些步骤进行分解</p><h2 id="步骤1：添加-Retrofit-库的依赖"><a href="#步骤1：添加-Retrofit-库的依赖" class="headerlink" title="步骤1：添加 Retrofit 库的依赖"></a>步骤1：添加 Retrofit 库的依赖</h2><h3 id="1-在Gradle加入Retrofit库的依赖"><a href="#1-在Gradle加入Retrofit库的依赖" class="headerlink" title="1.在Gradle加入Retrofit库的依赖"></a>1.在<code>Gradle</code>加入<code>Retrofit</code>库的依赖</h3><blockquote><p>由于<code>Retrofit</code>是基于<code>OkHttp</code>，所以还需要添加<code>OkHttp</code>库依赖</p></blockquote><p><em>build.gradle</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123; </div><div class="line">  compile&apos;com.squareup.retrofit2:retrofit:2.0.2&apos;  </div><div class="line">  // Retrofit库 </div><div class="line">  compile &apos;com.squareup.okhttp3:okhttp:3.1.2&apos;  </div><div class="line">  // Okhttp库 </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-添加-网络权限"><a href="#2-添加-网络权限" class="headerlink" title="2.添加 网络权限"></a>2.添加 网络权限</h3><p><em>AndroidManifest.xml</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</div></pre></td></tr></table></figure><h2 id="步骤2：创建-接受服务器返回数据-的类"><a href="#步骤2：创建-接受服务器返回数据-的类" class="headerlink" title="步骤2：创建 接受服务器返回数据 的类"></a>步骤2：创建 接受服务器返回数据 的类</h2><p><em>Reception.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reception</span></span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">//根据返回数据的格式和数据解析方式（Json、XML等）定义</span></div><div class="line">  <span class="comment">//下面会在实例中进行说明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="步骤3：创建-用于描述网络请求-的接口"><a href="#步骤3：创建-用于描述网络请求-的接口" class="headerlink" title="步骤3：创建 用于描述网络请求 的接口"></a>步骤3：创建 用于描述网络请求 的接口</h2><ul><li>Retrofit将Http请求抽象成Java接口：采用<strong>注解</strong>描述网络请求的参数 和 配置网络请求参数</li></ul><blockquote><p>1.用 动态代理 动态 将该接口的注解“翻译”成一个Http请求，最后再执行Http请求<br>2.注：接口中的每个方法的参数都需要使用注解标注，否则会报错</p></blockquote><p>_GetRequest<em>Interface.interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span></span>&#123;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>)</div><div class="line">    <span class="function">Call&lt;Translation&gt; <span class="title">getCall</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//@GET注解的作用：采用Get方法发送网络请求</span></div><div class="line">    <span class="comment">//getCall() = 接受网络请求数据的方法</span></div><div class="line">    <span class="comment">//其中返回类型为Call&lt;*&gt;,*是接收数据的类（即上面定义的Translation类）</span></div><div class="line">    <span class="comment">//如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面详细介绍Retrofit网络请求接口 的注解类型<br><strong>注解类型</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-ee747d1e331ed5a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注解说明</strong></p><h3 id="第一类：网络请求方法"><a href="#第一类：网络请求方法" class="headerlink" title="第一类：网络请求方法"></a>第一类：网络请求方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-e97379b8e0942459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="详细说明："><a href="#详细说明：" class="headerlink" title="详细说明："></a>详细说明：</h3><h4 id="a-GET、-POST、-PUT、-DELETE、-HEAD"><a href="#a-GET、-POST、-PUT、-DELETE、-HEAD" class="headerlink" title="a.@GET、@POST、@PUT、@DELETE、@HEAD"></a>a.@GET、@POST、@PUT、@DELETE、@HEAD</h4><p>以上方法分别对应HTTP中的网络请求方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123; </div><div class="line">  <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>) </div><div class="line">  <span class="function">Call&lt;Translation&gt; <span class="title">getCall</span><span class="params">()</span></span>; </div><div class="line">  <span class="comment">// @GET注解的作用:采用Get方法发送网络请求  </span></div><div class="line">  <span class="comment">// getCall() = 接收网络请求数据的方法  </span></div><div class="line">  <span class="comment">// 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类） </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>此处特意说明URL的组成：Retrofit把 网络请求的URL分成了两部分设置：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第1部分：在网络请求接口的注解设置</span></div><div class="line"> <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>)</div><div class="line"><span class="function">Call&lt;Translation&gt;  <span class="title">getCall</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 第2部分：在创建Retrofit实例时通过.baseUrl()设置</span></div><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                .baseUrl(<span class="string">"http://fanyi.youdao.com/"</span>) <span class="comment">//设置网络请求的Url地址</span></div><div class="line">                .addConverterFactory(GsonConverterFactory.create()) <span class="comment">//设置数据解析器</span></div><div class="line">                .build();</div><div class="line"></div><div class="line"><span class="comment">// 从上面看出：一个请求的URL可以通过 替换块 和 请求方法的参数 来进行动态的URL更新。</span></div><div class="line"><span class="comment">// 替换块是由 被&#123;&#125;包裹起来的字符串构成</span></div><div class="line"><span class="comment">// 即：Retrofit支持动态改变网络请求根目录</span></div></pre></td></tr></table></figure></p><ul><li>网络请求的完整 Url = 在创建 Retrofit 实例时通过.baseUrl() 设置 + 网络请求接口的注解设置（下面称“path”）</li><li>具体整合的规则如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-3dc42017038302d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>建议采用第三种方式来配置，并尽量使用同一种路径形式。</p></blockquote></li></ul><h4 id="b-HTTP"><a href="#b-HTTP" class="headerlink" title="b.@HTTP"></a>b.@HTTP</h4><ul><li>作用：替换@GET、@POST、@PUT、@DELETE、@HEAD注解的作用 及 更多功能拓展</li><li>具体使用：通过属性 method、path、hasBody进行设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * method：网络请求的方法（区分大小写）</div><div class="line">     * path：网络请求地址路径</div><div class="line">     * hasBody：是否有请求体</div><div class="line">     */</div><div class="line">    <span class="meta">@HTTP</span>(method = <span class="string">"GET"</span>, path = <span class="string">"blog/&#123;id&#125;"</span>, hasBody = <span class="keyword">false</span>)</div><div class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getCall</span><span class="params">(@Path(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;</div><div class="line">    <span class="comment">// &#123;id&#125; 表示是一个变量</span></div><div class="line">    <span class="comment">// method 的值 retrofit 不会做处理，所以要自行保证准确</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="第二类：标记"><a href="#第二类：标记" class="headerlink" title="第二类：标记"></a>第二类：标记</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-a6f1fc997c23a2e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="a-FormUrlEncoded"><a href="#a-FormUrlEncoded" class="headerlink" title="a.@FormUrlEncoded"></a>a.@FormUrlEncoded</h4><ul><li>作用：表示发送form-encoded 的数据<blockquote><p>每个键值对需要用 @Filed 来注解键名，随后的对象需要提供值。</p></blockquote></li></ul><h4 id="b-Multipart"><a href="#b-Multipart" class="headerlink" title="b.@Multipart"></a>b.@Multipart</h4><ul><li>作用：表示发送form-encoded 的数据（适用于 有文件 上传的场景）<blockquote><p>每个键值对需要用 @Part 来注解键名，随后的对象需要提供值。</p></blockquote></li></ul><p>具体使用如下：<br>_GetRequest<em>Interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）</div><div class="line">         * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@FormUrlEncoded</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded1</span><span class="params">(@Field(<span class="string">"username"</span>)</span> String name, @<span class="title">Field</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * &#123;<span class="doctag">@link</span> Part&#125; 后面支持三种类型，&#123;<span class="doctag">@link</span> RequestBody&#125;、&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 、任意类型</div><div class="line">         * 除 &#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 以外，其它类型都必须带上表单字段(&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 中已经包含了表单字段的信息)，</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@Multipart</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFileUpload1</span><span class="params">(@Part(<span class="string">"name"</span>)</span> RequestBody name, @<span class="title">Part</span><span class="params">(<span class="string">"age"</span>)</span> RequestBody age, @Part MultipartBody.Part file)</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体使用</span></div><div class="line">       GetRequest_Interface service = retrofit.create(GetRequest_Interface.class);</div><div class="line">        <span class="comment">// @FormUrlEncoded </span></div><div class="line">        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(<span class="string">"Carson"</span>, <span class="number">24</span>);</div><div class="line"></div><div class="line">        <span class="comment">//  @Multipart</span></div><div class="line">        RequestBody name = RequestBody.create(textType, <span class="string">"Carson"</span>);</div><div class="line">        RequestBody age = RequestBody.create(textType, <span class="string">"24"</span>);</div><div class="line"></div><div class="line">        MultipartBody.Part filePart = MultipartBody.Part.createFormData(<span class="string">"file"</span>, <span class="string">"test.txt"</span>, file);</div><div class="line">        Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);</div></pre></td></tr></table></figure><h3 id="第三类：网络请求参数"><a href="#第三类：网络请求参数" class="headerlink" title="第三类：网络请求参数"></a>第三类：网络请求参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-c547f2344eef630b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>详细说明</strong></p><h4 id="a-Header-amp-Headers"><a href="#a-Header-amp-Headers" class="headerlink" title="a.@Header &amp; @Headers"></a>a.@Header &amp; @Headers</h4><ul><li>作用：添加请求头 &amp; 添加不固定的请求头</li><li>具体使用如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @Header</span></div><div class="line"><span class="meta">@GET</span>(<span class="string">"user"</span>)</div><div class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Header(<span class="string">"Authorization"</span>)</span> String authorization)</span></div><div class="line"></div><div class="line"><span class="comment">// @Headers</span></div><div class="line">@<span class="title">Headers</span><span class="params">(<span class="string">"Authorization: authorization"</span>)</span></div><div class="line">@<span class="title">GET</span><span class="params">(<span class="string">"user"</span>)</span></div><div class="line">Call&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></div><div class="line"></div><div class="line"><span class="comment">// 以上的效果是一致的。</span></div><div class="line"><span class="comment">// 区别在于使用场景和使用方式</span></div><div class="line"><span class="comment">// 1. 使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头</span></div><div class="line"><span class="comment">// 2. 使用方式：@Header作用于方法的参数；@Headers作用于方法</span></div></pre></td></tr></table></figure></li></ul><h4 id="b-Body"><a href="#b-Body" class="headerlink" title="b.@Body"></a>b.@Body</h4><ul><li>作用：以<code>post</code>方式 传递 自定义数据类型给服务器</li><li>特别注意：如果提交的是一个Map，那么作用相当于<code>@Field</code><blockquote><p>不过 Map 要经过<code>FormBody.Builder</code>类处理成为符合OkHttp格式的表单，如：</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FormBody.Builder builder = <span class="keyword">new</span> ForBody.Builder();</div><div class="line">builder.add(<span class="string">"key"</span>,<span class="string">"value"</span>);</div></pre></td></tr></table></figure><h4 id="c-Field-amp-FieldMap"><a href="#c-Field-amp-FieldMap" class="headerlink" title="c.@Field &amp; @FieldMap"></a>c.@Field &amp; @FieldMap</h4><ul><li>作用：发送 Post 请求 时提交请求的表单字段</li><li>具体使用：与 @FormUrlEncoded 注解配合使用<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）</div><div class="line">         * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@FormUrlEncoded</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded1</span><span class="params">(@Field(<span class="string">"username"</span>)</span> String name, @<span class="title">Field</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">         * Map的key作为表单的键</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@FormUrlEncoded</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded2</span><span class="params">(@FieldMap Map&lt;String, Object&gt; map)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体使用</span></div><div class="line">         <span class="comment">// @Field</span></div><div class="line">        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(<span class="string">"Carson"</span>, <span class="number">24</span>);</div><div class="line"></div><div class="line">        <span class="comment">// @FieldMap</span></div><div class="line">        <span class="comment">// 实现的效果与上面相同，但要传入Map</span></div><div class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"username"</span>, <span class="string">"Carson"</span>);</div><div class="line">        map.put(<span class="string">"age"</span>, <span class="number">24</span>);</div><div class="line">        Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map);</div></pre></td></tr></table></figure></li></ul><h4 id="d-Part-amp-PartMap"><a href="#d-Part-amp-PartMap" class="headerlink" title="d.@Part &amp; @PartMap"></a>d.@Part &amp; @PartMap</h4><h4 id="e-Query-amp-QueryMap"><a href="#e-Query-amp-QueryMap" class="headerlink" title="e.@Query &amp; @QueryMap"></a>e.@Query &amp; @QueryMap</h4><h4 id="f-Path"><a href="#f-Path" class="headerlink" title="f.@Path"></a>f.@Path</h4><h4 id="g-Url"><a href="#g-Url" class="headerlink" title="g.@Url"></a>g.@Url</h4><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-f9f8994497df7fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="步骤4：创建-Retrofit-实例"><a href="#步骤4：创建-Retrofit-实例" class="headerlink" title="步骤4：创建 Retrofit 实例"></a>步骤4：创建 Retrofit 实例</h2><h2 id="步骤5：创建-网络请求接口实例-并-配置网络请求参数"><a href="#步骤5：创建-网络请求接口实例-并-配置网络请求参数" class="headerlink" title="步骤5：创建 网络请求接口实例 并 配置网络请求参数"></a>步骤5：创建 网络请求接口实例 并 配置网络请求参数</h2><h2 id="步骤6：发送网络请求（异步-同步）"><a href="#步骤6：发送网络请求（异步-同步）" class="headerlink" title="步骤6：发送网络请求（异步\同步）"></a>步骤6：发送网络请求（异步\同步）</h2><h2 id="步骤7：处理服务器返回的数据"><a href="#步骤7：处理服务器返回的数据" class="headerlink" title="步骤7：处理服务器返回的数据"></a>步骤7：处理服务器返回的数据</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;Android&lt;/strong&gt;开发中，网络请求十分常用&lt;/li&gt;
&lt;li&gt;当下的网络请求加载库中，&lt;stro
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio编译过程</title>
    <link href="https://edward7zhang.github.io/2019/03/02/AndroidStudio%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://edward7zhang.github.io/2019/03/02/AndroidStudio编译过程/</id>
    <published>2019-03-02T04:07:14.000Z</published>
    <updated>2019-03-04T07:35:29.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在此记录一下AndroidStudio编译过程</p></blockquote><p>其中使用到的编译工具：<br>aapt、aidl、Java Compiler、dex、zipalign</p><p>主要步骤描述：</p><pre><code>1.通过aapt打包res资源文件，生成R.java、resource.arsc和res文件（二进制&amp;非二进制如res/raw和pic保持原样）2.处理.aidl文件，生成对应的Java接口文件3.通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件4.通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex5.通过apkbuilder工具，将aapt生成的resource.arsc和res文件、assets文件和classes.dex一起打包生成apk6.通过Jarsigner工具，对上面的apk进行debug或release签名7.通过zipalign工具，将签名后的apk进行对齐处理</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/1420866-79b675761018ff57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/536/format/webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/1420866-1402494a5225964e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/993/format/webp" alt="link" title="">                </div>                <div class="image-caption">link</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在此记录一下AndroidStudio编译过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中使用到的编译工具：&lt;br&gt;aapt、aidl、Java Compiler、dex、zipalign&lt;/p&gt;
&lt;p&gt;主要步骤描述：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记一道简单的Java面试题【转载自 知乎——方志宏】</title>
    <link href="https://edward7zhang.github.io/2019/03/01/%E8%AE%B0%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://edward7zhang.github.io/2019/03/01/记一道简单的Java面试题/</id>
    <published>2019-03-01T11:07:14.000Z</published>
    <updated>2019-03-01T08:35:17.911Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是历史上最简单的一道java面试题了。</p><p>题目很简单，完成代码，判断一个整数是否是奇数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span></span></div></pre></td></tr></table></figure><p>相信相当数量的人都已经在准备吐槽了，只要看过《编程珠玑》的人都知道这道题的答案和其中极为简单的道理。不过别着急骂街，不管你信不信，这道笔试题我拿到的答案好多都长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"是奇数"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"是偶数"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后编译一下，发现错误了，挠挠头，顶多改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好吧，我承认我在筛选简历的能力可能有一些问题，不过不管你信不信，好多大厂工作了几年的程序员，都会写出如上风格的代码。</p><p>于是我继续进行引导：</p><p>我：“这个函数的定义要求返回一个什么类型的值？”</p><p>候选人看了看题干：“布尔类型。”</p><p>我：“那么，你if后面的括号里面的表达式的值是一个什么类型的？”</p><p>引导到这一步的时候，依然有高达两成的候选人选择了放弃，表示他们不知道。好吧，我真的不知道你们来面试这个职位的信心何在。不过大部分人想了想，还会回答出正确答案：</p><p>候选人：“也是布尔类型。”</p><p>我：“然后呢？”</p><p>有少量候选人虽然没说出来，但是我能看出来他们觉得这只是一个巧合，并不知道怎么进行下一步。不过，大多数人想了想之后，还是会优化成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>终于过了第一关了，进行第二关的引导：</p><p>我：“那我传进来一个-1呢？”</p><p>将近一半的人在想了想之后会嘴硬地表示他们从小被教导只有自然数才有奇数偶数之分，负数没有奇偶这一说。剩余的人接受了这个设定，想了一会儿，改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span> || i % <span class="number">2</span> == -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>并且在提示之后优化成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好吧，这是迄今为止第一个能通过编译且完全满足了需求的代码实现了。说实话，一开始就写成这样的人，如果没有其他什么明显的缺点的话，我这里基本就能通过了。我承认我的要求比较低，但是来面试的人能直接写出这样的真的不太多，粗略地估计的话，大概占一到两成吧。</p><p>但是这里还没完呢，还有最重要的第三关呢：</p><p>我：“有更好的办法吗？”</p><p>候选人：“？”</p><p>我：“我觉得取模操作比较慢，有更快的解决方案吗？”</p><p>除了少数人能自己想想就想出来了之外，绝大部分（毫不夸张）候选人表示没有或者不知道，于是进行下一步提示：</p><p>我：“奇数和偶数转换成二进制有什么区别？”</p><p>相当一部分候选人表示自己不懂什么叫二进制和位运算，有的还表示java不是c语言，不用研究这些，就跟很多评论会吐槽我在装逼一样。少部分候选人想了想，会怯怯地回答。</p><p>候选人：“奇数最后一位是1，偶数最后一位是0。”</p><p>我：“然后呢？”</p><p>这里很奇怪的点是，大部分能聊到这里来的候选人会想起来移位操作，我真的不知道是为什么，虽然这道题确实可以有这种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i &gt;&gt; <span class="number">1</span> &lt;&lt; <span class="number">1</span> != i;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是这根本不是重点好吧！！！</p><p>总之，无论如何，能在第三关的各种引导之后，能写出下面这个结果来的人，真的不多。能一开始没有任何引导的就写出来的人，至今只见过两个，一个我去哪儿都带着，一个拒了我的offer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i &amp; <span class="number">1</span>) == <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>别以为这就完了！终极boss来了：</p><p>我：“这样是不是比上面取模运算要快？”</p><p>候选人：“那当然了，位运算肯定快啊。”</p><p>我：“但是我们实际代码测试过，发现上面的按位与操作和取模操作，实际运行的时间是差不多的，为什么呢？”</p><p>候选人心里mmp：“闹了半天你这是在逗我玩啊？？？”</p><p>然而真正能回答出原因来的人，面试过程中我没见过，可能是大牛都看不上我所在的公司吧。只有在某公司的时候，一个同事想了想，给出了我正确答案：“编译器会将对2的指数的取模操作，优化成位运算操作。”</p><p>难道是我经历的公司都太low了么……</p><p>作者：方志宏<br>链接：<a href="https://zhuanlan.zhihu.com/p/57859872" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/57859872</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这可能是历史上最简单的一道java面试题了。&lt;/p&gt;
&lt;p&gt;题目很简单，完成代码，判断一个整数是否是奇数：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;l
      
    
    </summary>
    
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance【一面总结】</title>
    <link href="https://edward7zhang.github.io/2019/02/18/ByteDance%E3%80%90%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93%E3%80%91/"/>
    <id>https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/</id>
    <published>2019-02-18T11:07:14.000Z</published>
    <updated>2019-03-02T14:28:47.932Z</updated>
    
    <content type="html"><![CDATA[<p>大概在数天前投递了字节跳动-抖音方向的实习生岗位<br>昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题）</p><h2 id="1-Java中的引用类型有没有什么了解？"><a href="#1-Java中的引用类型有没有什么了解？" class="headerlink" title="1.Java中的引用类型有没有什么了解？"></a>1.Java中的引用类型有没有什么了解？</h2><p>Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。</p><pre><code>StrongReference（强引用）SoftReference（软引用）WeakReference（弱引用）PhantomReference（虚引用）</code></pre><h3 id="引用类型对比"><a href="#引用类型对比" class="headerlink" title="引用类型对比"></a>引用类型对比</h3><table><thead><tr><th>序号</th><th>引用类型</th><th>取得目标对象方式</th><th>垃圾回收条件</th><th>是否可能内存泄漏</th></tr></thead><tbody><tr><td>1</td><td>强引用</td><td>直接调用</td><td>不回收</td><td>可能</td></tr><tr><td>2</td><td>软引用</td><td>通过 get()方法</td><td>视内存情况回收</td><td>不可能</td></tr><tr><td>3</td><td>弱引用</td><td>通过 get()方法</td><td>永远回收</td><td>不可能</td></tr><tr><td>4</td><td>虚引用</td><td>无法取得</td><td>不回收</td><td>可能</td></tr></tbody></table><h4 id="1-StrongReference（强引用）"><a href="#1-StrongReference（强引用）" class="headerlink" title="1.StrongReference（强引用）"></a>1.StrongReference（强引用）</h4><p>如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</div></pre></td></tr></table></figure><h4 id="2-SoftReference（软引用）"><a href="#2-SoftReference（软引用）" class="headerlink" title="2.SoftReference（软引用）"></a>2.SoftReference（软引用）</h4><p>如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h4 id="3-WeakReference（弱引用）"><a href="#3-WeakReference（弱引用）" class="headerlink" title="3.WeakReference（弱引用）"></a>3.WeakReference（弱引用）</h4><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>    弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>    <br><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">WeakReference&lt;String[]&gt; weakBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">WeakReference&lt;String[]&gt; softBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h4 id="4-PhantomReference（虚引用）"><a href="#4-PhantomReference（虚引用）" class="headerlink" title="4.PhantomReference（虚引用）"></a>4.PhantomReference（虚引用）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">PhantomReference&lt;String[]&gt; referent = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h2 id="2-Java中创建线程的方式有哪些"><a href="#2-Java中创建线程的方式有哪些" class="headerlink" title="2.Java中创建线程的方式有哪些"></a>2.Java中创建线程的方式有哪些</h2><h3 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h3><pre><code>(1) 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。(2) 创建Thread子类的实例，即创建了线程对象。(3) 调用线程对象的start()方法来启用该线程。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">FirstThreadTest</span>  <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</div><div class="line"><span class="keyword">int</span>  i  =  <span class="number">0</span>; <span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">System.out.println(getName() +  <span class="string">" "</span>  + i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i  =  <span class="number">0</span>; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">System.out.println(Thread.currentThread().getName() +  <span class="string">" : "</span>  + i);</div><div class="line"><span class="keyword">if</span> (i ==  <span class="number">20</span>) &#123;</div><div class="line"><span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line"><span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName() 方法返回调用该方法的线程的名字。</p><h3 id="2-通过Runnable接口创建线程类"><a href="#2-通过Runnable接口创建线程类" class="headerlink" title="2.通过Runnable接口创建线程类"></a>2.通过Runnable接口创建线程类</h3><pre><code>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法 体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread 对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。</code></pre><h3 id="3-通过Callable和Future创建线程"><a href="#3-通过Callable和Future创建线程" class="headerlink" title="3.通过Callable和Future创建线程"></a>3.通过Callable和Future创建线程</h3><pre><code>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行 体，并且有返回值。（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该 FutureTask对象封装了该Callable对象的call()方法的返回值。（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用 get()方法会阻塞线程。</code></pre><h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><p>采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程 来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型， 较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接 使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。</p><h2 id="3-Object类对象含有的方法有哪些？"><a href="#3-Object类对象含有的方法有哪些？" class="headerlink" title="3.Object类对象含有的方法有哪些？"></a>3.Object类对象含有的方法有哪些？</h2><p>Java中的Object类是所有类的父类，它提供了以下11个方法：</p><pre><code>1.public final native Class&lt;?&gt;getClass()2.public native int hashCode()3.public boolean equals(Object obj)4.protected native Object clone() throws CloneNotSupportedException5.public String toString()6.public final native void notify()7.public final native void notifyAll()8.public final native void wait(long timeout) throws InterruptedException9.public final void wait(long timeout,int nanos)throws InterruptedException10.public final void wait() throws InterruptedException11.protected void finalize() throws Throwable{}</code></pre><h2 id="4-Android中的进程间通信有哪些方式？具体说说Binder"><a href="#4-Android中的进程间通信有哪些方式？具体说说Binder" class="headerlink" title="4.Android中的进程间通信有哪些方式？具体说说Binder"></a>4.Android中的进程间通信有哪些方式？具体说说Binder</h2><p>Android中的IPC方式</p><pre><code>使用Intent使用文件共享使用Messenger使用AIDL使用ContentProvider使用Socket</code></pre><h3 id="1-使用Intent"><a href="#1-使用Intent" class="headerlink" title="1.使用Intent"></a>1.使用Intent</h3><h4 id="1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"><a href="#1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。" class="headerlink" title="1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"></a>1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。</h4><h4 id="2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"><a href="#2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。" class="headerlink" title="2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"></a>2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。</h4><h3 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2.使用文件共享"></a>2.使用文件共享</h3><h4 id="1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem"><a href="#1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem" class="headerlink" title="1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem."></a>1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem.</h4><h4 id="2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"><a href="#2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）" class="headerlink" title="2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"></a>2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）</h4><h4 id="3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"><a href="#3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。" class="headerlink" title="3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"></a>3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。</h4><h3 id="3-使用Messenger"><a href="#3-使用Messenger" class="headerlink" title="3.使用Messenger"></a>3.使用Messenger</h3><p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，可以在不同进程中传递Message对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形</p><ul><li><p>服务端进程：服务端创建一个Service来处理客户端请求，同时通过一个Handler对象来实例化一个Meaaenger对象，然后在Servive的onBind中返回这个Messenger对象底层的Binder即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerSercive</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MessengerSercive.class.getSimpleName();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> msg</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</div><div class="line">                    Log.d(TAG, <span class="string">"receive msg from client: msg = ["</span></div><div class="line">                    + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>);</div><div class="line">                    Toast.makeText(MessengerService.<span class="keyword">this</span>, <span class="string">"receive msg from client: msg = ["</span> + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                    Messenger client = msg.replyTo;</div><div class="line">                    Message replyMsg = Message.obtain(<span class="keyword">null</span>, Constants.MSG_FROM_SERVICE);</div><div class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">                    bundle.putString(Constants.MSG_KEY, <span class="string">"我已经收到你的消息，稍后回复你！"</span>);</div><div class="line">                    replyMsg.setData(bundle);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        client.send(replyMsg);</div><div class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> mMessenger.getBinder();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>客户端进程：首先绑定服务端Service，绑定成功之后用服务端的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，消息类型是Message。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个Messenger（和服务端一样），并通过Message的replyTo参数传递给服务端。服务端通过Message的replyTo参数就可以回应客户端了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity&#123;</div><div class="line">    private static final String TAG = MainActivity.class.getSimpleName();</div><div class="line">    private Messenger mGetReplyMessenger = new Messenger(new MessageHandler());</div><div class="line">    private Messenger mService;</div><div class="line">    private class MessageHandler extends Handler&#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg)&#123;</div><div class="line">            switch(msg.what)&#123;</div><div class="line">                case Constants.MSG_FROM_SERVICE:</div><div class="line">                Log.d(TAG, "received msg form service: msg = </div><div class="line">                [" + msg.getData().getString(Constants.MSG_KEY) + "]");</div><div class="line">                Toast.makeText(MainActivity.this, "received vice: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                super.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInsttanceState)&#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">    public void bindService(View v)&#123;</div><div class="line">        Intent mIntent = new Intent(thia,MessengerService.class);</div><div class="line">        bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">    public void sendMessage(View v)&#123;</div><div class="line">        Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);</div><div class="line">        Bundle data = new Bunle();</div><div class="line">        data.putString(Constants.MSG_KEY, "Hello! This is client.");</div><div class="line">        msg.setData(data);</div><div class="line">        msg.replyTo = mGetReplyMessenger;</div><div class="line">        try&#123;</div><div class="line">            mService.send(mag);</div><div class="line">        &#125;catch(RemoteException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDestroy()&#123;</div><div class="line">        unbindService(mServiceConnection);</div><div class="line">        super.onDestroy();</div><div class="line">    &#125;</div><div class="line">    private ServiceConnection mServiceConnection = new ServiceConnection()&#123;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         * @param service</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder service)&#123;</div><div class="line">            mService = new Messenger(service);</div><div class="line">            Message msg = Message.obtain(null, Constants.MSG_FROM_CLIENT);</div><div class="line">            Bundle data = new Bundle();</div><div class="line">            data.putString(Constants.MSG_KEY,"Hello! This is cient.");</div><div class="line">            msg.setData(data);</div><div class="line">            mag.replyTo = mGetReplyMessenger;</div><div class="line">            try&#123;</div><div class="line">                mService.send(msg);</div><div class="line">            &#125;catch(RemoteException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceDiscommected(ComponentName name)&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>注意： 客户端和服务端是通过通过拿到对方的Messenger来发送Message的。只不过客户端通过bindService onServiceConnected而服务端通过message.replyTo来获得对方的Messenger。Messenger中有一个Hanlder以串行的方式处理队列中的消息。不存在并发执行，因此我们不考虑线程同步的问题。</p><h3 id="4-使用AIDL"><a href="#4-使用AIDL" class="headerlink" title="4.使用AIDL"></a>4.使用AIDL</h3><p>Messenger是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用Messenger，而且Messenger只适合传递消息，不能跨进程调用方法的问题，要知道Messenger本质上也是AIDL，只不过系统做了封装方便上层的调用而已。</p><p><strong>AIDL文件支持的数据类型</strong></p><ul><li>基本数据类型；</li><li>String和CharSequence；</li><li>ArrayList，里面的元素必须能够被AIDL支持；</li><li>HashMap，实现Parcelable接口的对象；注意：如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件。</li><li>AIDL，AIDL接口本身也可以在AIDL文件中使用。<br><strong>服务端</strong><br>服务端创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。<br><strong>客户端</strong><br>绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，然后就可以调用AIDL中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致ANR。客户端的onServiceConnected和onServiceDisconnected方法都在UI线程中。</li></ul><h2 id="5-Android中的AsyncTask的作用？"><a href="#5-Android中的AsyncTask的作用？" class="headerlink" title="5.Android中的AsyncTask的作用？"></a>5.Android中的AsyncTask的作用？</h2><h2 id="6-Android中的消息机制？"><a href="#6-Android中的消息机制？" class="headerlink" title="6.Android中的消息机制？"></a>6.Android中的消息机制？</h2><h2 id="7-Android中的事件分发机制了解多少？如何解决滑动冲突"><a href="#7-Android中的事件分发机制了解多少？如何解决滑动冲突" class="headerlink" title="7.Android中的事件分发机制了解多少？如何解决滑动冲突"></a>7.Android中的事件分发机制了解多少？如何解决滑动冲突</h2><h2 id="8-Java中的抽象类和接口的区别？"><a href="#8-Java中的抽象类和接口的区别？" class="headerlink" title="8.Java中的抽象类和接口的区别？"></a>8.Java中的抽象类和接口的区别？</h2><h3 id="理解抽象"><a href="#理解抽象" class="headerlink" title="理解抽象"></a>理解抽象</h3><p>abstract class 和 interface 是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract calss和interface之间对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。</p><p>其实，两者之间还是有很大区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p><h3 id="语法定义理解"><a href="#语法定义理解" class="headerlink" title="语法定义理解"></a>语法定义理解</h3><h4 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修饰的数据成员（也就是必须是<strong>static final</strong>的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract calss。</p><h3 id="编程角度理解"><a href="#编程角度理解" class="headerlink" title="编程角度理解"></a>编程角度理解</h3><p>首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多继承的支持方面的一种折中考虑吧。</p><p>其次，在abstract class的定义中，我们可以赋予方法的默认行为。</p><p>但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用<strong>default</strong>关键字实现默认方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Java 8 之前，接口与其实现类之间的<strong>耦合度</strong>太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在lambda表达式作为Java8语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。</p><h3 id="一般性理解"><a href="#一般性理解" class="headerlink" title="一般性理解"></a>一般性理解</h3><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是“like-a”关系，抽象类反映的是“is-a”关系。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（if they are class），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它，所以，在高级语言上，一个类只能继承一个类（抽象类）（正如人不可能同时是生物和非生物），但是可以实现多个接口（吃饭接口、走路接口）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。2.抽象类要被子类继承，接口要被类实现。3.接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。4.抽象类里可以没有抽象方法。5.接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。6.接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。7.抽象类不能在Java 8的 lambda 表达式中使用。</code></pre><h2 id="9-Java设计模式了解多少？观察者模式在哪里使用过？"><a href="#9-Java设计模式了解多少？观察者模式在哪里使用过？" class="headerlink" title="9.Java设计模式了解多少？观察者模式在哪里使用过？"></a>9.Java设计模式了解多少？观察者模式在哪里使用过？</h2><h2 id="10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？"><a href="#10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？" class="headerlink" title="10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？"></a>10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大概在数天前投递了字节跳动-抖音方向的实习生岗位&lt;br&gt;昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题）&lt;/p&gt;
&lt;h2 id=&quot;1-Java中的引用类型有没有什么了解？&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>深度学习模型的转换 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://edward7zhang.github.io/2019/01/26/深度学习模型的转换/</id>
    <published>2019-01-26T11:07:14.000Z</published>
    <updated>2019-01-26T14:04:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端部署我们可能会使用feather CNN nihui的NCNN或者小米的mace等框架。facebook ONNX的出现为模型的转换提供了一种思路，但除了pytorch等框架能很好的支持ONNX。其他等框架并未很好的对接ONNX。在<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>出现之前，大家都把caffemodel作为一个中间体来进行转换。</p><p>其实就模型转换而言只是个填参数的过程，把模型结构搭好，把参数填进去就即可，但是实践过的朋友大家一定会知道这其中存在不少坑，但是我们更希望有一种自动化的模型转换方案来进行模型转换。</p><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的出现为模型转换带来了不少的福音，<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>提供了一种IR(中间表示)来来衔接各个模型之间的转换。他囊括并支持了主流的DNN框架。</p><p>下面我就简要讲一下几个的简单模型转换</p><p>在此我推荐一个查看模型结构的工具<a href="https://github.com/lutzroeder/Netron" target="_blank" rel="external">Netron</a> 支持数种主流深度学习框架(Caffe,Tensorflow,ONNX等)的模型结构查看。</p><p>例如下图是MTCNN Pnet的模型结构图</p><p><img src="https://i.loli.net/2019/01/09/5c35f0ad3eaf1.png" alt="det1.png"></p><h3 id="MMdnn的安装"><a href="#MMdnn的安装" class="headerlink" title="MMdnn的安装"></a>MMdnn的安装</h3><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的安装非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mmdnn</div></pre></td></tr></table></figure><h4 id="转换中的一些坑"><a href="#转换中的一些坑" class="headerlink" title="转换中的一些坑"></a>转换中的一些坑</h4><h5 id="1-并不是所有Layer和所有网络都支持转换"><a href="#1-并不是所有Layer和所有网络都支持转换" class="headerlink" title="1.并不是所有Layer和所有网络都支持转换"></a>1.并不是所有Layer和所有网络都支持转换</h5><p>由于各个深度学习框架之间的设计模式不同有的是基于命令式的有的是基于符号形式的。各个框架之间的op的粒度不同，又由于没有一个统一的标准，支持所有框架之间的转换是一件非常难的事情。MMdnn也只是把一些提供的常用的op，如conv,pooling等常规op。</p><h5 id="2-Tensorflow与caffe的padding方式并不相同"><a href="#2-Tensorflow与caffe的padding方式并不相同" class="headerlink" title="2.Tensorflow与caffe的padding方式并不相同"></a>2.Tensorflow与caffe的padding方式并不相同</h5><p>这个问题会出现在MobileNet在转换的过程中，因为Tensorflow的padding方式和其他框架是不同的。Tensorflow标准的卷积操作通常采用非对称的padding，而caffe等其他框架的卷积操作则是采用对称的padding。</p><p>如下图 ，比如当 卷积核的大小为3x3 stride为2的时候。尽管他们的padding方式不同，但卷积之后的尺寸确是一样的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/Microsoft/MMdnn/wiki/image/mobilenet1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h4><p>例如现在我们想把MTCNN的Keras Pnet转化成caffeodel用于部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtoir -f keras -w pnet.h5 -o pnet</div></pre></td></tr></table></figure><p>把keras模型转化成MMdnn IR中间表示，在当然目录下会生成一个.npy 的weights文件和一个.pb文件。接着使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtomodel -f caffe -in pnet -iw pnet.npy -o pnet</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习经典卷积神经网络 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://edward7zhang.github.io/2019/01/16/深度学习经典卷积神经网络/</id>
    <published>2019-01-16T11:07:14.000Z</published>
    <updated>2019-01-26T14:03:30.420Z</updated>
    
    <content type="html"><![CDATA[<p>随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：</p><pre><code>1.LeNet-5, 1998年2.AlexNet, 2012年3.ZF-Net, 2013年4.GoogleNet, 2014年5.VGG, 2014年6.ResNet, 2015年</code></pre><p>经过科研工作者的反复验证及广泛使用，这些模型逐渐成为经典，我们这里收集了一些常用的模型进行介绍。</p><h3 id="1-VGG"><a href="#1-VGG" class="headerlink" title="1. VGG"></a>1. VGG</h3><p><a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="external">论文地址</a></p><p>VGGNet是牛津大学计算机视觉组（Visual Geometry Group）和 Google DeepMind 公司的研究员一起研发的的深度卷积神经网络。VGGNet 探索了卷积神经网络的深度与其性能之间的关系，一共有六种不同的网络结构，但是每种结构都有含有５组卷积，每组卷积都使用３ｘ３的卷积核，每组卷积后进行一个２ｘ２最大池化，接下来是三个全连接层。在训练高级别的网络时，可以先训练低级别的网络，用前者获得的权重初始化高级别的网络，可以加速网络的收敛。VGGNet 相比之前state-of-the-art的网络结构，错误率大幅下降，并取得了ILSVRC 2014比赛分类项目的第2名和定位项目的第1名。同时VGGNet的拓展性很强，迁移到其他图片数据上的泛化性非常好。VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3<em>3）和最大池化尺寸（2</em>2）。<br>到目前为止，VGGNet依然经常被用来提取图像特征。</p><p><a href="https://blog.csdn.net/marsjhao/article/details/72955935" target="_blank" rel="external">经典卷积神经网络之VGGNet</a></p><p><a href="https://blog.csdn.net/qq_40027052/article/details/79015827" target="_blank" rel="external">VGG模型核心拆解</a></p><h3 id="2-GoogLeNet"><a href="#2-GoogLeNet" class="headerlink" title="2. GoogLeNet"></a>2. GoogLeNet</h3><p><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="external">[v1] Going Deeper with Convolutions</a></p><p><a href="http://arxiv.org/abs/1502.03167" target="_blank" rel="external">[v2] Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></p><p><a href="http://arxiv.org/abs/1512.00567" target="_blank" rel="external">[v3] Rethinking the Inception Architecture for Computer Vision</a> </p><p><a href="http://arxiv.org/abs/1602.07261" target="_blank" rel="external">[v4] Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning</a></p><p>GoogLeNet的最早版本，出现在2014年的” Going deeper with convolutions “。之所以名为 “GoogLeNet” 而非 “GoogleNet” ,文章说是为了向早期的LeNet致敬。GoogleNet提出了一个全新的深度 CNN 架构——Inception，无全连接层，可以节省运算的同时，减少了很多参数，参数数量是AlexNet的1/12，数量只有5 million，而且在ImageNet竞赛中取得了很好的成绩。</p><p><a href="https://blog.csdn.net/cdknight_happy/article/details/79247280" target="_blank" rel="external">GoogleNet系列论文学习</a></p><h3 id="3-Resnet"><a href="#3-Resnet" class="headerlink" title="3. Resnet"></a>3. Resnet</h3><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="external">论文地址</a></p><p>ResNet在2015年被提出，在ImageNet比赛classification任务上获得第一名，因为它 “简单与实用” 并存，之后很多方法都建立在ResNet50或者ResNet101的基础上完成的，检测，分割，识别等领域都纷纷使用ResNet，具有很强的适应性。ResNet的作者<a href="http://kaiminghe.com/" target="_blank" rel="external">何凯明</a>也因此摘得CVPR2016最佳论文奖。</p><p><a href="https://blog.csdn.net/lanran2/article/details/79057994" target="_blank" rel="external">ResNet解析</a></p><p><a href="https://blog.csdn.net/xxy0118/article/details/78324256" target="_blank" rel="external">ResNet学习</a></p><h3 id="4-MobileNet-V1-amp-MobileNet-V2"><a href="#4-MobileNet-V1-amp-MobileNet-V2" class="headerlink" title="4. MobileNet-V1 &amp; MobileNet -V2"></a>4. MobileNet-V1 &amp; MobileNet -V2</h3><p><a href="https://arxiv.org/abs/1704.04861" target="_blank" rel="external">V1论文地址</a></p><p><a href="https://arxiv.org/abs/1801.04381" target="_blank" rel="external">V2论文地址</a></p><p>MobileNet是Google团队针对移动端提出的高效图像识别网络，深入的研究了Depthwise Separable Convolutions使用方法后设计出MobileNet，Depthwise Separable Convolutions的本质是冗余信息更少的稀疏化表达。在此基础上给出了高效模型设计的两个选择：宽度因子(Width Multiplier)和分辨率因子(Resolution Multiplier)；通过权衡大小、延迟时间以及精度，来构建规模更小、速度更快的MobileNet。</p><p>MobileNet V2是之前MobileNet V1的改进版。MobileNet V1中主要是引入了Depthwise Separable Convolution代替传统的卷积操作，相当于实现了spatial和channel之间的解耦，达到模型加速的目的，整体网络结构还是延续了VGG网络直上直下的特点。和MobileNet V1相比，MobileNet V2主要的改进有两点：1、Linear Bottlenecks。也就是去掉了小维度输出层后面的非线性激活层，目的是为了保证模型的表达能力。2、Inverted Residual block。该结构和传统residual block中维度先缩减再扩增正好相反，因此shotcut也就变成了连接的是维度缩减后的feature map。</p><p><a href="https://blog.csdn.net/t800ghb/article/details/78879612" target="_blank" rel="external">深度解读谷歌MobileNet</a></p><p><a href="https://blog.csdn.net/u011995719/article/details/79135818" target="_blank" rel="external">轻量化网络：MobileNet-V2</a></p><h3 id="5-U-NET"><a href="#5-U-NET" class="headerlink" title="5. U-NET"></a>5. U-NET</h3><p><a href="http://arxiv.org/abs/1505.04597" target="_blank" rel="external">论文地址</a></p><p><a href="https://lmb.informatik.uni-freiburg.de/people/ronneber/u-net/" target="_blank" rel="external">项目地址</a></p><p>这是Encoder-Decoder网络的一种，在无监督学习中的框架，利用conv与deconv降维升维来进行学习，分别叫做encoder与decoder编码解码，一般基于卷积网络，encoder后相当于学习到了特征，而decoder后相当于还原了图像，既可以用输入图像进行训练，训练好一层加深一层。再可以利用有监督微调，从而达到分类或者图像转换的目的。</p><h3 id="6-GAN"><a href="#6-GAN" class="headerlink" title="6. GAN"></a>6. GAN</h3><p>总结：利用两个网络对抗生成模型，生成器与辨别器，生成器输入图像，生成所需图像，辨别器辨别所需图像与生成图像，使生成器的生成图像骗过辨别器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>常用深度学习框架[学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/09/%E5%B8%B8%E8%A7%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>https://edward7zhang.github.io/2019/01/09/常见深度学习框架/</id>
    <published>2019-01-09T11:07:14.000Z</published>
    <updated>2019-01-09T12:55:52.270Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，针对主流的深度学习框架进行简单对比及介绍。</p><table><thead><tr><th>框架</th><th>机构</th><th>支持语言</th><th>Stars</th><th>Forks</th></tr></thead><tbody><tr><td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">Caffe</a></td><td>BVLC</td><td>C++/Python/Matlab</td><td>25480</td><td>15560</td></tr><tr><td><a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">CNTK</a></td><td>Microsoft</td><td>C++</td><td>15083</td><td>4020</td></tr><tr><td><a href="notebooks/Keras_TF_CNN.ipynb">Keras</a></td><td>Fchollet</td><td>Python</td><td>33332</td><td>12563</td></tr><tr><td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">Tensorflow</a></td><td>Google</td><td>Python/C++/Go…</td><td>109115</td><td>67339</td></tr><tr><td><a href="https://github.com/apache/incubator-mxnet" target="_blank" rel="external">MXNet</a></td><td>DMLC</td><td>Python/C++/R…</td><td>15162</td><td>5484</td></tr><tr><td><a href="https://github.com/pytorch/pytorch" target="_blank" rel="external">PyTorch</a></td><td>Facebook</td><td>Python</td><td>18517</td><td>4426</td></tr></tbody></table><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><h4 id="1-训练时间-Network-DenseNet-121-Multi-GPU"><a href="#1-训练时间-Network-DenseNet-121-Multi-GPU" class="headerlink" title="1. 训练时间: Network DenseNet-121 (Multi-GPU)"></a>1. 训练时间: Network DenseNet-121 (Multi-GPU)</h4><p><strong>运行于 SSD 硬盘</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">27min</td><td style="text-align:center">10min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">38min</td><td style="text-align:center">18min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">33min</td><td style="text-align:center">22min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">29min</td><td style="text-align:center">10min</td></tr></tbody></table><p><strong>运行于RAM内存中</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">25min</td><td style="text-align:center">8min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">36min</td><td style="text-align:center">15min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">25min</td><td style="text-align:center">14min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">28min</td><td style="text-align:center">8min</td></tr></tbody></table><h4 id="2-1000张图片推理时间-s-Network-ResNet-50"><a href="#2-1000张图片推理时间-s-Network-ResNet-50" class="headerlink" title="2. 1000张图片推理时间(s): Network ResNet-50"></a>2. 1000张图片推理时间(s): Network ResNet-50</h4><table><thead><tr><th>框架</th><th style="text-align:center">K80/CUDA 8/CuDNN 6</th><th style="text-align:center">P100/CUDA 8/CuDNN 6</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">8.5</td><td style="text-align:center">1.6</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">10.2</td><td style="text-align:center">2.9</td></tr><tr><td>Tensorflow</td><td style="text-align:center">6.5</td><td style="text-align:center">1.8</td></tr><tr><td>MXNet</td><td style="text-align:center">7.7</td><td style="text-align:center">1.6</td></tr><tr><td>PyTorch</td><td style="text-align:center">7.7</td><td style="text-align:center">1.9</td></tr></tbody></table><h4 id="3-CPU推理时间-s-E5-2630v4-Network-FCN5"><a href="#3-CPU推理时间-s-E5-2630v4-Network-FCN5" class="headerlink" title="3. CPU推理时间(s): E5-2630v4, Network FCN5"></a>3. CPU推理时间(s): E5-2630v4, Network FCN5</h4><table><thead><tr><th>框架</th><th style="text-align:center">1 Thread</th><th style="text-align:center">2 Threads</th><th style="text-align:center">4 Threads</th><th style="text-align:center">8 Threads</th><th style="text-align:center">16 Threads</th><th style="text-align:center">32 Threads</th></tr></thead><tbody><tr><td>Caffe</td><td style="text-align:center">1887.2ms</td><td style="text-align:center">1316.7ms</td><td style="text-align:center">1051.8ms</td><td style="text-align:center">952.1ms</td><td style="text-align:center">952.3ms</td><td style="text-align:center">834.7ms</td></tr><tr><td>CNTK</td><td style="text-align:center">1238.7ms</td><td style="text-align:center">616.3ms</td><td style="text-align:center">352.7ms</td><td style="text-align:center">229.5ms</td><td style="text-align:center">155.9ms</td><td style="text-align:center">192.4ms</td></tr><tr><td>Tensorflow</td><td style="text-align:center">992.2ms</td><td style="text-align:center">773.6ms</td><td style="text-align:center">419.3ms</td><td style="text-align:center">252.3ms</td><td style="text-align:center">149.7ms</td><td style="text-align:center">124.7ms</td></tr><tr><td>MXNet</td><td style="text-align:center">1386.8ms</td><td style="text-align:center">915.5ms</td><td style="text-align:center">559.0ms</td><td style="text-align:center">499.1ms</td><td style="text-align:center">416.3ms</td><td style="text-align:center">413.9ms</td></tr></tbody></table><h3 id="框架评价"><a href="#框架评价" class="headerlink" title="框架评价"></a>框架评价</h3><table><thead><tr><th>框架</th><th style="text-align:center">安装成本</th><th style="text-align:center">代码理解程度</th><th style="text-align:center">API丰富程度</th><th style="text-align:center">模型丰富程度</th><th style="text-align:center">文档完整程度</th><th style="text-align:center">训练与测过程</th><th style="text-align:center">学习资源</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Keras</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td></tr><tr><td>MXNet</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Pytorch</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Tensorflow</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Caffe</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td></tr></tbody></table><h3 id="推荐框架"><a href="#推荐框架" class="headerlink" title="推荐框架"></a>推荐框架</h3><p>目前众多的深度学习框架，使用者只要选择适合自己的框架即可，我们在日常使用中，考虑到训练的快捷程度，部署难度以及对CNN、RNN模型的直接程度，推荐以下几款深度学习框架。</p><h4 id="1-Keras"><a href="#1-Keras" class="headerlink" title="1.Keras"></a>1.Keras</h4><p>Keras 提供了简单易用的 API 接口，入门快，特别适合初学者入门。其后端采用 TensorFlow, CNTK，以及 Theano。另外，Deeplearning4j 的 Python 也是基于 Keras 实现的。Keras 几乎已经成了 Python 神经网络的接口标准。</p><h4 id="2-TensorFlow"><a href="#2-TensorFlow" class="headerlink" title="2.TensorFlow"></a>2.TensorFlow</h4><p>谷歌出品，追随者众多。代码质量高，支持模型丰富，支持语言多样， TensorBoard 可视化工具使用方便。</p><h4 id="3-MXNet"><a href="#3-MXNet" class="headerlink" title="3.MXNet"></a>3.MXNet</h4><p>已被亚马逊选为 AWS 上的深度学习框架，支持动态图计算。MXNet 有许多中国开发者，因而有非常良好的中文文档支持。Gluon 接口使得 MXNet 像 Keras 一样简单易用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://dlbench.comp.hkbu.edu.hk/?v=v8" target="_blank" rel="external">香港浸会大学深度学习框架Benchmark</a></li><li><a href="https://github.com/ilkarman/DeepLearningFrameworks" target="_blank" rel="external">DeepLearningFrameworks</a></li><li><a href="http://app.myzaker.com/news/article.php?pk=5a13b55c1bc8e05d71000016" target="_blank" rel="external">博客</a></li><li><a href="https://www.zhihu.com/question/68114194/answer/465874315" target="_blank" rel="external">开发者如何选择深度学习框架?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>回环，未来可期</title>
    <link href="https://edward7zhang.github.io/2018/08/27/%E5%9B%9E%E7%8E%AF%EF%BC%8C%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/"/>
    <id>https://edward7zhang.github.io/2018/08/27/回环，未来可期/</id>
    <published>2018-08-26T17:42:07.000Z</published>
    <updated>2018-08-26T13:25:57.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天，是我21岁的生日。<br>在一个半月前我辞职了，但准确的说是被动式辞职。<br>现在看来这是一件好事。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8176988f43d.jpg" alt="第一天到公司楼下" title="">                </div>                <div class="image-caption">第一天到公司楼下</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac7c155.jpg" alt="工牌" title="">                </div>                <div class="image-caption">工牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b81769918ccc.jpg" alt="第一天安顿下来" title="">                </div>                <div class="image-caption">第一天安顿下来</div>            </figure><h2 id="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"><a href="#似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历" class="headerlink" title="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"></a>似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历</h2><p>辞职的原因是优秀的project不被认可…所以和我的直接主管就一并选择了离职…</p><p>在外界人看来可能这种做法简直是不解…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173aeb88e9.jpg" alt="嗯，希望这家公司可以保持初心" title="">                </div>                <div class="image-caption">嗯，希望这家公司可以保持初心</div>            </figure><p>可是对于程序猿这类人来说，能做自己感兴趣的事情应该是最高的荣誉…</p><p>况且是在一个优秀project并且在有良好实现的基础上被否掉…这种痛苦莫过于饮鸩</p><p>正如标题所言<strong> 回环 </strong>，刚刚接到消息的时候自己还郁闷了一整天，现在回头看这应该是一种回环，就如同立交桥的转环匝道，虽然又绕回了原点，但是却提升了一个维度。</p><p>幸运如我，在这短暂的实习中遇到了非常nice的主管，涨了很多见识，意识到我之前是多么的短视…从而也看到了自己未来的一些可能，但前提要做一些付出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad848db.jpg" alt="公司对面的腾讯&完美世界" title="">                </div>                <div class="image-caption">公司对面的腾讯&完美世界</div>            </figure><h2 id="在这两个月的实习中，项目进展有如神助"><a href="#在这两个月的实习中，项目进展有如神助" class="headerlink" title="在这两个月的实习中，项目进展有如神助"></a>在这两个月的实习中，项目进展有如神助</h2><p>在实习这段时间，项目进展速度惊人，每天都很充实，每天一组的伙伴们都在一起想对策，现在回头想想也许是之前自己在人工智能方面的一点小小的经验加之主管之前在NLP方面的研究的共交使得项目发展迅速。</p><p>两个月的时间实现了模型的搭建以及demo的实现&amp;项目预演…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a8e14d3.png" alt="工位" title="">                </div>                <div class="image-caption">工位</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac5d381.jpg" alt="在公司最后一天的项目汇报" title="">                </div>                <div class="image-caption">在公司最后一天的项目汇报</div>            </figure><p>至于为什么否掉我们…各种因素…不想明说了…有点官宦风格…各位看客自己想象吧…</p><h2 id="下一步，再进站"><a href="#下一步，再进站" class="headerlink" title="下一步，再进站"></a>下一步，再进站</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad86919.jpg" alt="反射" title="">                </div>                <div class="image-caption">反射</div>            </figure><p>这一趟实习下来，可以说彻底改变了我曾经对自己的看法…</p><p>总的来说，过去我常常视线过度短浅…在对自己人生的规划上也过于保守吧…</p><p>事实上，一个人所看到的往往是狭窄的，通过不断的接触高层次的人和事物才能让自己变得更open。</p><p>决定了考研，也看清了国内的互联网环境的虚实…希望自己能付有所得…</p><p>如果有机会，还是去接触接触技术原始地熏陶熏陶吧…</p><h2 id="未来可期"><a href="#未来可期" class="headerlink" title="未来可期"></a>未来可期</h2><p>在大学里的三年再算上实习的经历…尝试了互联网开发的很多方向…</p><p>最终吸引我的并不是各种框架炫技的开发…而是能赋予应用灵魂的人工智能方向…</p><p>大概未来的发展方向也就定在这样的趋势了…</p><p><strong>继续行走，未来可期。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac9ba83.jpg" alt="离开那天天气很好" title="">                </div>                <div class="image-caption">离开那天天气很好</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a5c08cd.jpg" alt="未来可期" title="">                </div>                <div class="image-caption">未来可期</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天，是我21岁的生日。&lt;br&gt;在一个半月前我辞职了，但准确的说是被动式辞职。&lt;br&gt;现在看来这是一件好事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div 
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>基于TensorFlow的CNN中文文本分类</title>
    <link href="https://edward7zhang.github.io/2018/05/20/%E5%9F%BA%E4%BA%8ETensorFlow%E7%9A%84CNN%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    <id>https://edward7zhang.github.io/2018/05/20/基于TensorFlow的CNN中文文本分类/</id>
    <published>2018-05-20T10:00:07.000Z</published>
    <updated>2018-05-20T10:50:21.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。</p></blockquote><h1 id="CNN实现文本分类的原理"><a href="#CNN实现文本分类的原理" class="headerlink" title="CNN实现文本分类的原理"></a>CNN实现文本分类的原理</h1><p>下图展示了如何使用cnn进行句子分类。输入是一个句子，为了使其可以进行卷积，首先需要将其转化为向量表示，通常使用word2vec实现。d=5表示每个词转化为5维的向量，矩阵的形状是[sentence_length ×× 5]，即[7 ×× 5]。6个filter（卷积核），与图像中使用的卷积核不同的是，nlp使用的卷积核的宽与句子矩阵的宽相同，只是长度不同。这里有（2，3，4）三种size，每种size有两个filter，一共有6个filter。然后开始卷积，从图中可以看出，stride是1，因为对于高是4的filter，最后生成4维的向量，（7-4）/1+1=4。对于高是3的filter，最后生成5维的向量，（7-3）/1+1=5。卷积之后，我们得到句子的特征，使用activation function和1-max-pooling得到最后的值，每个filter最后得到两个特征。将所有特征合并后，使用softmax进行分类。图中没有用到chanel,下文的实验将会使用两个通道，static和non-static，有相关的具体解释。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-12.05.40-PM-1024x937.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h1 id="本文使用的模型"><a href="#本文使用的模型" class="headerlink" title="本文使用的模型"></a>本文使用的模型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-8.03.47-AM-1024x413.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>主要包括五层，第一层是embedding layer,第二层是convolutional layer,第三层是max-pooling layer,第四层是fully connected layer，最后一层是softmax layer.接下来依次介绍相关代码实现。</p><h2 id="Input-placeholder"><a href="#Input-placeholder" class="headerlink" title="Input placeholder"></a>Input placeholder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Placeholders for input, output and dropout</div><div class="line">self.input_x = tf.placeholder(tf.int32, [None, sequence_length], name=&quot;input_x&quot;)</div><div class="line">self.input_y = tf.placeholder(tf.float32, [None, num_classes], name=&quot;input_y&quot;)</div><div class="line">self.dropout_keep_prob = tf.placeholder(tf.float32, name=&quot;dropout_keep_prob&quot;)</div></pre></td></tr></table></figure><p><code>tf.placeholder</code> 创建一个占位符变量，在训练或者测试的时候，需要将占位符输入到网络中进行计算，其中的第二个参数是输入张量的形状。None 意味着它可以是任何维度的长度，在我们的实验中它代表批处理的大小，None使得网络可以处理任意长度的batches。<br>失活率同样也是输入的一部分，在训练的时候使用dropout ，测试的时候不使用dropout 。</p><h2 id="EMBEDDING-LAYER"><a href="#EMBEDDING-LAYER" class="headerlink" title="EMBEDDING LAYER"></a>EMBEDDING LAYER</h2><p>这一层将单词索引映射到低维的向量表示，它本质上是一个查找表，我们从数据中通过学习得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with tf.device(&apos;/cpu:0&apos;), tf.name_scope(&quot;embedding&quot;):</div><div class="line">    W = tf.Variable(tf.random_uniform([vocab_size, embedding_size], -1.0, 1.0), name=&quot;W&quot;)</div><div class="line">    self.embedded_chars = tf.nn.embedding_lookup(W, self.input_x)</div><div class="line">    self.embedded_chars_expanded = tf.expand_dims(self.embedded_chars, -1)</div></pre></td></tr></table></figure><p>其中，<code>W</code> 是 在训练时得到的embedding matrix.，用随机均匀分布进行初始化。<a href="http://blog.csdn.net/u013713117/article/details/55048040" target="_blank" rel="external">tf.nn.embedding_lookup</a>实现embedding操作，得到 一个3-dimensional 的张量，形状是 <code>[None, sequence_length, embedding_size].</code> <code>sequence_length</code> 是数据集中最长句子的长度，其他句子都通过添加“PAD”补充到这个长度。<code>embedding_size</code> 是词向量的大小。</p><p>TensorFlow的卷积函数-<code>conv2d</code> 需要四个参数， 分别是batch, width, height 以及channel。 embedding之后不包括 channel, 所以我们人为地添加上它，并设置为1。现在就是<code>[None, sequence_length, embedding_size, 1]</code></p><h2 id="CONVOLUTION-AND-MAX-POOLING-LAYERS"><a href="#CONVOLUTION-AND-MAX-POOLING-LAYERS" class="headerlink" title="CONVOLUTION AND MAX-POOLING LAYERS"></a>CONVOLUTION AND MAX-POOLING LAYERS</h2><p>由图中可知， 我们有不同size的filters。因为每次卷积都会产生不同形状的张量，所以我们要遍历每个filter，然后将结果合并成一个大的特征向量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pooled_outputs = []</div><div class="line">for i, filter_size in enumerate(filter_sizes):</div><div class="line">    with tf.name_scope(&quot;conv-maxpool-%s&quot; % filter_size):</div><div class="line">        # Convolution Layer</div><div class="line">        filter_shape = [filter_size, embedding_size, 1, num_filters]</div><div class="line">        W = tf.Variable(tf.truncated_normal(filter_shape, stddev=0.1), name=&quot;W&quot;)</div><div class="line">        b = tf.Variable(tf.constant(0.1, shape=[num_filters]), name=&quot;b&quot;)</div><div class="line">        conv = tf.nn.conv2d(</div><div class="line">            self.embedded_chars_expanded,</div><div class="line">            W,</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&quot;VALID&quot;,</div><div class="line">            name=&quot;conv&quot;)</div><div class="line">        # Apply nonlinearity</div><div class="line">        h = tf.nn.relu(tf.nn.bias_add(conv, b), name=&quot;relu&quot;)</div><div class="line">        # Max-pooling over the outputs</div><div class="line">        pooled = tf.nn.max_pool(</div><div class="line">            h,</div><div class="line">            ksize=[1, sequence_length - filter_size + 1, 1, 1],</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&apos;VALID&apos;,</div><div class="line">            name=&quot;pool&quot;)</div><div class="line">        pooled_outputs.append(pooled)</div><div class="line"></div><div class="line"># Combine all the pooled features</div><div class="line">num_filters_total = num_filters * len(filter_sizes)</div><div class="line">self.h_pool = tf.concat(3, pooled_outputs)</div><div class="line">self.h_pool_flat = tf.reshape(self.h_pool, [-1, num_filters_total])</div></pre></td></tr></table></figure><p>这里<code>W</code> 是filter 矩阵，<code>h</code> 是对卷积结果进行非线性转换之后的结果。每个 filter都从整个embedding划过,不同之处在于覆盖多少单词。 “VALID” padding意味着没有对句子的边缘进行padding,也就是用了narrow convolution，输出的形状是 <code>[1, sequence_length - filter_size + 1, 1, 1]</code>。narrow convolution与 wide convolution的区别是是否对边缘进行填充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-9.47.41-AM-1024x261.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br><em>Narrow vs. Wide Convolution. Filter size 5, input size 7. Source: A Convolutional Neural Network for Modelling Sentences (2014)</em><br>当你的filter比输入的size还大时，你可以看到wide convolution是多么的有用，甚至说是必须的。如上所示，narrow convolution产出的尺寸是（7-5）+1=3，而wide convolution产出尺寸是（7+2*4-5）+1=11。通常，输出尺寸的规则表达式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161218225721289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVlbWFpY2hh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br>对输出进行max-pooling后得到形状是 <code>[batch_size, 1, 1, num_filters]</code> 的张量，本质上是一个特征向量，最后一个维度是特征代表数量。把每一个max-pooling之后的张量合并起来之后得到一个长向量 <code>[batch_size, num_filters_total]</code>. in <code>tf.reshape</code> 中的 -1表示T将向量展平。</p><h2 id="DROPOUT-LAYER"><a href="#DROPOUT-LAYER" class="headerlink" title="DROPOUT LAYER"></a>DROPOUT LAYER</h2><p>Dropout也许是cnn中最流行的正则化方法。dropout的想法很简单，dropout layer随机地选择一些神经元，使其失活。这样可以阻止co-adapting,迫使它们每一个都学习到有用的特征。失活的神经单元个数由<code>dropout_keep_prob</code> 决定。在训练的时候设为 0.5 ,测试的时候设为 1 (disable dropout) .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Add dropout</div><div class="line">with tf.name_scope(&quot;dropout&quot;):</div><div class="line">    self.h_drop = tf.nn.dropout(self.h_pool_flat, self.dropout_keep_prob)</div></pre></td></tr></table></figure><h2 id="SCORES-AND-PREDICTIONS"><a href="#SCORES-AND-PREDICTIONS" class="headerlink" title="SCORES AND PREDICTIONS"></a>SCORES AND PREDICTIONS</h2><p>利用特征向量，我们可以用矩阵相乘计算两类的得分，也可以用 softmax函数计算两类的概率值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">with tf.name_scope(&quot;output&quot;):</div><div class="line">    W = tf.Variable(tf.truncated_normal([num_filters_total, num_classes], stddev=0.1), name=&quot;W&quot;)</div><div class="line">    b = tf.Variable(tf.constant(0.1, shape=[num_classes]), name=&quot;b&quot;)</div><div class="line">    self.scores = tf.nn.xw_plus_b(self.h_drop, W, b, name=&quot;scores&quot;)</div><div class="line">    self.predictions = tf.argmax(self.scores, 1, name=&quot;predictions&quot;)</div></pre></td></tr></table></figure><h2 id="LOSS-AND-ACCURACY"><a href="#LOSS-AND-ACCURACY" class="headerlink" title="LOSS AND ACCURACY"></a>LOSS AND ACCURACY</h2><p>可以用得分定义损失值。损失计算的是网络的误差，我们的目标是将其最小化，分类问题标准的损失函数是交叉熵损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate mean cross-entropy loss</div><div class="line">with tf.name_scope(&quot;loss&quot;):</div><div class="line">    losses = tf.nn.softmax_cross_entropy_with_logits(self.scores, self.input_y)</div><div class="line">    self.loss = tf.reduce_mean(losses)</div></pre></td></tr></table></figure><p>计算正确率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate Accuracy</div><div class="line">with tf.name_scope(&quot;accuracy&quot;):</div><div class="line">    correct_predictions = tf.equal(self.predictions, tf.argmax(self.input_y, 1))</div><div class="line">    self.accuracy = tf.reduce_mean(tf.cast(correct_predictions, &quot;float&quot;), name=&quot;accuracy&quot;)</div></pre></td></tr></table></figure><h2 id="MINIMIZING-THE-LOSS"><a href="#MINIMIZING-THE-LOSS" class="headerlink" title="MINIMIZING THE LOSS"></a>MINIMIZING THE LOSS</h2><p>利用TensorFlow 内置的optimizers，例如 Adam optimizer，优化网络损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">global_step = tf.Variable(0, name=&quot;global_step&quot;, trainable=False)</div><div class="line">optimizer = tf.train.AdamOptimizer(1e-4)</div><div class="line">grads_and_vars = optimizer.compute_gradients(cnn.loss)</div><div class="line">train_op = optimizer.apply_gradients(grads_and_vars, global_step=global_step)</div></pre></td></tr></table></figure><p><code>train_op</code> 是一个新建的操作，我们可以在参数上进行梯度更新。每执行一次 <code>train_op</code> 就是一次训练步骤。 TensorFlow 可以自动地计算才那些变量是“可训练的”然后计算他们的梯度。通过<code>global_step</code>这个变量可以计算训练的步数，每训练一次自动加一。</p><h2 id="CHECKPOINTING"><a href="#CHECKPOINTING" class="headerlink" title="CHECKPOINTING"></a>CHECKPOINTING</h2><p>TensorFlow 中可以用checkpointing 保存模型的参数。checkpointing中的参数也可以用来继续训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Checkpointing</div><div class="line">checkpoint_dir = os.path.abspath(os.path.join(out_dir, &quot;checkpoints&quot;))</div><div class="line">checkpoint_prefix = os.path.join(checkpoint_dir, &quot;model&quot;)</div><div class="line"># Tensorflow assumes this directory already exists so we need to create it</div><div class="line">if not os.path.exists(checkpoint_dir):</div><div class="line">    os.makedirs(checkpoint_dir)</div><div class="line">saver = tf.train.Saver(tf.all_variables())</div></pre></td></tr></table></figure><h2 id="DEFINING-A-SINGLE-TRAINING-STEP"><a href="#DEFINING-A-SINGLE-TRAINING-STEP" class="headerlink" title="DEFINING A SINGLE TRAINING STEP"></a>DEFINING A SINGLE TRAINING STEP</h2><p>用一个batch的数据进行一次训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def train_step(x_batch, y_batch):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    A single training step</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: FLAGS.dropout_keep_prob</div><div class="line">    &#125;</div><div class="line">    _, step, summaries, loss, accuracy = sess.run(</div><div class="line">        [train_op, global_step, train_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    train_summary_writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><p><code>train_op</code> 什么也不返回，只是更新网络中的参数。最终，打印出当前训练的损失值与正确率。如果batch的size很小的话，这两者在不同的batch中差别很大。因为使用了dropout，训练的metrics可能要比测试的metrics糟糕。</p><p>同样的函数也可以用在测试时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def dev_step(x_batch, y_batch, writer=None):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Evaluates model on a dev set</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: 1.0</div><div class="line">    &#125;</div><div class="line">    step, summaries, loss, accuracy = sess.run(</div><div class="line">        [global_step, dev_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    if writer:</div><div class="line">        writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><h2 id="TRAINING-LOOP"><a href="#TRAINING-LOOP" class="headerlink" title="TRAINING LOOP"></a>TRAINING LOOP</h2><p>通过迭代数据进行训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Generate batches</div><div class="line">batches = data_helpers.batch_iter(</div><div class="line">    zip(x_train, y_train), FLAGS.batch_size, FLAGS.num_epochs)</div><div class="line"># Training loop. For each batch...</div><div class="line">for batch in batches:</div><div class="line">    x_batch, y_batch = zip(*batch)</div><div class="line">    train_step(x_batch, y_batch)</div><div class="line">    current_step = tf.train.global_step(sess, global_step)</div><div class="line">    if current_step % FLAGS.evaluate_every == 0:</div><div class="line">        print(&quot;\nEvaluation:&quot;)</div><div class="line">        dev_step(x_dev, y_dev, writer=dev_summary_writer)</div><div class="line">        print(&quot;&quot;)</div><div class="line">    if current_step % FLAGS.checkpoint_every == 0:</div><div class="line">        path = saver.save(sess, checkpoint_prefix, global_step=current_step)</div><div class="line">        print(&quot;Saved model checkpoint to &#123;&#125;\n&quot;.format(path))</div></pre></td></tr></table></figure><h2 id="VISUALIZING-RESULTS-IN-TENSORBOARD"><a href="#VISUALIZING-RESULTS-IN-TENSORBOARD" class="headerlink" title="VISUALIZING RESULTS IN TENSORBOARD"></a>VISUALIZING RESULTS IN TENSORBOARD</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.29.14-AM-1024x347.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.27.48-AM-1024x350.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>从上图中我们可以观察到:</p><ul><li>我们的训练 metrics不平滑，因为用的batch sizes很小。如果用大的batches (或者在整个测试集上进行评估)，会得到平滑的线。</li><li>测试集的 accuracy明显比训练集的低，说明网络过拟合了，我们应该用更大的数据集，更强的正则化，更少的模型参数。</li><li>训练集上的 loss 和 accuracy比测试集低的原因是用了dropout.</li></ul><h1 id="参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow"><a href="#参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow" class="headerlink" title="参考：http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/"></a>参考：<a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="external">http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;CNN实现文本分类的原理&quot;&gt;&lt;a href=&quot;#CNN实现文本分类的原理
      
    
    </summary>
    
    
      <category term="TensorFlow" scheme="https://edward7zhang.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>实验室招新题目②</title>
    <link href="https://edward7zhang.github.io/2018/05/08/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE(2)/"/>
    <id>https://edward7zhang.github.io/2018/05/08/实验室招新题目(2)/</id>
    <published>2018-05-08T10:00:07.000Z</published>
    <updated>2018-05-08T16:09:44.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="火车装箱"><a href="#火车装箱" class="headerlink" title="火车装箱"></a>火车装箱</h1><hr><h2 id="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"><a href="#现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车" class="headerlink" title="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"></a>现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车</h2><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul><li>其中每节车厢中包含两种元素 车厢号：<code>TrainNum</code> 以及所装载货物数量：<code>GoodsNum</code>；</li><li>其中每节车厢以<code>前车厢</code> -&gt; <code>后车厢</code> 的形式进行连接；</li><li>按照每节车厢的<code>GoodsNum</code>的降序进行连接；</li><li><p>自定义一个<code>TrainCabin</code>数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span>&#123;</span></div><div class="line"></div><div class="line"><span class="comment">//TODO structure your struct</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>写出一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin* TrainList)</span></span>;</div><div class="line"><span class="comment">//选择你认为时间复杂度最小的算法进行编码</span></div></pre></td></tr></table></figure></li></ul><blockquote><p>返回值为已按照以上要求排好序后的火车链表</p></blockquote><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>第一个值为<code>TrainNum</code></li><li>第二个值为<code>GoodsNum</code></li><li>中间以<code>|</code>分割</li><li>输入<code>-1</code> 以结束输入</li></ul><h3 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h3><pre><code>1 | 32 | 53 | 74 | 25 | 0-1</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>在控制台中打印排好序的火车列</li><li>按照以下示例格式</li></ul><h3 id="Output："><a href="#Output：" class="headerlink" title="Output："></a>Output：</h3><pre><code>| 3 | 7 | -&gt; | 2 | 5 | -&gt; | 1 | 3 | -&gt; | 4 | 2 | -&gt; | 5 | 0 |</code></pre><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>非常基础的一道考察数据抽象、数据结构构造、排序算法、单向链表的简单题…但今天的现场情况不容乐观<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum;</div><div class="line"><span class="keyword">int</span> GoodsNum;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span> *<span class="title">next</span>;</span></div><div class="line">&#125;TrainCabin;</div><div class="line"></div><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line">TrainCabin *i=TrainList;</div><div class="line">TrainCabin *j;</div><div class="line">TrainCabin *temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"><span class="keyword">while</span>(i!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">j=i-&gt;next;</div><div class="line"><span class="keyword">while</span>(j!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>((*i).GoodsNum&gt;(*j).GoodsNum)</div><div class="line">&#123;</div><div class="line">(*temp).TrainNum=(*i).TrainNum;</div><div class="line">(*temp).GoodsNum=(*i).GoodsNum;</div><div class="line">(*i).TrainNum=(*j).TrainNum;</div><div class="line">(*i).GoodsNum=(*j).GoodsNum;</div><div class="line">(*j).TrainNum=(*temp).TrainNum;</div><div class="line">(*j).GoodsNum=(*temp).GoodsNum;</div><div class="line">&#125;</div><div class="line">j=j-&gt;next;</div><div class="line">&#125;</div><div class="line">i=i-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> TrainList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span>(TrainList-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"| -&gt; "</span>;</div><div class="line">TrainList=TrainList-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum=<span class="number">0</span>,GoodsNum=<span class="number">0</span>;</div><div class="line">TrainCabin *frist,*last;</div><div class="line">TrainCabin *temp;</div><div class="line">frist=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">frist-&gt;next=<span class="literal">NULL</span>;</div><div class="line">last=frist;</div><div class="line"><span class="keyword">char</span> input;</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;TrainNum;</div><div class="line"><span class="keyword">if</span>(TrainNum==<span class="number">-1</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;input;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;GoodsNum;</div><div class="line"></div><div class="line">temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;TrainNum=TrainNum;</div><div class="line">temp-&gt;GoodsNum=GoodsNum;</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line">last-&gt;next=temp;</div><div class="line">last=temp;</div><div class="line">&#125;</div><div class="line">TrainCabin *result=AssembleTraninCabin((*frist).next);</div><div class="line">display(result);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;火车装箱&quot;&gt;&lt;a href=&quot;#火车装箱&quot; class=&quot;headerlink&quot; title=&quot;火车装箱&quot;&gt;&lt;/a&gt;火车装箱&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车&quot;&gt;&lt;a href=&quot;#现有一批火车车厢需要按
      
    
    </summary>
    
    
      <category term="Lab_Interview" scheme="https://edward7zhang.github.io/tags/Lab-Interview/"/>
    
  </entry>
  
  <entry>
    <title>后生可畏</title>
    <link href="https://edward7zhang.github.io/2018/05/06/%E5%90%8E%E7%94%9F%E5%8F%AF%E7%95%8F/"/>
    <id>https://edward7zhang.github.io/2018/05/06/后生可畏/</id>
    <published>2018-05-06T15:20:07.000Z</published>
    <updated>2018-05-06T15:44:43.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Take-your-Child-to-work-Day-at-Google-2018"><a href="#Take-your-Child-to-work-Day-at-Google-2018" class="headerlink" title="Take your Child to work Day at Google 2018"></a>Take your Child to work Day at Google 2018</h1><iframe width="600" height="337.3" src="https://www.youtube.com/embed/2nWkYwC2XHI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>When I heared a kid who Firmly said I will be a video game programmer, I realize that it is extraordinary.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Take-your-Child-to-work-Day-at-Google-2018&quot;&gt;&lt;a href=&quot;#Take-your-Child-to-work-Day-at-Google-2018&quot; class=&quot;headerlink&quot; title=&quot;Take you
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Fragment Navigation Drawer</title>
    <link href="https://edward7zhang.github.io/2018/05/05/Fragment%20Navigation%20Drawer/"/>
    <id>https://edward7zhang.github.io/2018/05/05/Fragment Navigation Drawer/</id>
    <published>2018-05-05T14:20:07.000Z</published>
    <updated>2018-05-05T15:28:55.945Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://camo.githubusercontent.com/6d366e1a5c41a4fc25432102224848023987a8f8/68747470733a2f2f692e6c6f6c692e6e65742f323031382f30352f30352f356165643265643962393236632e706e67" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>..最近这段时间在着手做一个<a href="https://github.com/Edward7Zhang/Sorry-AndroidClient" target="_blank" rel="external">开源项目</a>..使用新鲜的Kotlin以及Google最经典的MaterialDesign..由于刚开始使用自然会碰到很多坑..上面是我的项目Logo🤣<br>本篇文章重点讲解最经典的MaterialDesign中的抽屉式布局 <a href="http://developer.android.com/training/implementing-navigation/nav-drawer.html" target="_blank" rel="external">Navigation Drawer</a>虽然AndroidStudio已经集成了Sample但跟手复现一遍还是很受益的。</p></blockquote><p>在2015年I/O大会上..Google发布了NavigationView，与之前的官方文档相比，本文档更容易创建完整的抽屉式布局<br>随着Android 5.0 Lollipop的发布，新的材料设计风格的抽屉横跨屏幕的整个高度，并显示在<code>ActionBar</code>半透明的上方并重叠<code>StatusBar</code>。<br>Like this：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/hPOFJUf.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>本指南将介绍如何建立一个基于MaterialDesign的可以切换不同Fragment到内容区域的抽屉式导航。In this way,you can define multiple fragments, and then define the list of options which will display in the drawers items list. Each item when clicked will switch the relevant fragment into the activity’s container view.</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>Make sure to setup the Google Design Support Library before using Google’s new NavigationView,announced as part of the Android M release. The NavigationView should be backwards compatible with all versions down to Android 2.1.</p><p>Make sure you have this Gradle dependency added to your <code>app/build.gradle</code> file:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.android.support:design:27.1.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Setup Drawer Resources</p><p>Create a <code>menu/drawer_view.xml</code> file:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_first_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_one"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"First"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_second_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_two"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"Second"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_third_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_three"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"Third"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Note that you can set one of these elements to be default selected by using <code>android:checked=&quot;true&quot;</code> .</p><p>You can also create subheaders too and group elements together:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:title</span>=<span class="string">"Sub items"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">                    <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_dashboard"</span></div><div class="line">                    <span class="attr">android:title</span>=<span class="string">"Sub item 1"</span> /&gt;</div><div class="line">                <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">                    <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_forum"</span></div><div class="line">                    <span class="attr">android:title</span>=<span class="string">"Sub item 2"</span> /&gt;</div><div class="line">            <span class="tag">&lt;/<span class="name">group</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/zoDqDKM.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Define-Fragments"><a href="#Define-Fragments" class="headerlink" title="Define Fragments"></a>Define Fragments</h3><p>接下来，你需要来定义你的Fragments，这些Fragments将会显示在你的Activity中。<br>These can be any support fragments you define within your application. Make sure that all the fragments extend from <strong>android.support.v4.app.Fragment</strong>.</p><h3 id="Setup-Toolbar"><a href="#Setup-Toolbar" class="headerlink" title="Setup Toolbar"></a>Setup Toolbar</h3><p>In order to slide our navigation drawer over the ActionBar, we need to use the new Toolbar widget as defined in the AppCompat v21 library.The <code>Toolbar</code> can be embedded into your view hierarchy which makes sure that the drawer slides over the <code>ActionBar</code>.</p><p>Create a new layout file <code>res/layout/toolbar.xml</code> with the following code:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">    <span class="attr">android:minHeight</span>=<span class="string">"?attr/actionBarSize"</span></div><div class="line">    <span class="attr">app:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimaryDark"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Note that when the <code>android:fitsSystemWindows</code> attribute is set to true for a view, the view would be laid out as if the <code>StatusBar</code> and the <code>ActionBar</code> were present i.e. the UI on top gets padding enough to not be obscured by the navigation bar. Without this attribute, there is not enough padding factored into consideration for the <code>ToolBar</code>:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/HaOAmoh.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>We want our main content view to have the navigation bar and hence <code>android:fitsSystemWindows</code> is set to true for the <code>Toolbar</code>.</p><p>To use the <code>Toolbar</code> as an <code>ActionBar</code>, you need to disable the default <code>ActionBar</code>. This can be done by setting the app theme in <code>styles.xml</code> file.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="xml"></span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#673AB7<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>#512DA8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>Also note that normally you should decide on your color scheme by going to <a href="http://www.materialpalette.com/" target="_blank" rel="external">Material Palette</a> and choosing a primary and dark primary color. For this example, we will pick purple-based colors as shown in the screenshot.</p><p><em>Note</em>: If you forget to disable the ActionBar in <code>styles.xml</code>, you are likely to see a <code>java.lang.IllegalStateException</code> with an error message that reads <code>This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead.</code>If you see this message, you need to make sure to follow the previous steps.</p><h3 id="Setup-Drawer-in-Activity"><a href="#Setup-Drawer-in-Activity" class="headerlink" title="Setup Drawer in Activity"></a>Setup Drawer in Activity</h3><p>Next, let’s setup a basic navigation drawer based on the following layout file which has the entire drawer setup in <code>res/layout/activity_main.xml</code>. Note that the <code>Toolbar</code> is added as the first child of the main content view by adding the include tag. <em>Note: if you are using a CoordinatorLayout, it must not lie outside of the DrawerLayout. See <a href="https://stackoverflow.com/questions/32523188/coordinatorlayout-appbarlayout-navigationdrawer" target="_blank" rel="external">https://stackoverflow.com/questions/32523188/coordinatorlayout-appbarlayout-navigationdrawer</a></em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- This DrawerLayout has two children at the root  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- This LinearLayout represents the contents of the screen  --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The ActionBar displayed at the top --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span></span></div><div class="line">            <span class="attr">layout</span>=<span class="string">"@layout/toolbar"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The main content view where fragments are loaded --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/flContent"</span></div><div class="line">            <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- The navigation drawer that comes from the left --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Note that `android:layout_gravity` needs to be set to 'start' --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/nvView"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span></div><div class="line">        <span class="attr">app:menu</span>=<span class="string">"@menu/drawer_view"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>Now, let’s setup the drawer in our activity. We can also setup the menu icon too.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> DrawerLayout mDrawer;</div><div class="line">  <span class="keyword">private</span> Toolbar toolbar;</div><div class="line"> <span class="keyword">private</span> NavigationView nvDrawer;</div><div class="line"></div><div class="line">  <span class="comment">// Make sure to be using android.support.v7.app.ActionBarDrawerToggle version.</span></div><div class="line"></div><div class="line"> <span class="comment">// The android.support.v4.app.ActionBarDrawerToggle has been deprecated.</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> ActionBarDrawerToggle drawerToggle;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="comment">// Set a Toolbar to replace the ActionBar.</span></div><div class="line"></div><div class="line">        toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">        setSupportActionBar(toolbar);</div><div class="line"></div><div class="line">        <span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">        mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">        <span class="comment">// The action bar home/up action should open or close the drawer.</span></div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (item.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> android.R.id.home:</div><div class="line">                mDrawer.openDrawer(GravityCompat.START);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Navigating-between-Menu-Items"><a href="#Navigating-between-Menu-Items" class="headerlink" title="Navigating between Menu Items"></a>Navigating between Menu Items</h3><p>Setup a handler to respond to click events on the navigation elements and swap out the fragment. This can be put into the activity directly:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...From section above...</span></div><div class="line"></div><div class="line">        <span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">        nvDrawer = (NavigationView) findViewById(R.id.nvView);</div><div class="line">        <span class="comment">// Setup drawer view</span></div><div class="line"></div><div class="line">        setupDrawerContent(nvDrawer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupDrawerContent</span><span class="params">(NavigationView navigationView)</span> </span>&#123;</div><div class="line">        navigationView.setNavigationItemSelectedListener(</div><div class="line">                <span class="keyword">new</span> NavigationView.OnNavigationItemSelectedListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</div><div class="line">                        selectDrawerItem(menuItem);</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectDrawerItem</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</div><div class="line">        <span class="comment">// Create a new fragment and specify the fragment to show based on nav item clicked</span></div><div class="line"></div><div class="line">        Fragment fragment = <span class="keyword">null</span>;</div><div class="line">        Class fragmentClass;</div><div class="line">        <span class="keyword">switch</span>(menuItem.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.nav_first_fragment:</div><div class="line">                fragmentClass = FirstFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.nav_second_fragment:</div><div class="line">                fragmentClass = SecondFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.nav_third_fragment:</div><div class="line">                fragmentClass = ThirdFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                fragmentClass = FirstFragment.class;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fragment = (Fragment) fragmentClass.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Insert the fragment by replacing any existing fragment</span></div><div class="line"></div><div class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</div><div class="line">        fragmentManager.beginTransaction().replace(R.id.flContent, fragment).commit();</div><div class="line"></div><div class="line">        <span class="comment">// Highlight the selected item has been done by NavigationView</span></div><div class="line"></div><div class="line">        menuItem.setChecked(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// Set action bar title</span></div><div class="line"></div><div class="line">        setTitle(menuItem.getTitle());</div><div class="line">        <span class="comment">// Close the navigation drawer</span></div><div class="line"></div><div class="line">        mDrawer.closeDrawers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Add-Navigation-Header"><a href="#Add-Navigation-Header" class="headerlink" title="Add Navigation Header"></a>Add Navigation Header</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/Ri3c6Xz.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>The NavigationView also accepts a custom attribute that can reference a layout that provides a header of our layout. For instance, you can create a <code>layout/nav_header.xml</code> similar to the following:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"192dp"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimaryDark"</span></div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"16dp"</span></div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">    <span class="attr">android:gravity</span>=<span class="string">"bottom"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Header"</span></div><div class="line">        <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span></div><div class="line">        <span class="attr">android:textAppearance</span>=<span class="string">"@style/TextAppearance.AppCompat.Body1"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>You would then reference this in the layout <code>res/layout/activity_main.xml</code> in the <code>NavigationView</code> with the <code>app:headerLayout</code> custom attribute:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- res/layout/activity_main.xml --&gt;</span></div><div class="line"></div><div class="line"> <span class="comment">&lt;!-- The navigation drawer --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></div><div class="line">        <span class="attr">...</span></div><div class="line">        <span class="attr">app:headerLayout</span>=<span class="string">"@layout/nav_header"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.NavigationView</span>&gt;</span></div></pre></td></tr></table></figure><p>This <code>app:headerLayout</code> inflates the specified layout into the header automatically. This can alternatively be done at runtime with:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Lookup navigation view</span></div><div class="line"></div><div class="line">NavigationView navigationView = (NavigationView) findViewById(R.id.nav_draw);</div><div class="line"><span class="comment">// Inflate the header view at runtime</span></div><div class="line"></div><div class="line">View headerLayout = navigationView.inflateHeaderView(R.layout.nav_header);</div><div class="line"><span class="comment">// We can now look up items within the header if needed</span></div><div class="line"></div><div class="line">ImageView ivHeaderPhoto = headerLayout.findViewById(R.id.imageView);</div></pre></td></tr></table></figure><h3 id="Getting-references-to-the-header"><a href="#Getting-references-to-the-header" class="headerlink" title="Getting references to the header"></a>Getting references to the header</h3><p><strong>Note:</strong> Version <code>23.1.0</code> of the design support library switches <code>NavigationView</code> to using a <code>RecyclerView</code> and causes NPE (null exceptions) on header lookups unless the header is added at runtime. If you need to get a reference to the header, you need to use the new <code>getHeaderView()</code>method introduced in the latest <code>v23.1.1</code> update:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// There is usually only 1 header view.  </span></div><div class="line"></div><div class="line"><span class="comment">// Multiple header views can technically be added at runtime.</span></div><div class="line"></div><div class="line"><span class="comment">// We can use navigationView.getHeaderCount() to determine the total number.</span></div><div class="line"></div><div class="line">View headerLayout = navigationView.getHeaderView(<span class="number">0</span>);</div></pre></td></tr></table></figure><h2 id="动画汉堡图标"><a href="#动画汉堡图标" class="headerlink" title="动画汉堡图标"></a>动画汉堡图标</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/ekmWl7q.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了让汉堡包图标动画显示抽屉正在打开和关闭，我们需要使用<a href="https://developer.android.com/reference/android/support/v7/app/ActionBarDrawerToggle.html" target="_blank" rel="external">ActionBarDrawerToggle</a>类。</p><p>在你的<code>res/values/strings.xml</code>添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"drawer_open"</span>&gt;</span>Open navigation drawer<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"drawer_close"</span>&gt;</span>Close navigation drawer<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>我们需要将DrawerLayout和工具栏结合在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; </div><div class="line"><span class="comment">// Set a Toolbar to replace the ActionBar.</span></div><div class="line"></div><div class="line">toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">setSupportActionBar(toolbar);</div><div class="line"></div><div class="line"><span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);</div><div class="line">drawerToggle = setupDrawerToggle();</div><div class="line"></div><div class="line"><span class="comment">// Tie DrawerLayout events to the ActionBarToggle</span></div><div class="line"></div><div class="line">mDrawer.addDrawerListener(drawerToggle);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> ActionBarDrawerToggle <span class="title">setupDrawerToggle</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// <span class="doctag">NOTE:</span> Make sure you pass in a valid toolbar reference.  ActionBarDrawToggle() does not require it</span></div><div class="line"></div><div class="line">      <span class="comment">// and will not render the hamburger icon without it.  </span></div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, mDrawer, toolbar, R.string.drawer_open,  R.string.drawer_close);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>接下来，我们需要确保在恢复屏幕或配置发生变化（即屏幕旋转）时同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `onPostCreate` called when activity start-up is complete after `onStart()`</span></div><div class="line"></div><div class="line"><span class="comment">// NOTE 1: Make sure to override the method with only a single `Bundle` argument</span></div><div class="line"></div><div class="line"><span class="comment">// Note 2: Make sure you implement the correct `onPostCreate(Bundle savedInstanceState)` method. </span></div><div class="line"></div><div class="line"><span class="comment">// There are 2 signatures and only `onPostCreate(Bundle state)` shows the hamburger icon.</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onPostCreate(savedInstanceState);</div><div class="line">    <span class="comment">// Sync the toggle state after onRestoreInstanceState has occurred.</span></div><div class="line"></div><div class="line">    drawerToggle.syncState();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</div><div class="line">    <span class="comment">// Pass any configuration change to the drawer toggles</span></div><div class="line"></div><div class="line">    drawerToggle.onConfigurationChanged(newConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们还需要更改<code>onOptionsItemSelected()</code>方法并允许ActionBarToggle处理事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (drawerToggle.onOptionsItemSelected(item)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ActionBarToggle将执行与先前完成的功能相同的功能，但会添加更多检查，并允许鼠标​​单击图标以打开和关闭抽屉。有关更多上下文，请参阅<a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/src/android/support/v7/app/ActionBarDrawerToggle.java#L285-291" target="_blank" rel="external">源代码</a>。</p><p>有一点需要注意的是，ActionBarDrawerToggle会为您呈现汉堡图标的自定义<a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/src/android/support/v7/graphics/drawable/DrawerArrowDrawable.java" target="_blank" rel="external">DrawerArrowDrawable</a>。</p><p>另外，请确保使用的<code>android.support.v7.app.ActionBarDrawerToggle</code>版本。在<code>android.support.v4.app.ActionBarDrawerToggle</code>已被弃用。</p><h2 id="使状态栏半透明"><a href="#使状态栏半透明" class="headerlink" title="使状态栏半透明"></a>使状态栏半透明</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/o4WvT3k.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要使状态栏变成半透明状态并让我们的抽屉滑过它，我们需要将其设置<code>android:windowTranslucentStatus</code>为true。由于此样式不适用于之前的Kitkat设备，因此我们将为<code>res/values-v19/styles.xml</code>API版本19及之后的版本添加 文件。 <strong>注意</strong>：如果<code>res/values/styles.xml</code>直接用此<code>android:windowTranslucentStatus</code>行修改，则可能需要构建仅适用于19或更高版本的SDK，这显然会限制您支持许多较旧的设备。</p><p>在<code>res/values-v19/styles.xml</code>我们可以添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- Base application theme. --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="xml"></span></div><div class="line">    <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>现在，如果你运行你的应用程序，你应该看到导航抽屉，并能够在你的片段之间进行选择。</p><h2 id="将自定义视图添加到导航抽屉"><a href="#将自定义视图添加到导航抽屉" class="headerlink" title="将自定义视图添加到导航抽屉"></a>将自定义视图添加到导航抽屉</h2><p>对设计支持库23.1.0所做的一项改进是增加了对导航抽屉项目的自定义视图的支持。例如，我们可以为其中一行创建自定义开关，如Google Play电影的导航抽屉：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/gCgB5PQ.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>该方法与将<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-actionview-items" target="_blank" rel="external">ActionView项目</a>添加到ActionBar相同。我们只需要定义一个单独的布局，如下面的代码片段。我们将调用这个文件<code>action_view_switch.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.SwitchCompat</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Switch"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>然后，我们使用该<code>app:actionLayout</code>属性引用此布局。标题必须提供，但也可以设置为空白：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_switch"</span></span></div><div class="line">        <span class="attr">app:actionLayout</span>=<span class="string">"@layout/action_view_switch"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"Downloaded only"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure><p>只要您的活动将实施该方法，您就可以直接使用XML附加事件。要通过Java以编程方式将事件处理添加到切换开关，您需要先获取菜单实例并访问相应的ActionView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Menu menu = navigationView.getMenu();</div><div class="line">MenuItem menuItem = menu.findItem(R.id.nav_switch);</div><div class="line">View actionView = MenuItemCompat.getActionView(menuItem);</div><div class="line">actionView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>自定义小部件的使用<code>app:actionViewClass</code>也可以用于菜单项目。有关Action Views的更多详细信息，请参阅将<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-searchview-to-actionbar" target="_blank" rel="external">SearchView</a>添加<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-searchview-to-actionbar" target="_blank" rel="external">到ActionBar</a>指南。</p><h2 id="持久导航抽屉"><a href="#持久导航抽屉" class="headerlink" title="持久导航抽屉"></a>持久导航抽屉</h2><p>在某些情况下，特别是在平板电脑上，导航抽屉应该是充当侧栏的活动的永久固定装置(Like my Blog Design)：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/9f7nyrA.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要达到此效果，请查看以下描述一种方法的链接：</p><ul><li><a href="http://derekrwoods.com/2013/09/creating-a-static-navigation-drawer-in-android/" target="_blank" rel="external">静态导航抽屉</a></li><li><a href="http://stackoverflow.com/a/18095111" target="_blank" rel="external">相关的Stackoverflow问题</a></li><li><a href="https://github.com/samerzmd/Navigation-Drawer-set-as-always-opened-on-tablets" target="_blank" rel="external">示例代码</a></li></ul><p>第三方库也可能使这更容易实现。</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>有一些第三方库仍然可以作为<code>DrawerLayout</code>直接使用自动提供某些材料设计元素的替代方案：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/6WHIEX5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="external">MaterialDrawer</a></li><li><a href="https://github.com/rudsonlive/NavigationDrawer-MaterialDesign" target="_blank" rel="external">NavigationDrawerMaterial</a></li></ul><p>通常这些都是不必要的，但请检查它们以查看它们提供的功能。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>设计支持库的当前版本的确有其局限性。主要问题在于突出显示导航菜单中的当前项目的系统。NavigationView的itemBackground属性不能正确处理项目的选中状态：不管怎样，所有项目都突出显示或者没有任何项目。这使得这个属性基本上不适用于大多数应用程序。</p><h2 id="Fragment的替代品"><a href="#Fragment的替代品" class="headerlink" title="Fragment的替代品"></a>Fragment的替代品</h2><p>虽然许多导航抽屉示例显示了如何将Fragment用于导航抽屉，但如果您希望将抽屉用作当前显示的活动的叠加层，也可以使用<code>RelativeLayout</code>/ <code>LinearLayout</code>。</p><p>而不是<code>&lt;FrameLayout&gt;</code>你可以用一个<code>&lt;LinearLayout&gt;</code>替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">                <span class="attr">android:id</span>=<span class="string">"@+id/content_frame"</span></div><div class="line">                <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The navigation drawer --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">android:id</span>=<span class="string">"@+id/left_drawer"</span></span></div><div class="line">                  <span class="attr">android:layout_width</span>=<span class="string">"240dp"</span></div><div class="line">                  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">                  <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></div><div class="line">                  <span class="attr">android:choiceMode</span>=<span class="string">"singleChoice"</span></div><div class="line">                  <span class="attr">android:divider</span>=<span class="string">"@android:color/transparent"</span></div><div class="line">                  <span class="attr">android:dividerHeight</span>=<span class="string">"0dp"</span></div><div class="line">                  <span class="attr">android:background</span>=<span class="string">"#111"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>取而代之的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Insert the fragment by replacing any existing fragment</span></div><div class="line"></div><div class="line">getFragmentManager().beginTransaction()</div><div class="line">       .replace(R.id.content_frame, fragment)</div><div class="line">       .commit();</div></pre></td></tr></table></figure><p>您可以改为使用<code>LinearLayout</code>容器直接为活动充气：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LayoutInflater inflater = getLayoutInflater();</div><div class="line">LinearLayout container = (LinearLayout) findViewById(R.id.content_frame);</div><div class="line">inflater.inflate(R.layout.activity_main, container);</div></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html" target="_blank" rel="external">http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html</a></li><li><a href="http://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st" target="_blank" rel="external">http://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st</a></li><li><a href="http://antonioleiva.com/navigation-view/" target="_blank" rel="external">http://antonioleiva.com/navigation-view/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Material Design" scheme="https://edward7zhang.github.io/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>实验室招新题目①</title>
    <link href="https://edward7zhang.github.io/2018/04/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE/"/>
    <id>https://edward7zhang.github.io/2018/04/27/实验室招新题目/</id>
    <published>2018-04-27T10:00:07.000Z</published>
    <updated>2018-05-07T16:02:13.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摇篮排序"><a href="#摇篮排序" class="headerlink" title="摇篮排序"></a>摇篮排序</h1><h2 id="输入摇篮数组以摇篮中的序号为基准进行排序"><a href="#输入摇篮数组以摇篮中的序号为基准进行排序" class="headerlink" title="输入摇篮数组以摇篮中的序号为基准进行排序"></a>输入摇篮数组以摇篮中的序号为基准进行排序</h2><h2 id="请自定义Bucket的数据结构包括"><a href="#请自定义Bucket的数据结构包括" class="headerlink" title="请自定义Bucket的数据结构包括"></a>请自定义Bucket的数据结构包括</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;序号&#125;,&#123;学科&#125;&#125;</div></pre></td></tr></table></figure><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul><li><p>写出一个方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bucket[] sortBucket(Bucket[] J,boolean Flag)</div></pre></td></tr></table></figure></li><li><p>返回为排好序后的Bucket数组并在控制台中答应</p></li><li>Flag == true返回正序排序</li><li>Flag == false返回倒序排序</li></ul><h1 id="面向大一同学要求："><a href="#面向大一同学要求：" class="headerlink" title="面向大一同学要求："></a>面向大一同学要求：</h1><h2 id="在控制台中输入Bucket数组"><a href="#在控制台中输入Bucket数组" class="headerlink" title="在控制台中输入Bucket数组"></a>在控制台中输入Bucket数组</h2><h2 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h2><h2 id="input"><a href="#input" class="headerlink" title="input:"></a>input:</h2><ul><li>1 数学</li><li>3 语文</li><li>2 英语</li><li>true<h2 id="output"><a href="#output" class="headerlink" title="output:"></a>output:</h2></li><li>1 数学</li><li>2 英语</li><li>3 语文</li></ul><h1 id="面向大二同学要求："><a href="#面向大二同学要求：" class="headerlink" title="面向大二同学要求："></a>面向大二同学要求：</h1><h2 id="构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮"><a href="#构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮" class="headerlink" title="构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮"></a>构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮</h2><h2 id="在其中输入Bucket数组"><a href="#在其中输入Bucket数组" class="headerlink" title="在其中输入Bucket数组"></a>在其中输入Bucket数组</h2><h2 id="example：-1"><a href="#example：-1" class="headerlink" title="example："></a>example：</h2><h2 id="input-1"><a href="#input-1" class="headerlink" title="input:"></a>input:</h2><ul><li>1 数学</li><li>3 语文</li><li>2 英语<h2 id="output-1"><a href="#output-1" class="headerlink" title="output:"></a>output:</h2></li><li>1 数学</li><li>2 英语</li><li>3 语文</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摇篮排序&quot;&gt;&lt;a href=&quot;#摇篮排序&quot; class=&quot;headerlink&quot; title=&quot;摇篮排序&quot;&gt;&lt;/a&gt;摇篮排序&lt;/h1&gt;&lt;h2 id=&quot;输入摇篮数组以摇篮中的序号为基准进行排序&quot;&gt;&lt;a href=&quot;#输入摇篮数组以摇篮中的序号为基准进行排序&quot; cla
      
    
    </summary>
    
    
      <category term="Lab_Interview" scheme="https://edward7zhang.github.io/tags/Lab-Interview/"/>
    
  </entry>
  
  <entry>
    <title>三年三月三天三小时</title>
    <link href="https://edward7zhang.github.io/2018/04/27/%E4%B8%89%E5%B9%B4%E4%B8%89%E6%9C%88%E4%B8%89%E5%A4%A9%E4%B8%89%E5%B0%8F%E6%97%B6/"/>
    <id>https://edward7zhang.github.io/2018/04/27/三年三月三天三小时/</id>
    <published>2018-04-26T17:42:07.000Z</published>
    <updated>2018-04-27T07:52:55.006Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" marginwidth="0" marginheight="0" width="300" height="50" src="https://music.163.com/outchain/player?type=2&id=1218773&auto=0&height=32"></iframe></p><h1 id="2018-04-26-14-27-👨‍💻"><a href="#2018-04-26-14-27-👨‍💻" class="headerlink" title="2018.04.26/14:27 👨‍💻"></a>2018.04.26/14:27 👨‍💻</h1><h3 id="我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。"><a href="#我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。" class="headerlink" title="我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。"></a>我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。</h3><h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p>我的价值终于得到了认可…<strong>前20年的知识积奠..后3年的专业浅触..以及3个月来的准备..还有近3天以来的焦虑..最终是拿到Offer前3小时的不镇定</strong>…也许这种过程正是我踏入社会的开始以及最重要的是可以在我梦寐的大平台上开拓自己的视野强化自己的专业知识…这一切也来源于我3年以来的不懈…但更值得感谢的是我的伯乐–我的专业引路人刘老师和班导严老师在这三年来的照料与解惑…反观我三年前刚入校的木讷与轻浮..到现在可以负责实验室..以及得到社会的认可这一路来没有他们的指引我也许还在自己的混沌中不能自拔…<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c7ffc33f5.png" alt="My favorite mural Creazione di Adamo by Michelangelo" title="">                </div>                <div class="image-caption">My favorite mural Creazione di Adamo by Michelangelo</div>            </figure></p><ul><li><p>我也曾愣头青…在还未准备充分就冲去面试阿里…连续挂掉两次的腾讯面试…以及没有音讯的美团…到现在我心心念的还在等结果的大疆…以及我已拿到实习Offer的爱奇艺…</p></li><li><p>拿到Offer的我一点也没有激动…只是让我千疮百孔的心得到了一点满足…</p></li><li><p>在这一路的面试经历中我发现，我最终收益的还是我对专业的坚持…始终没有放弃我热爱的Android移动端开发..当出现新的技术..我总是首先想到应用于移动端…至少这种原力式的驱动来自于我的世界观..我认为在这个时代互联网的最大作用应该是带动人类发展进步..即使如今是个百家合唱的互联网环境..更多的企业选择了推动经济的捞钱式行为…大量的研发资源用于对娱乐或是低俗文化的传播…使得如今都是面向上市敲钟式创业…</p></li><li><p>异曲同工的是最近在年级群中看到有已面50家公司拿到3个Offer的人却大言不惭的写着面经..教唆想去参加工作的同学若是没有项目去某宝花钱购买…纯粹的面向面试的编程令人感到恶俗…地球科技的进步如果存在很多这样的人简直不堪想象吧…</p></li><li><p>如今这个时代有点伪文艺复兴的感觉…好像世间很纷乱…不是那么安定…但大家好像还过得自得其乐…这种自杀式的习惯在一点点的吞噬人类心灵最后的进取…</p></li></ul><h1 id="三年-👹"><a href="#三年-👹" class="headerlink" title="三年 👹"></a>三年 👹</h1><p>大学这三年来其实是憋了一口气的去追赶我高中三年所遗失的种种<br>三年后再看我倒是追回来了一些..这是值得肯定的<br>至少我没有被世俗赶上..至少我暂时赢得了自己的认可</p><h1 id="伯乐-🐎"><a href="#伯乐-🐎" class="headerlink" title="伯乐 🐎"></a>伯乐 🐎</h1><blockquote><p>世有伯乐，然后有千里马。千里马常有，而伯乐不常有。<br>我是一个傲慢的自谦的，不易被他人压制的，向往自由的人。</p></blockquote><p>这三年来我真心的感谢我的班导严灵毓老师、我的计算机语言入门人刘伟老师。<br>是他们的慧眼给了我进升的平台。<br>这两位老师的性格迥异对我来说是非常受益的…</p><ul><li>其一、那种对学生的关怀与学术上、人生上大义至简的指导与沟通是让我摆脱各种木讷与混沌的唯一绳索。</li><li>另一位、那种随性的不羁的帅气的男性风格成为了我对男性理解的标榜…作为我项目指导老师对我的信任，直接影响了我之后对软件产品的看法与理解…将项目大意解释与学生，其他的可以自我发挥的做法，至少目前我没有在其他老师身上发现过…这种对学生的信任同样也是让我辗转各种实验室后最终又回到Lab603的唯一理由…</li></ul><p>现在再回头看看这三年…充实又充满回忆…</p><h1 id="开发者同伴-😎"><a href="#开发者同伴-😎" class="headerlink" title="开发者同伴 😎"></a>开发者同伴 😎</h1><blockquote><p>如果拿伯牙与钟子期的故事来说我们可能过头..其实我们也没有到那种境界…只是想用这种感觉来表达我这三年来对他的感谢，他与我共同开发了我这三年来的大部分项目…</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c382bbaeb.jpg" alt="2016年10月12日 星期三 23:22 张睿在我的宿舍里一起重构项目看到结果后的喜悦" title="">                </div>                <div class="image-caption">2016年10月12日 星期三 23:22 张睿在我的宿舍里一起重构项目看到结果后的喜悦</div>            </figure><p>这三年来不下10个大大小小的项目其中2/3都是我和他共同开发的…无数个通宵..无数个需求的争执无数个问题的解决…在这一系列的过程中如果没有这样一个人的存在又会变得有多大的挑战呢？<br>我现在只能说张睿这三年来感谢你的互助，没有你我也走不到这一步…我会在这条路继续走下去的…只为了我们那无数个日夜的单纯的梦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2d43e09aaf.jpg" alt="2016年10月16日 星期日 3:11 我们合作的第一个项目OneKey2Alarm肝通宵" title="">                </div>                <div class="image-caption">2016年10月16日 星期日 3:11 我们合作的第一个项目OneKey2Alarm肝通宵</div>            </figure><h1 id="Project-⌨️"><a href="#Project-⌨️" class="headerlink" title="Project ⌨️"></a>Project ⌨️</h1><blockquote><p>项目之于开发者如同父与子的关系</p></blockquote><p>相信每一个开发者在完成他的Project后都会加倍心力的去维护他的Project…在这过程中也同时是开发者经验能力提升的关键…所以在面试过程中每个开发者在他过去完成的项目质量与数量就显得格外宝贵..通过项目的侧面观察可以看得出一个人的代码风格..他的个性..他的为人…所以如上文所述的那种面向面试的编程方式是我个人非常厌恶的…我认为只要是一个有追求的开发者..一个合格的程序员都十分摒弃这种做法…通过获取他人的劳动成果来打肿脸充胖子..总有一天会败露的。<br>真诚是一个人最美好也是最底线的品质…如果你想让这个世界达到公平那么久应该人人有责…通过不择手段的方式来通过面试这样对更多优秀的项目开发者无异于是一种侮辱…我周围的同学在最近找工作的过程中没有一个人是轻松的…一家家公司一次次的拒绝到让人怀疑自己…但说实话只有内心强大的人才能冲出这片混沌…因为从此之后你就会脱离象牙塔…不会再有人去庇护你…你要面对的是狰狞而残酷的社会..要为自己的言行负责了…人人不易…唯有坚持才能冲破重围…</p><blockquote><p>在这里同时想感谢我未来的部门领导..是他对我的认可..我才直接的得到了这一提升自己视野的机会…我会向自己证明他并没有看错</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c508827c3.jpg" alt="2018.04 武汉春季Hackthon" title="">                </div>                <div class="image-caption">2018.04 武汉春季Hackthon</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c50d2c899.jpg" alt="2018.04 凌晨4:00 武汉春季Hackthon" title="">                </div>                <div class="image-caption">2018.04 凌晨4:00 武汉春季Hackthon</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c50919947.jpg" alt="2018.04 武汉春季Hackthon 产品展示" title="">                </div>                <div class="image-caption">2018.04 武汉春季Hackthon 产品展示</div>            </figure><h1 id="家庭-👪"><a href="#家庭-👪" class="headerlink" title="家庭 👪"></a>家庭 👪</h1><ul><li>我拥有这样的家庭应该是我人生走过20年所幸至极之事</li><li>父母对我的关心与爱护适合且得当</li><li>父母对我的放养式管理我称为“不管之恩”这种做法间接的使我自由发展寻我所乐</li><li>父母对我的无条件支持我的选择使我受益</li><li>生于张先生与陈女士是我这一生无可比拟的幸运</li></ul><p>感谢我的父母让我度过了无忧的童年、少年..未来世界的狰狞我已经可以独自去面对了，也请你们放心<br>我永远爱你们❤️</p><h1 id="Last-but-not-least-💪"><a href="#Last-but-not-least-💪" class="headerlink" title="Last but not least 💪"></a>Last but not least 💪</h1><p>通过我一次次的失败..经验的积累..也拿到了如愿的Offer…<br>我明白这并不是标榜着什么..而是又一次新的开始..我这长久以来只是在为自己争取去更好的平台学习..发展…<br>在此想给未来的自己说：不要让你之前的努力白费..保持自己的梦想..不要被世俗侵染..保持学习..保持竞争力..切勿自满…</p><blockquote><p>记一个即将步入社会的男生回首过去20年的狰狞与对自己未来的勉励</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c515a6cd2.jpg" alt="Lab603 我的工位 ;-)" title="">                </div>                <div class="image-caption">Lab603 我的工位 ;-)</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;300&quot; height=&quot;50&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=12
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Java与Kotlin下的6种单例模式</title>
    <link href="https://edward7zhang.github.io/2018/04/25/Java%E4%B8%8EKotlin%E4%B8%8B%E7%9A%846%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://edward7zhang.github.io/2018/04/25/Java与Kotlin下的6种单例模式/</id>
    <published>2018-04-25T05:44:14.000Z</published>
    <updated>2018-04-26T11:15:00.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b9b7aa8c2779e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在学习Kotlin，由于Google粑粑把这一语言提携为官方指定，并且对于移动端等开发得天独厚的优势，作为一名AndroidDeveloper学习Kotlin是必要的。<br>当初在学习Java时对单例模式的六种书写与应用记忆深刻<br>所以这次对不同单例模式的Java与Kotlin实现进行了分别探讨。</p></blockquote><p>六种模式如下：</p><ul><li>饿汉模式</li><li>懒汉模式</li><li>线程安全的懒汉模式</li><li>双重校验锁式</li><li>静态内部类式</li><li>枚举式</li></ul><hr><h1 id="饿汉模式：static-final-field"><a href="#饿汉模式：static-final-field" class="headerlink" title="饿汉模式：static final field"></a>饿汉模式：static final field</h1><p>饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。<br>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="comment">//类加载时就初始化</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Kotlin引入了 <code>object</code>类型，可以很容易声明单例模式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="keyword">object</span> Singleton</div></pre></td></tr></table></figure></p><p>这种方式和 Java 单例模式的饿汉式一样，不过比 Java 中的实现代码量少很多，其实是个语法糖（Kotlin漫山遍野都是语法糖）。反编译生成的 class 文件后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        INSTANCE = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从反编译的代码可以看出 object 对象实际上还是利用了 INSTANCE 静态变量，但是在Java和Kotlin混编时，Java代码中调用则需要注意，使用如下<code>Singleton.INSTANCE.test()</code>,Kolint中调用时只需要使用<code>Singleton.test()</code>。<br>这种实现方式在类加载时就创建了单例对象，所以肯定是线程安全的，但是还是有饿汉式实现方式的问题：</p><ul><li>如果构造方法中有耗时操作的话，会导致这个类的加载比较慢。</li><li>饿汉式一开始就创建实例，但是并没有调用，会造成资源浪费。</li><li>还有一个 Java 饿汉式单例模式没有的问题：无法自定义构造函数，object 中不允许 constructor 函数。</li></ul><h1 id="懒汉模式：线程不安全"><a href="#懒汉模式：线程不安全" class="headerlink" title="懒汉模式：线程不安全"></a>懒汉模式：线程不安全</h1><p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance : Singleton? = <span class="literal">null</span></div><div class="line">        <span class="keyword">get</span>()&#123;</div><div class="line">            <span class="keyword">if</span>(field == <span class="literal">null</span>)&#123;</div><div class="line">                field = Singleton()</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> field</div><div class="line">        &#125; </div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>:Singleton&#123;</div><div class="line">            <span class="keyword">return</span> instance!!</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述代码中，我们可以发现在Kotlin实现中，我们让其<strong>主构造函数私有化</strong>并自定义了其<strong>属性访问器</strong>，其余内容大同小异。</p><ul><li>如果不清楚Kotlin构造函数的使用方式。请点击 - - - <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fclasses.html" target="_blank" rel="external">构造函数</a></li><li>不清楚Kotlin的属性与访问器，请点击 - - -<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fproperties.html" target="_blank" rel="external">属性和字段</a></li></ul><h1 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h1><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></div><div class="line">            <span class="keyword">get</span>() &#123;</div><div class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</div><div class="line">                    field = Singleton()</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> field</div><div class="line">            &#125;</div><div class="line">        <span class="meta">@Synchronized</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: Singleton&#123;</div><div class="line">            <span class="keyword">return</span> instance!!</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>大家都知道在使用懒汉式会出现线程安全的问题，需要使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加 <strong>@Synchronized</strong> 注解</p><h1 id="双重校验锁式"><a href="#双重校验锁式" class="headerlink" title="双重校验锁式"></a>双重校验锁式</h1><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * volatile保证了：</div><div class="line"> * 1.instance再多线程下的并发可见性</div><div class="line"> * 2.禁止instance在操作时的指令重排序</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getIntance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="comment">//第一次判空，保证不必要的同步</span></div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line"><span class="comment">//synchronized对Singleton加全局锁，保证每次只要一个线程创建实例</span></div><div class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line"><span class="comment">//第二次判空时为了在null的情况下创建实例</span></div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。<strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><ul><li>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</li></ul><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</div><div class="line">        <span class="keyword">val</span> instance: Singleton <span class="keyword">by</span> lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123;</div><div class="line">            SingletonDemo()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的<strong>延迟属性 Lazy</strong>。</p><p><strong>Lazy</strong>是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</p><p>这里还有有两个额外的知识点。</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Flambdas.html" target="_blank" rel="external">高阶函数</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fdelegated-properties.html" target="_blank" rel="external">委托属性</a></li></ul><p>如果你了解以上知识点，我们直接来看Lazy的内部实现。</p><ul><li>Lazy内部实现</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: ()</span></span> -&gt; T): Lazy&lt;T&gt; =</div><div class="line">        <span class="keyword">when</span> (mode) &#123;</div><div class="line">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</div><div class="line">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</div><div class="line">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>观察上述代码，因为我们传入的<strong>mode = LazyThreadSafetyMode.SYNCHRONIZED</strong>， 那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。</p><ul><li>Lazy接口</li></ul><p>SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lazy</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</div><div class="line">     <span class="comment">//当前实例化对象，一旦实例化后，该对象不会再改变</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</div><div class="line">    <span class="comment">//返回true表示，已经延迟实例化过了，false 表示，没有被实例化，</span></div><div class="line">    <span class="comment">//一旦方法返回true，该方法会一直返回true,且不会再继续实例化</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>继续查看SynchronizedLazyImpl，具体实现如下：</p><ul><li>SynchronizedLazyImpl内部实现</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;</span>(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</div><div class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</div><div class="line">    <span class="comment">// final field is required to enable safe publication of constructed instance</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</div><div class="line">        <span class="keyword">get</span>() &#123;</div><div class="line">            <span class="keyword">val</span> _v1 = _value</div><div class="line">            <span class="comment">//判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑</span></div><div class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></div><div class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</div><div class="line">                <span class="keyword">val</span> _v2 = _value</div><div class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                    <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span> (_v2 <span class="keyword">as</span> T)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">val</span> typedValue = initializer!!()<span class="comment">//调用高级函数获取其返回值</span></div><div class="line">                    _value = typedValue   <span class="comment">//将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值</span></div><div class="line">                    initializer = <span class="literal">null</span></div><div class="line">                    typedValue  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。</p><p>到里这里其实大家还是肯定有疑问，我这里<strong>只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢？</strong>。这里又涉及到了<strong>委托属性</strong>。</p><p>委托属性语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。</p><p>而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@kotlin.internal.InlineOnly</div><div class="line">//返回初始化的值。</div><div class="line">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value</div></pre></td></tr></table></figure><h1 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h1><p>这种方法也是《Effective Java》上所推荐的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种写法仍然使用JVM本身机制保证了线程安全的问题。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，<strong>第一次调用getInstance()时将内部类SingletonHodler</strong>，在该内部类中定义了一个static类型的变量INSTANCE，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于SingletonHodler是私有的，除了getInstance()之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">val</span> instance = SingletonHolder.holder</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">object</span> SingletonHolder &#123;</div><div class="line">        <span class="keyword">val</span> holder= Singleton()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="枚举式：Enum"><a href="#枚举式：Enum" class="headerlink" title="枚举式：Enum"></a>枚举式：Enum</h1><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">EasySingleton</span></span>&#123;</div><div class="line">INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b9b7aa8c2779e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
      <category term="Kotlin" scheme="https://edward7zhang.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>记一次呆若木鸡的面试</title>
    <link href="https://edward7zhang.github.io/2018/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%91%86%E8%8B%A5%E6%9C%A8%E9%B8%A1%E7%9A%84%E9%9D%A2%E8%AF%95/"/>
    <id>https://edward7zhang.github.io/2018/04/24/记一次呆若木鸡的面试/</id>
    <published>2018-04-24T14:24:14.000Z</published>
    <updated>2018-04-24T14:52:45.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一道很简单很简单的入门题…核心就是一个我高中就学过的数学知识…叉积…可惜年久不用…在面试的紧要关头就显得呆若木鸡…很遗憾没有表现出自己的真实水平…</p></blockquote><pre><code>/* ** 在一个平面中.任意一个直线线段可以由2个点表示,任意一个点可以由X,Y坐标值表示.*例如线段 J 由 点A(x1, y1), B(x2, y2)表示. 其中坐标值 x,y 都为int. *求写出一个方法, boolean checkIntersect(Line J, Line K); *检查在平面中给出的2个线段是否相交, return true 代表线段相交, false 为不想交. *请自行定义线段Line的数据结构, 并可以假设传入参数Line J 和 Line K 为有效输入. */</code></pre><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aiqyInterview;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckIntersect</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> EdwardZhang</div><div class="line"> * 判断线段相交：</div><div class="line"> * 两个线段的交点个数可能有0个 1个或者无数个</div><div class="line"> * 判断两个线段相交，可以按照如下步骤：</div><div class="line"> * 判断A点B点是否在线段CD的两侧，即计算叉积时异号</div><div class="line"> * 判断C点和D点是否在线段AB的两侧，即计算叉积时异号</div><div class="line"> * 然后在处理特殊情况，即ABCD四个点有至少三个点共线的情况，</div><div class="line"> * 即出现叉积为零的情况，如果A点与线段CD共线，</div><div class="line"> * 则要查看A点是否在线段CD上，其它情况依次类推。</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.x = x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</div><div class="line">Point A = <span class="keyword">new</span> Point();</div><div class="line">Point B = <span class="keyword">new</span> Point();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">getA</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> A;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">A.x = i;</div><div class="line">A.y = j;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">getB</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">B.x = i;</div><div class="line">B.y = j;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">direct</span><span class="params">(Point i, Point j, Point k)</span> </span>&#123; <span class="comment">// 计算叉积</span></div><div class="line"><span class="keyword">return</span> (k.x - i.x) * (j.y - i.y) - (j.x - i.x) * (k.y - i.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onSegment</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="comment">// 共线时，判断点是否落在线段</span></div><div class="line"><span class="keyword">float</span> minx = Math.min(a.x, b.x);</div><div class="line"><span class="keyword">float</span> maxx = Math.max(a.x, b.x);</div><div class="line"><span class="keyword">float</span> miny = Math.min(a.y, b.y);</div><div class="line"><span class="keyword">float</span> maxy = Math.max(a.y, b.y);</div><div class="line"><span class="keyword">if</span> (c.x &gt;= minx &amp;&amp; c.x &lt;= maxx &amp;&amp; c.y &gt;= miny &amp;&amp; c.y &lt;= maxy) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkIntersect</span><span class="params">(Line X, Line Y)</span> </span>&#123;</div><div class="line"><span class="keyword">float</span> d1 = direct(Y.A, Y.B, X.A);</div><div class="line"><span class="keyword">float</span> d2 = direct(Y.A, Y.B, X.B);</div><div class="line"><span class="keyword">float</span> d3 = direct(X.A, X.B, Y.A);</div><div class="line"><span class="keyword">float</span> d4 = direct(X.A, X.B, Y.B);</div><div class="line"><span class="keyword">if</span> (d1 * d2 &lt; <span class="number">0</span> &amp;&amp; d3 * d4 &lt; <span class="number">0</span>)</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d1 == <span class="number">0</span> &amp;&amp; onSegment(Y.A, Y.B, X.A))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; onSegment(Y.A, Y.B, X.B))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d3 == <span class="number">0</span> &amp;&amp; onSegment(X.A, X.B, Y.A))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d4 == <span class="number">0</span> &amp;&amp; onSegment(X.A, X.B, Y.B))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">CheckIntersect checkIntersect = <span class="keyword">new</span> CheckIntersect();</div><div class="line">Line a = checkIntersect.new Line();</div><div class="line">Line b = checkIntersect.new Line();</div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//相交 true</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//相离 false</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">4</span>, <span class="number">2</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//平行 false</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">b.setB(<span class="number">3</span>, <span class="number">3</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//在一条直线上 true</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一道很简单很简单的入门题…核心就是一个我高中就学过的数学知识…叉积…可惜年久不用…在面试的紧要关头就显得呆若木鸡…很遗憾没有表现出自己的真实水平…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;/* *

* 在一个平面中.任意一个
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>计算机系应届生求职指北</title>
    <link href="https://edward7zhang.github.io/2018/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%BA%94%E5%B1%8A%E7%94%9F%E6%B1%82%E8%81%8C%E6%8C%87%E5%8C%97/"/>
    <id>https://edward7zhang.github.io/2018/04/19/计算机系应届生求职指北/</id>
    <published>2018-04-19T01:07:14.000Z</published>
    <updated>2018-04-19T05:18:21.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天早晨看到了Easy大大的这篇文章，在文章中读到了自己的影子，并且也明白了这段时间自己在实习招聘中的不足，受益匪浅。希望我的好友可以看到从中受益<br>特此转载 From：<a href="https://github.com/easychen/career-guide-for-cs-graduate" target="_blank" rel="external">https://github.com/easychen/career-guide-for-cs-graduate</a></p></blockquote><h1 id="计算机系应届生求职指北"><a href="#计算机系应届生求职指北" class="headerlink" title="计算机系应届生求职指北"></a>计算机系应届生求职指北</h1><p>最近帮了一个朋友的朋友做了下职业规划，结合之前在微博上的一些问答，觉得不少应届生同学对求职有蛮多误解的，所以这里分享下我的一点经验吧。虽然本文题为指北，但只是一个面向对行业、对业界技术不熟悉的同学的操作手册。各位技术大牛可能觉得粗浅，请见谅。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh5iysqx1j20qy0f50xb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p>本文略长，会谈及以下问题。</p><ul><li>职业规划越早越好</li><li>一定要珍惜校招的机会窗口</li><li>应届生的求职策略</li><li>技术职位的选择</li><li>语言和技术栈的选择</li><li>技术栈的优化</li><li>简历的书写</li></ul><p>下边我们一点一点来讲。</p><blockquote><p>本文作者 @Easy （ <a href="http://weibo.com/easy" target="_blank" rel="external">weibo.com/easy</a> ），方糖全栈课（ <a href="http://quanzhanke.com" target="_blank" rel="external">quanzhanke.com</a> ）主讲人，有多年大规模网站、云平台开发经验、曾运营过用户数十万的程序员拍卖平台，为上千名程序员找过工作。转载请保留以上作者信息和链接，谢谢。</p></blockquote><p>内容更新通知</p><p>可微信扫码（未关注直接关注）订阅本指北更新。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh6g6fiauj20by0byq3p.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <h2 id="职业规划越早越好"><a href="#职业规划越早越好" class="headerlink" title="职业规划越早越好"></a>职业规划越早越好</h2><p>职业是一个非常特殊的东西，它有两点很特别，一个是「不可重来」，另一个是「验证耗时」。之前和一个老友聊天，他感叹说，回过头看看，自己的整个职业过得乱七八糟。等到现在明白这点的时候，已经来不及了。因为一般一段职业经历短则一到两年，长则三到五年。换两家公司，十年一晃就过去了。如果你在这十年中没有很好的成长，又不幸身在某些公司，那三十多岁可能就面临被清退的处境了。</p><p>我一般不屑于去和别人分享什么人生经验，毕竟有些坑不自己跳下去是不会牢记在心的。但职业的坑不一样，等你发现在坑里时，可能已经晚了。所以我花了蛮多时间来研究这个。有兴趣的同学可以去读读我的《程序员跳槽全攻略》，专门讲职业规划的。( 在我的个人网站上可以免费读 <a href="http://t.cn/RYh1xhS" target="_blank" rel="external">方糖气球🎈|程序员跳槽全攻略</a> ) </p><h2 id="一定要珍惜校招的机会窗口"><a href="#一定要珍惜校招的机会窗口" class="headerlink" title="一定要珍惜校招的机会窗口"></a>一定要珍惜校招的机会窗口</h2><p>我大学的语文老师曾告诫我们说，人生就像四季一样，春天该播种，你去播种，秋天该收获，你去收获，这样是最省力的。你非要倒过来呢，也不是不行，但就是会很累，会付出更多的精力和代价。</p><p>校招也类似，它是社会和企业为从未步入职场的同学特意准备的一个绿色通道。在这个通道里，我们将候选人当做一张白纸，可以没有经验、没有行业常识，只要对工作充满热情、有还算聪明的头脑，基本都算是合格的。企业会为这些同学准备培训，并留足适应期，有的甚至还会安排一对一的老员工来带。</p><p>但是，一旦你错过了它，那一切都不一样了，因为你进入了名为「社招」的红海。在这里，所有已经毕业的人变成了你的竞争对手，不但要面对和你一样工作年限的人竞争，还要面对其他工作时间更长、经验更丰富的同行跳槽带来的竞争。甚至经常发生因为招到了一个中级岗位的候选人，取消掉两个初级岗位的情况。</p><p>所以校招非常重要，一定不要错过。</p><h2 id="应届生的求职策略"><a href="#应届生的求职策略" class="headerlink" title="应届生的求职策略"></a>应届生的求职策略</h2><p>既然校招这么重要，那么我们怎么才能在其中占据优势呢？记住两个词「择优录取」和「跑赢同学」。</p><h3 id="择优录取"><a href="#择优录取" class="headerlink" title="择优录取"></a>择优录取</h3><p>在微博上经常可以看到这样的问题：「我这个也会、那个也合格，凭什么他们就不招我呢？」这是典型的没有明白招聘本质的表现。要明白，求职不是「会考」而是「高考」，不是什么产品的出厂合格校验，而是一场中国这个资源紧缺型国家里的又一场优质资源争夺战。</p><p>那些薪水高、发展空间好的知名企业（后文简称大厂），每年招聘的人数是一定的。极端点说，如果现在所有候选人的水平都下调20%，他们依然要招人的，不然没法发展（严格讲会有一些调整空间，但也扛不了多久）。</p><p>所以，尤其是在校招里边，「绝对值」并不重要，「相对值」才是最重要的。</p><h3 id="跑赢同学"><a href="#跑赢同学" class="headerlink" title="跑赢同学"></a>跑赢同学</h3><p>我来讲一个很老的童话，听过的同学请装作没听过。两个人在森林里边遇到了熊🐻，kuma 看见他们就嗷嗷的追了过来。一个同学转身就跑，另一个问他说，我们怎么跑也跑不过熊的，那跑有什么用呢？这个同学回答说，我只要跑赢你就好了呀。</p><p>那其实校招也是一样的。它不是说你的能力要有多少，其实再牛的应届生的水平放到行业里边，都是不入流的，因为很多水平是靠海量的用户压出来的，你没有遇到过这些场景，怎么可能知道怎么去应对。</p><p>所以应届生和那些社招的候选人比，通常都是没啥胜算的，但幸运的是，我们和他们是不同的赛道。要跑赢一个在大厂核心岗位工作了一两年的人不容易，但要跑赢那些和你一样在大学只学了一堆理论基础，甚至理论课都没好好学天天在寝室吃鸡的同学，就容易很多了。</p><p>要承认，即使这样，要跑赢某些天资聪颖、能力拔群的学霸还是有难度的。但这场比赛是不公平的，因为它没规定每个人必须同时开始跑。鲁迅说得好，笨鸟先飞。（鲁迅：我没有说过）如果我们能更早的认识到这点，花更多时间去准备，那么赢的概率就会成倍提升。</p><p>我本身就是一个非常好的例子。严格的讲，我的能力算是平庸偏上一点点的，虽然在当时无论如何我都不会承认。当我在大一下半期认识到这一点时，就开始自学 PHP，大二的时候写了一堆没人用的开源项目，大三上半期找了家公司做兼职，已经能把学费挣回来了。当大三下半期开始找实习时，我的简历已经可以秒杀同校同学，小小PK 一流高校的同学了。</p><p>所以你以为校招比的是能力，其实对于执行力中等、同样天赋的同学来讲，校招比的其实是认知。越早认识到本质的人，就越容易在这场游戏里边胜出。从这个角度讲，坚持读到这里的你，甚至可能已经赢了一半了。所以记得要把这篇文章分享给你的好朋友，然后千万别让你不喜欢的同学知道。</p><h2 id="技术岗位的选择"><a href="#技术岗位的选择" class="headerlink" title="技术岗位的选择"></a>技术岗位的选择</h2><p>技术岗位的大体分布如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nht0kdj20vn0hhmz8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在几乎所有的软件都已经互联网化了，就算没有互联网化的，它以后也会互联网化，所以我们就不单纯地去说软件开发这个行业了。</p><h4 id="开发岗"><a href="#开发岗" class="headerlink" title="开发岗"></a>开发岗</h4><p>首先就是开发岗，这个就包括了前端开发、后端开发和移动开发。</p><p>前端开发和后端开发，主要是 B/S 结构里的。B/S 结构就是 Browser-Server 结构。而前端指的就是浏览器这个端；后端指的就是服务器这个端。</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>前端主要做的事情，就是把从服务器端读取到的数据展现给用户，然后通过各种 UI 控件和用户互动，再将新的数据送回服务器端。具体的技术包括 HTML、CSS、JavaScript，还可能有一些嵌入浏览器运行的组件，比如 Flash 、 WebGL 。</p><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>后端则主要送数据给前端，一般有两种方式，以前用的比较多的是，将数据在服务器端先渲染完，然后将输出的结果发送给前端；现在用的比较多的方式是将纯数据通过 Json 或者 xml 等格式发送给前端，在浏览器中通过 JS 来进行渲染。</p><p>所以以前很多后端的工程师往往也懂一些前端的知识，比如我认识的很多 PHP 程序员，他们不但懂 MySQL 和 Apache，还懂 HTML 、 CSS 、 JS 和 PS。这种前后端都懂的工程师，也叫全栈工程师。</p><p>后端可以用各种语言开发，国内用的比较多的包括 Java、PHP ，还有相对小众一些的 Python 、 Ruby 、 Go。其实 C 也是可以写后端的，不过现在已经很少有公司直接用它写了。</p><p>后来有了 NodeJS ，JavaScript 也能跑到后端了，所以很多前端工程师也有了后端开发的能力，他们也占了全栈工程师的很大一部分。</p><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>相对于 B/S 结构，还有 C/S 结构，就是 Client-Server 。C/S 结构下不用浏览器来展现数据和交互，而是用客户端，一般是 Mac/Win/Linux 三大平台。</p><h5 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h5><p>手机大潮起来以后，不管是 B/S 结构还是 C/S 结构，全部移动化了。B/S 结构对应的就是适配手机浏览器的移动网页、以及嵌入在微信、微博里边的 H5 页面; C/S 结构就是 APP ，一般覆盖 iOS 和 Android 两个主流平台。</p><p>除了这些标准开发岗，而还有一些新兴或者相对小众的开发方向，比如人工智能/算法工程师、做智能硬件的硬件开发工程师、给企业做解决方案的企业软件工程师。</p><h4 id="其他岗位"><a href="#其他岗位" class="headerlink" title="其他岗位"></a>其他岗位</h4><p>软件并不是开发出来就完了的，在上线或者发布之前，我们还需要「测试工程师」来进行测试；而上线以后，还需要「运维工程师」来管理和优化服务器集群。现在服务器都虚拟化和容器化了，运维工程师中也出现了懂开发的分支，叫做 DevOps。</p><h4 id="中高级岗位"><a href="#中高级岗位" class="headerlink" title="中高级岗位"></a>中高级岗位</h4><p>不管是开发岗还是测试、运维岗，都有其对应的中高级岗位。开发一般是技术经理；运维一般是架构师；测试一般是测试总监。技术总监、CTO 就是更高一级的职位了。</p><p>以上的职位分类我们参考了招聘网站的分类，不一定准确，可能会有很多岗位没覆盖到，不少公司也会有自己独特的岗位设置。</p><h3 id="职位的选择"><a href="#职位的选择" class="headerlink" title="职位的选择"></a>职位的选择</h3><p>如果能选择的话，不建议一开始就选运维或者测试。原因有两个：第一，因为它们虽然很重要，但不是软件开发的核心岗位。第二，从开发岗往这两个职位转非常容易，反之却非常难。</p><p>之前在给掘金写《程序员职业小白书》的时候，我做过一个邮件访谈，以问题的形式采访了多位在不同阶段、不同岗位、不同城市的程序员的日常。大家可以读一读，了解下。<a href="https://juejin.im/book/59e17a7ff265da430629cc4e/section/59faea95f265da430d575a22" target="_blank" rel="external">程序员们的日常是怎样的</a> （虽然这个小册是收费的，但访谈这一章却是可以免费读的，不需要购买哈）</p><h2 id="语言和技术栈的选择"><a href="#语言和技术栈的选择" class="headerlink" title="语言和技术栈的选择"></a>语言和技术栈的选择</h2><h3 id="语言概况"><a href="#语言概况" class="headerlink" title="语言概况"></a>语言概况</h3><p>虽然出于某种政治正确，我们一般都会说，语言不重要。但语言真的不重要么？并不是这样的，每种语言都有自己的优缺点和适用范围。</p><p>像日语和英语一样，一个是看动画玩游戏用的，一个是看资料写代码用的。（误）<br>下边简单介绍下我眼中的各个语言。</p><h4 id="C-C-："><a href="#C-C-：" class="headerlink" title="C/C++ ："></a>C/C++ ：</h4><p>系统语言，用来写底层操作系统、高性能中间件和嵌入式开发。</p><h4 id="Python：人工智能的好选择"><a href="#Python：人工智能的好选择" class="headerlink" title="Python：人工智能的好选择"></a>Python：人工智能的好选择</h4><p>举例来说，如果你想做人工智能方向的话，Python语言就是非常不错的选择。因为它在各个大学和研究机构用的非常多，有成熟好用的数学库，适合于科学计算。在深度学习等热门方向上，有大量用 Python 开发的框架，新出的 Paper 也能很快在 GitHub 上找到 Python 的代码实现，可以说是不二选择了。</p><h4 id="JavaScript：前端和全端"><a href="#JavaScript：前端和全端" class="headerlink" title="JavaScript：前端和全端"></a>JavaScript：前端和全端</h4><p>如果你想做前端，那么目前来看，除了 JavaScript 还真没有别的选择，因为现在能在浏览器里边跑起来，也就是它了。过两年等 wasm 成熟可能会有其他选择，但现在，是真没有。</p><p>而相应的，如果你学会了 JavaScript ，想在这个基础上再把后端给做了，那么 Node.JS 就是非常好的选择。因为它使用的就是 JavaScript 的解释器，按 JavaScript 写就好了。从学习成本上来讲，它是非常低的，可以通过很低的投入，就进入了服务器端的领域。</p><h4 id="PHP：依然是网站首选"><a href="#PHP：依然是网站首选" class="headerlink" title="PHP：依然是网站首选"></a>PHP：依然是网站首选</h4><p>如果你要做网站，那么 PHP 就是首选了。一方面是有大量的可用代码，世界上超过80%的网站都用的 PHP，基本上你能想到的网站功能，都有能找到的实现，悬念只是有没有免费的；另一方面，PHP7 的性能提升了很多，用来写 API 也非常好。</p><p>另外一点，就是目前使用 PHP 的团队非常多，即使在二三线城市也比较容易找到工作，当然，组建团队也同样相对容易。</p><h4 id="Java：大数据分析"><a href="#Java：大数据分析" class="headerlink" title="Java：大数据分析"></a>Java：大数据分析</h4><p>如果你要做大数据分析，那么可能就离不开 Java 了。<br>从 Hadoop 开始一系列的 Google Big Table 的开源实现都是 Java 的，用于海量数据搜索的 Elastic Stack 也是 Java 的。</p><h4 id="Go：云计算和容器管理"><a href="#Go：云计算和容器管理" class="headerlink" title="Go：云计算和容器管理"></a>Go：云计算和容器管理</h4><p>如果你现在要想去做云计算，那 Go 就是一个非常好的选择。</p><p>因为它就是为了大规模计算设计的，并发管理和性能都非常不错。而且有很多云计算的软件，它就是 Go 写的，如果你要去修改它，调整里边的实现逻辑的话，不会 Go 可能很麻烦。当然，理论上讲，你也可以通过容器和微服务的方式来搞定，但肯定比直接改代码麻烦。</p><p>另外区块链的大热平台以太坊的官方（最具潜力）实现，也是Go做的。钱途大大的。</p><h3 id="语言的选择"><a href="#语言的选择" class="headerlink" title="语言的选择"></a>语言的选择</h3><h4 id="兴趣优先"><a href="#兴趣优先" class="headerlink" title="兴趣优先"></a>兴趣优先</h4><p>在语言的选择上，尤其是第一门语言的选择上，我一直推荐兴趣优先的原则。因为对初学者而言，当你遇到困难坚持不下去时，兴趣会帮你一把。中学时为了改仙剑，我连汇编都试着学了个入门 🤣</p><h4 id="市场其次"><a href="#市场其次" class="headerlink" title="市场其次"></a>市场其次</h4><p>但其实对绝大部分应届生而言，对各种语言并没有特别的偏好。而且「找到工作」这件事是非常重要的。所以与其盲目的选择语言学习不如来看看各个语言在招聘市场的表现。</p><p>我之前写过一个脚本，可以抓取几个互联网招聘大站的招聘启事，并按职位对薪资进行统计。下边是最近一周的统计结果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nzwnz0j20qo5ubkjn.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>先来说说这些数据怎么看。</p><p>职位热度类似于招聘职位数，和其他语言对比就能看出差距。平均薪资之所有有两个值，是因为我们一般招聘时会给出薪资的上限和下限。严格的讲，这并不是当前某个语言的程序员们的薪资，而是他们下一次跳槽时的可能薪资。另外，部分企业喜欢在上限值上边虚高，所以把上限乘80%可能更合理。而下限一般比较真实，更具备对比价值。</p><p>然后我们来看看能发现什么。</p><h5 id="Java-的数据非常牛"><a href="#Java-的数据非常牛" class="headerlink" title="Java 的数据非常牛"></a>Java 的数据非常牛</h5><p>首先我们会发现，Java 的职位热度非常高，几乎在所有城市里边都是排名第一的。这里有一个特殊原因，就是 Android 职位基本也是使用 Java 语言进行开发的，所以这两个职位有一些重叠。也就是说，学好 Java 其实可以同时应聘 Java工程师 和 Android 工程师（可能需要额外在学一点点应用开发的知识），这非常划算。而从薪资方面看，Java 也是数一数二的。</p><h5 id="前端紧跟其后"><a href="#前端紧跟其后" class="headerlink" title="前端紧跟其后"></a>前端紧跟其后</h5><p>紧随其后的是前端职位。前端是个非常有意思的特点，那就是——几乎所有的公司都会招前端。对比 Java 而言，可能有很多大厂的后端用的不是 Java ，那他们就不需要招聘 Java 工程师。如果你非常想去这家公司，但你会的语言是 Java ，那么就可能和机会擦肩而过。而前端岗位的话，机会就可能大得多。这有点像血型里边的O型血，怎么地方都能用。就算是自以为站在食物链顶端鄙视「古典互联网」的区块链公司也不得不招前端呢，也是一个非常好的选择。</p><p>除了看热度，我们也要考虑到竞争，比如 Java 是一个「传统」岗，很多软件行业的工程师也是会 Java 的。而「前端」是一个新兴的互联网岗，专业前端还不算太多（和 Java 比啦），所以入职难度说不定反而低一些。</p><h5 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h5><p>其他语言在各个城市的数据各不相同，大家可以挑自己感兴趣的看。比如 Go 语言在北京比其他城市热几倍；区块链虽然看起来很火，但其实职位数也就比 PHP 的一半多点；Ruby 虽然薪资不错，但岗位非常少…</p><p>总之语言的选择因人而异因时而异，请综合各种视角去选择一个适合自己的。</p><h3 id="学习路线图"><a href="#学习路线图" class="headerlink" title="学习路线图"></a>学习路线图</h3><p>在选择好职位和语言后，就要寻找对应的学习路线图进行学习了。这里推荐这个 Star 数量超过4万的路线图（的中文版）：<a href="https://github.com/goodjack/developer-roadmap-chinese" target="_blank" rel="external">GitHub - goodjack/developer-roadmap-chinese: 2018 年成為 Web 開發人員的路線圖</a></p><p>虽然不是很全，但细节不错。</p><ul><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nk3d0ej214d2xc4qp.jpg" target="_blank" rel="external">前端路线图</a> </li><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nlxc7hj210u2sc4qp.jpg" target="_blank" rel="external">后端路线图</a></li><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nj63kgj215i1bpduw.jpg" target="_blank" rel="external">DevOPs路线图</a></li></ul><h2 id="技术栈的优化"><a href="#技术栈的优化" class="headerlink" title="技术栈的优化"></a>技术栈的优化</h2><p>之前我们在分析 Java 数据的时候，发现一个有意思的问题，那就是 Java 的技术栈可以同时覆盖两个热门职位 —— Java 和 Android，这让我们的求职竞争力一下翻了一倍。那么在其他的语言和岗位上还存不存在类似的情况呢？</p><p>其实是有的，比如前端岗位就是一个非常有潜力的例子，它的后端解决方案 NodeJS 正在日益流行 。在我写这篇文章的时候，互联网招聘大站 拉勾网 上北京的 NodeJS 职位数是 181，上海是 114，深圳是 65 。所以学完前端知识再补一下 NodeJS 的收益是不错的。</p><p>但这个技术栈其实还可以进一步优化，因为一个偶然的原因，我统计了一下 PHP 岗位和前端岗位招聘启事里边出现的技术关键词，发现其重合度竟然高于60%。具体的技术关键词和热度见这里 <a href="https://quanzhanke.github.io/ref/MAP.html" target="_blank" rel="external">《PHP&amp;前端岗（1~3年）核心技术点分析报告》</a></p><p>回头一想其实也很好理解，毕竟招 PHP 是来做网站的，HTML CSS JS 总得会一些才行。这意味着PHP的同学只需要补上部分前端知识，比如主流框架 React / Vue / Angular 和 SPA 开发就可以同时应聘 PHP 和 前端 职位。</p><p>这会有多大的竞争力呢？前端招聘启事里边，有超过十分之一的企业提及了PHP。这还没完，React 有一个混合应用解决方案，叫做 React Native，可以直接用 React 栈来开发手机APP。这个技术的需求如何呢？现在拉勾网上北京的 React Native 相关职位数有 84 。</p><p>于是呢，我们可以选择 PHP + React + React Native 的技术栈，仅仅多学习一点知识，可以投递的岗位就从原来的 364 变成了 364 + 373 + 84 。 </p><p>这就是技术栈优化的策略。关于这个技术栈的优化结构，可以看这里 <a href="https://quanzhanke.github.io/0-0.html" target="_blank" rel="external">《方糖全栈学习路线图》</a>，这个栈还顺便把区块链应用开发也覆盖了。大家可以举一反三，去优化自己选中的技术栈。</p><h2 id="简历的写作"><a href="#简历的写作" class="headerlink" title="简历的写作"></a>简历的写作</h2><p>不要最后找工作的时候再来写简历。现在就开始写，即使你什么都不会。这样你才会真切的感受到，自己的缺点和劣势。然后通过不断的学习，往简历上追加新的内容，直到你自己看起来觉得有竞争力了，简历才算阶段性完成了。</p><p>关于简历的写作技巧和工具，我之前写过一篇文章详细说明，可以点这里阅读 <a href="https://juejin.im/book/59e17a7ff265da430629cc4e/section/59faec225188252abc5db42c" target="_blank" rel="external">《如何写出一份专业的技术简历》</a> （这篇文章本身依然是免费的，不用购买小册就能读）</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>( 由于V站上某些同学的疑惑，这里我也补充一下吧。学好基础知识是必须的，这是最基本的，如果这些地方你都丢分了，这些技巧就都白费了 )</p><p>( 刷题库是面试必须的，但只刷题库就舍本逐末了，实践驱动的学习会让你对基础的理解更深入，虽然辛苦点。顺便po一个题库网站 [nowcoder]<a href="https://www.nowcoder.com/" target="_blank" rel="external">https://www.nowcoder.com/</a>  )</p><p>不知不觉已经写了这么多了，其实还有一些内容想说，但暂时就不写到这里了。</p><p>等以后有空我再整理一个小册子吧。我把文章也同时发布到了 GitHub，以后的更新会通过 GitHub 进行，欢迎 watch 和 star 。<a href="https://github.com/easychen/career-guide-for-cs-graduate" target="_blank" rel="external">https://github.com/easychen/career-guide-for-cs-graduate</a></p><p>PS：如果你还不知道怎么用 GitHub，那么赶紧学学吧，这可是程序员的必备（<del>交友</del>）工具哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天早晨看到了Easy大大的这篇文章，在文章中读到了自己的影子，并且也明白了这段时间自己在实习招聘中的不足，受益匪浅。希望我的好友可以看到从中受益&lt;br&gt;特此转载 From：&lt;a href=&quot;https://github.com/easychen/
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/17/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/17/Android网络编程面试题集/</id>
    <published>2018-04-17T01:07:14.000Z</published>
    <updated>2018-04-17T01:39:28.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP与UDP有什么区别？"><a href="#TCP与UDP有什么区别？" class="headerlink" title="TCP与UDP有什么区别？"></a>TCP与UDP有什么区别？</h3><ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol><h3 id="简单介绍一下TCP三次握手与四次分手过程？"><a href="#简单介绍一下TCP三次握手与四次分手过程？" class="headerlink" title="简单介绍一下TCP三次握手与四次分手过程？"></a>简单介绍一下TCP三次握手与四次分手过程？</h3><p>TCP用<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#建立通路" target="_blank" rel="external">三次握手</a>（three-way handshake）过程创建一个连接，使用四次分手<br>关闭一个连接。</p><p>三次握手与四次分手的流程如下所示：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/practice/network/three_way_handshake.jpeg" width="500"></p><p>三次握手</p><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li></ul><p>四次分手</p><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><p>三次握手与四次分手也是个老生常谈的概念，举个简单的例子说明一下。</p><p>三次握手</p><blockquote><p>例如你小时候出去玩，经常玩忘了回家吃饭。你妈妈也经常过来喊你。如果你没有走远，在门口的小土堆上玩泥巴，你妈妈会喊：”小新，回家吃饭了”。你听到后会回应：”知道了，一会就回去”。妈妈听<br>到你的回应后又说：”快点回来，饭要凉了”。这样你妈妈和你就完成了三次握手的过程。😁说到这里你也可以理解三次握手的必要性，少了其中一个环节，另一方就会陷入等待之中。</p></blockquote><p>三次握手的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误.</p><p>四次分手</p><blockquote><p>例如偶像言情剧干净利落的分手，女主对男主说：我们分手吧🙄，男主说：分就分吧😰。女主说：你果然是不爱我了，你只知道让我多喝热水🙄。男主说：事到如今也没什么好说的了，祝你幸福🙃。四次分手完成。说到这里你可以理解<br>了四次分手的必要性，第一次是女方（客户端）提出分手，第二次是男主（服务端）同意女主分手，第三次是女主确定男主不再爱她，也同意男主分手。第四次两人彻底拜拜（断开连接）。</p></blockquote><p>因为TCP是全双工模式，所以四次分手的目的就是为了可靠地关闭连接。</p><h3 id="TCP如何保证数据传输的可靠性？"><a href="#TCP如何保证数据传输的可靠性？" class="headerlink" title="TCP如何保证数据传输的可靠性？"></a>TCP如何保证数据传输的可靠性？</h3><ol><li>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。</li><li>数据校验。</li><li>数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。</li><li>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。</li><li>拥塞控制：当网络发生拥塞时，减少数据的发送。</li></ol><h3 id="HTTP与HTTPS有什么区别？"><a href="#HTTP与HTTPS有什么区别？" class="headerlink" title="HTTP与HTTPS有什么区别？"></a>HTTP与HTTPS有什么区别？</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">HTTPS</a>是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份<br>认证，保护交换数据的隐私与完整性。</p></blockquote><p>如下图所示，可以很明显的看出两个的区别：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/practice/network/http_https.png" width="500"></p><p>注：TLS是SSL的升级替代版，具体发展历史可以参考<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="external">传输层安全性协议</a>。</p><p>HTTP与HTTPS在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来：</p><ul><li>如果URL的协议是HTTP，则客户端会打开一条到服务端端口80（默认）的连接，并向其发送老的HTTP请求。</li><li>如果URL的协议是HTTPS，则客户端会打开一条到服务端端口443（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的<br>HTTP请求。</li></ul><p>所以你可以看到，HTTPS比HTTP多了一层与SSL的连接，这也就是客户端与服务端SSL握手的过程，整个过程主要完成以下工作：</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证</li><li>生成临时的会话密钥，以便加密信道。</li></ul><p>SSL握手是一个相对比较复杂的过程，更多关于SSL握手的过程细节可以参考<a href="https://www.wosign.com/faq/faq2016-0309-04.htm" target="_blank" rel="external">TLS/SSL握手过程</a></p><p>SSL/TSL的常见开源实现是OpenSSL，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。<br>更多源于OpenSSL的技术细节可以参考<a href="https://www.openssl.org/" target="_blank" rel="external">OpenSSL</a>。</p><h3 id="谈一谈对HTTP缓存的理解？"><a href="#谈一谈对HTTP缓存的理解？" class="headerlink" title="谈一谈对HTTP缓存的理解？"></a>谈一谈对HTTP缓存的理解？</h3><p>HTTP的缓存机制也是依赖于请求和响应header里的参数类实现的，最终响应式从缓存中去，还是从服务端重新拉取，HTTP的缓存机制的流程如下所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/android-open-framwork-analysis/raw/master/art/okhttp/http_cache_structure.png" width="600"></p><p>HTTP的缓存可以分为两种：</p><ul><li>强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。</li><li>对比缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存<br>标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。</li></ul><p>强制缓存优先于对比缓存。</p><p>上面提到强制缓存使用的的两个标识：</p><ul><li>Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。</li><li>Cache-Control：Expires有个时间校验的问题，所有HTTP1.1采用Cache-Control替代Expires。</li></ul><p>Cache-Control的取值有以下几种：</p><ul><li>private:             客户端可以缓存。</li><li>public:              客户端和代理服务器都可缓存。</li><li>max-age=xxx:   缓存的内容将在 xxx 秒后失效</li><li>no-cache:          需要使用对比缓存来验证缓存数据。</li><li>no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发。</li></ul><p>我们再来看看对比缓存的两个标识：</p><p><strong>Last-Modified/If-Modified-Since</strong></p><p>Last-Modified 表示资源上次修改的时间。</p><p>当客户端发送第一次请求时，服务端返回资源上次修改的时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Last-Modified: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div></pre></td></tr></table></figure><p>客户端再次发送，会在header里携带If-Modified-Since。将上次服务端返回的资源时间上传给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-Modified-Since: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div></pre></td></tr></table></figure><p>服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改，<br>则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存。</p><p>上面是一种时间戳标记资源是否修改的方法，还有一种资源标识码ETag的方式来标记是否修改，如果标识码发生改变，则说明资源已经被修改，ETag优先级高于Last-Modified。</p><p><strong>Etag/If-None-Match</strong></p><p>ETag是资源文件的一种标识码，当客户端发送第一次请求时，服务端会返回当前资源的标识码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ETag: <span class="string">"5694c7ef-24dc"</span></div></pre></td></tr></table></figure><p>客户端再次发送，会在header里携带上次服务端返回的资源标识码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-None-Match:<span class="string">"5694c7ef-24dc"</span></div></pre></td></tr></table></figure><p>服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较，如果不同，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回<br>304，客户端可以继续使用缓存。</p><h3 id="HTTPS是如何保证安全的，证书如何校验？"><a href="#HTTPS是如何保证安全的，证书如何校验？" class="headerlink" title="HTTPS是如何保证安全的，证书如何校验？"></a>HTTPS是如何保证安全的，证书如何校验？</h3><h3 id="HTTP如何实现长连接？"><a href="#HTTP如何实现长连接？" class="headerlink" title="HTTP如何实现长连接？"></a>HTTP如何实现长连接？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
</feed>
