<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EdwardZhang&#39;s Blog</title>
  
  <subtitle>Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://edward7zhang.github.io/"/>
  <updated>2019-07-31T06:14:25.995Z</updated>
  <id>https://edward7zhang.github.io/</id>
  
  <author>
    <name>EdwardZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tensroflow XLA AOT 模型优化</title>
    <link href="https://edward7zhang.github.io/2019/07/29/Tensorflow%20XLA%20AOT%20%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/"/>
    <id>https://edward7zhang.github.io/2019/07/29/Tensorflow XLA AOT 模型优化/</id>
    <published>2019-07-29T12:24:12.000Z</published>
    <updated>2019-07-31T06:14:25.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近团队在APM方向发力，需要在产品的深度学习模型的速度和占用空间大小两个维度来进行提升</p><p>目前使用的是Tensorflow Lite的格式在进行模型运算，想通过Tensorflow官方在2017年推出的预研项目XLA对模型进行优化，在官方示例过程的结论中模型使用XLA/AOT优化的模型比之前使用.pb格式的模型运行速度会提升10%~200%（有个别情况），占用空间会有4x的缩小</p><p>本文将逐一展示完整优化过程及遇到的坑（解决方案）。</p></blockquote><h1 id="Step-1-使用XLA将模型编译为AOT（ahead-of-time）代码的步骤"><a href="#Step-1-使用XLA将模型编译为AOT（ahead-of-time）代码的步骤" class="headerlink" title="Step -1: 使用XLA将模型编译为AOT（ahead-of-time）代码的步骤"></a>Step -1: 使用XLA将模型编译为AOT（ahead-of-time）代码的步骤</h1><ol><li><p>编译tfcomfile</p></li><li><p>固化模型</p></li><li><p>graph.config.pbtxt</p></li><li><p>编写bazel BUILD脚本</p></li><li><p>编译对应平台二进制文件 .o .h</p></li><li><p>编写代码调用AOT模型</p></li><li><p>编写BUILD</p></li><li><p>编译对应平台最终产物 .so</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Ubuntu18.04</li><li>Bazel 0.24</li><li>jdk 8</li><li>NDK</li><li>SDK</li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">//tensorflow/compiler/aot/</div><div class="line">│  aot_only_var_handle_op.cc</div><div class="line">│  benchmark.cc</div><div class="line">│  benchmark.h</div><div class="line">│  benchmark_main.template</div><div class="line">│  benchmark_test.cc</div><div class="line">│  BUILD</div><div class="line">│  codegen.cc</div><div class="line">│  codegen.h</div><div class="line">│  codegen_test.cc</div><div class="line">│  codegen_test_h.golden</div><div class="line">│  codegen_test_o.golden</div><div class="line">│  compile.cc</div><div class="line">│  compile.h</div><div class="line">│  embedded_protocol_buffers.cc</div><div class="line">│  embedded_protocol_buffers.h</div><div class="line">│  flags.cc</div><div class="line">│  flags.h</div><div class="line">│  test.cc</div><div class="line">│  test_graph_tfadd.config.pbtxt</div><div class="line">│  test_graph_tfadd.pbtxt</div><div class="line">│  test_graph_tfunknownop.config.pbtxt</div><div class="line">│  test_graph_tfunknownop.pbtxt</div><div class="line">│  test_graph_tfunknownop2.config.pbtxt</div><div class="line">│  test_graph_tfunknownop3.config.pbtxt</div><div class="line">│  tfcompile.bzl</div><div class="line">│  tfcompile_main.cc</div><div class="line">│</div><div class="line">├─custom</div><div class="line">│  │  BUILD</div><div class="line">│  │  com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.cc</div><div class="line">│  │  com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.h</div><div class="line">│  │  custom_interface.config.pbtxt</div><div class="line">│  │  custom_interface_lib.h</div><div class="line">│  │  custom_interface_tfcompile_function.o</div><div class="line">│  │  custom_interface_tfcompile_metadata.o</div><div class="line">│  │  debug.cc</div><div class="line">│  │  debug.h</div><div class="line">│  │  figure-65.png</div><div class="line">│  │  figure-66.jpg</div><div class="line">│  │  frozen_custom_010.pb</div><div class="line">│  │  input_image.py</div><div class="line">│  │  libcustom_interface.a</div><div class="line">│  │  libcustom_interface.pic.a</div><div class="line">│  │  libcustom_interface.so</div><div class="line">│  │  lib_custom_interface.so</div><div class="line">│  │  log.h</div><div class="line">│  │  log_stream.h</div><div class="line">│  │  out.h</div><div class="line">│  │  out_helper.o</div><div class="line">│  │  out_model.o</div><div class="line">│  │  predict_model.py</div><div class="line">│  │  Screenshot_67.jpg</div><div class="line">│  │  Screenshot_68.png</div><div class="line">│  │  tfcompile_h_o.py</div><div class="line">│  │  __init__.py</div><div class="line">│  │</div><div class="line">│  ├─arm64-v8a</div><div class="line">│  │      libcustom_interface.so</div><div class="line">│  │      lib_custom_interface.so</div><div class="line">│  │</div><div class="line">│  └─armeabi-v7a</div><div class="line">│          libcustom_interface.so</div><div class="line">│          lib_custom_interface.so</div><div class="line">│</div><div class="line">└─tests</div><div class="line">        BUILD</div><div class="line">        make_test_graphs.py</div><div class="line">        test_graph_tfadd.config.pbtxt</div><div class="line">        test_graph_tfadd_with_ckpt.config.pbtxt</div><div class="line">        test_graph_tfassert_eq.config.pbtxt</div><div class="line">        test_graph_tfcond.config.pbtxt</div><div class="line">        test_graph_tffunction.config.pbtxt</div><div class="line">        test_graph_tfgather.config.pbtxt</div><div class="line">        test_graph_tfmatmul.config.pbtxt</div><div class="line">        test_graph_tfmatmulandadd.config.pbtxt</div><div class="line">        test_graph_tfsplits.config.pbtxt</div><div class="line">        test_graph_tftop_k.config.pbtxt</div><div class="line">        test_graph_tfvariable.config.pbtxt</div><div class="line">        test_graph_tfvariable_sequential_updates.config.pbtxt</div><div class="line">        tfcompile_test.cc</div></pre></td></tr></table></figure></li></ol><h1 id="Step-0-编译tfcomfile"><a href="#Step-0-编译tfcomfile" class="headerlink" title="Step 0: 编译tfcomfile"></a>Step 0: 编译tfcomfile</h1><ul><li><p>首先编译tfcomfile其实就是编译tensorflow源码中的一部分，但这一部分的编译却需要整个工程的依赖</p><ol><li><p>下载源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> --recurse-submodules https://github.com/tensorflow/tensorflow</div></pre></td></tr></table></figure><p>其中<strong>–recurse-submodules</strong>参数是必须的，用于获取TensorFlow依赖的protobuf库.</p></li><li><p>配置TensorFlow</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/tensorflow</div><div class="line">./configure</div></pre></td></tr></table></figure><p>需要注意配置编译项的一些规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">You have bazel 0.25.0 installed.</div><div class="line">Please specify the location of python. [Default is C:\ProgramData\Anaconda3\python.exe]: </div><div class="line"></div><div class="line"></div><div class="line">Found possible Python library paths:</div><div class="line">  C:\ProgramData\Anaconda3\lib\site-packages</div><div class="line">Please input the desired Python library path to use.  Default is [C:\ProgramData\Anaconda3\lib\site-packages]</div><div class="line"></div><div class="line">Do you wish to build TensorFlow with XLA JIT support? [y/N]: Y</div><div class="line">XLA JIT support will be enabled <span class="keyword">for</span> TensorFlow.</div><div class="line"></div><div class="line">Do you wish to build TensorFlow with ROCm support? [y/N]: N</div><div class="line">No ROCm support will be enabled <span class="keyword">for</span> TensorFlow.</div><div class="line"></div><div class="line">Do you wish to build TensorFlow with CUDA support? [y/N]: N</div><div class="line">No CUDA support will be enabled <span class="keyword">for</span> TensorFlow.</div><div class="line"></div><div class="line">Please specify optimization flags to use during compilation when bazel option <span class="string">"--config=opt"</span> is specified [Default is</div><div class="line">/arch:AVX]: </div><div class="line"></div><div class="line"></div><div class="line">Would you like to override eigen strong inline <span class="keyword">for</span> some C++ compilation to reduce the compilation time? [Y/n]: N</div><div class="line">Not overriding eigen strong inline, some compilations could take more than 20 mins.</div><div class="line"></div><div class="line">Preconfigured Bazel build configs. You can use any of the below by adding <span class="string">"--config=&lt;&gt;"</span> to your build <span class="built_in">command</span>. See .ba</div><div class="line">zelrc <span class="keyword">for</span> more details.</div><div class="line">        --config=mkl            <span class="comment"># Build with MKL support.</span></div><div class="line">        --config=monolithic     <span class="comment"># Config for mostly static monolithic build.</span></div><div class="line">        --config=gdr            <span class="comment"># Build with GDR support.</span></div><div class="line">        --config=verbs          <span class="comment"># Build with libverbs support.</span></div><div class="line">        --config=ngraph         <span class="comment"># Build with Intel nGraph support.</span></div><div class="line">        --config=numa           <span class="comment"># Build with NUMA support.</span></div><div class="line">        --config=dynamic_kernels        <span class="comment"># (Experimental) Build kernels into separate shared objects.</span></div><div class="line">        --config=v2             <span class="comment"># Build TensorFlow 2.x instead of 1.x.</span></div><div class="line">Preconfigured Bazel build configs to DISABLE default on features:</div><div class="line">        --config=noaws          <span class="comment"># Disable AWS S3 filesystem support.</span></div><div class="line">        --config=nogcp          <span class="comment"># Disable GCP support.</span></div><div class="line">        --config=nohdfs         <span class="comment"># Disable HDFS support.</span></div><div class="line">        --config=noignite       <span class="comment"># Disable Apache Ignite support.</span></div><div class="line">        --config=nokafka        <span class="comment"># Disable Apache Kafka support.</span></div><div class="line">        --config=nonccl         <span class="comment"># Disable NVIDIA NCCL support.</span></div><div class="line">Configuration finished</div></pre></td></tr></table></figure><p>最需要注意的是其中的：<code>Do you wish to build TensorFlow with XLA JIT support? [y/N]: Y</code>!!!这是使用XLA的关键</p></li><li><p>开始编译tfcompile</p><p>tfcompile的Bazel脚本入口在<code>//tensorflow/compiler/aot:tfcompile</code></p><p>执行命令进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bazel build //tensorflow/compiler/aot:tfcompile</div></pre></td></tr></table></figure></li></ol><blockquote><p>讲一下这一步骤中遇到的坑</p><ul><li>首先编译源码的过程中不同资源是异步编译的经常会出现找不到包的问题，可以多尝试执行上一命令重复进行编译即可</li><li>在编译过程中会首先去请求下载各种依赖，这一过程中会出现依赖方已升级版本但本地请求需要验证SHA256（本地SHA256是在代码中写死的）不匹配这一问题，可以根据日志定位依赖下载脚本位置修改对应SHA256值即可</li><li>bazel编译过程在下载依赖后是有缓存机制的不必担心下载后的依赖丢失（前提是不执行<code>bazel clean</code>）</li><li>在编译tfcompile过程中如果遇到不论在什么网络状态在都无法编译通过的问题尝试<code>bazel clean</code>后重新执行命令或在项目根目录执行<code>bazel build --config=opt //tensorflow/tools/pip_package:build_pip_package</code>进行依赖下载构建依赖包成功后再次执行tfcompile编译命令就会顺畅很多</li></ul></blockquote></li></ul><h1 id="Step-1-固化模型"><a href="#Step-1-固化模型" class="headerlink" title="Step 1:  固化模型"></a>Step 1:  固化模型</h1><p>这一步中需要将graph与checkpoints冻结形成.pb格式的固化模型这是之后形成二进制文件的原料</p><p>这一步很容易没有什么坑 ；)</p><h1 id="Step-2-graph-config-pbtxt"><a href="#Step-2-graph-config-pbtxt" class="headerlink" title="Step 2: graph.config.pbtxt"></a>Step 2: graph.config.pbtxt</h1><p>这一步中主要是为了形成graph的描述，即注明该graph的输入节点的节点名、入参tensor大小，输出节点的节点名等参数</p><p>有两种方式可以形成该描述</p><ol><li><p>使用源码中的工具进行自动化形成（需要编写代码）</p><p>使用源码中的tf2xla_pb2.py可进行一些操作形成该描述</p><p>这里介绍另一种直观且快速的方式</p></li><li><p>通过可视化工具确定入口出口</p><p><img src="https://i.loli.net/2019/07/30/5d3fb86bbc95b76560.jpg" alt="NETRON"></p><p>通过该工具将模型导入后可扩展内部所有节点的描述，即可以得到输入节点与输出节点的描述，进行对应节点描述文件编写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Each feed is a positional input argument for the generated function.  The order</span></div><div class="line"><span class="comment"># of each entry matches the order of each input argument.  Here “x_hold” and “y_hold”</span></div><div class="line"><span class="comment"># refer to the names of placeholder nodes defined in the graph.</span></div><div class="line">feed &#123;</div><div class="line">  id &#123; node_name: <span class="string">"input"</span> &#125;</div><div class="line">  shape &#123;</div><div class="line">    dim &#123; size: 1 &#125;</div><div class="line">    dim &#123; size: 160 &#125;</div><div class="line">    dim &#123; size: 160 &#125;</div><div class="line">    dim &#123; size: 3 &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment"># Each fetch is a positional output argument for the generated function.  The order</span></div><div class="line"><span class="comment"># of each entry matches the order of each output argument.  Here “x_y_prod”</span></div><div class="line"><span class="comment"># refers to the name of a matmul node defined in the graph.</span></div><div class="line">fetch &#123;</div><div class="line">  id &#123; node_name: <span class="string">"MobilenetV2/Predictions/Reshape_1"</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>   将该文件保存为<code>graph.config.pbtxt</code></p><p>   该步骤完成</p><p>   <strong>WARNING:</strong> 需要注意在该描述文件中添加注释时只可使用<code>#</code>作为标示，否则编译不过且定位不到问题位置</p><h1 id="Step-3-编写bazel-BUILD脚本"><a href="#Step-3-编写bazel-BUILD脚本" class="headerlink" title="Step 3: 编写bazel BUILD脚本"></a>Step 3: 编写bazel BUILD脚本</h1><p>在这一步骤中将进行编写编译脚本很简短的配置但有一些细节需要注意：</p><ul><li><p>建议在<code>//tensorflow/compiler/aot</code>下建立自己的floder将以上生成的产物放入其中，以下操作默认操作在<code>//tensorflow/compiler/aot/custom</code>下进行</p></li><li><p>在custom目录下创建BUILD脚本文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">load(<span class="string">"//tensorflow/compiler/aot:tfcompile.bzl"</span>, <span class="string">"tf_library"</span>)</div><div class="line"></div><div class="line">tf_library(</div><div class="line">    name = <span class="string">"custom_interface"</span>,</div><div class="line"></div><div class="line">    cpp_class = <span class="string">"Classifier"</span>,</div><div class="line"></div><div class="line">    graph = <span class="string">"frozen_custom_010.pb"</span>,</div><div class="line"></div><div class="line">    config = <span class="string">"graph.config.pbtxt"</span>,</div><div class="line">)</div></pre></td></tr></table></figure><h3 id="内部参数解释："><a href="#内部参数解释：" class="headerlink" title="内部参数解释："></a>内部参数解释：</h3><ul><li><p><code>name</code>：即执行编译后将生成产物的名称</p></li><li><p><code>cpp_class</code>：即生成C++头文件.h中对该类的命名，可以在该类名前添加作用域such as：<code>foo::bar::Classifier</code>等自定义操作</p></li><li><p><code>graph</code>：即之前步骤中生成的冻结图.pb产物</p></li><li><p><code>config</code>：即上一步骤中产生的图描述文件</p><p><em>此步骤完成</em></p></li></ul></li></ul><h1 id="Step-4-编译对应平台二进制文件-o-h"><a href="#Step-4-编译对应平台二进制文件-o-h" class="headerlink" title="Step 4: 编译对应平台二进制文件 .o .h"></a>Step 4: 编译对应平台二进制文件 .o .h</h1><p>使用命令：<code>bazel build --verbose_failures //tensorflow/compiler/aot/custom:custom_interface</code></p><p>其中<code>custom_interface</code>对应上一步骤中的<code>name</code></p><p>鉴于之前编译过tfcompile，此步骤只是使用了该产物中的部分资源进行编译所以不会有什么坑</p><p>这里介绍另一种编译此步骤产物的方式，需要在编译tfcompile步骤后产生的bazel-bin文件中找到tfcompile的run文件</p><p>通过命令<code>tfcompile --graph=frozen_custom_010.pb --config=graph.config.pbtxt --cpp_class=&quot;Classifier&quot;</code></p><p>这里贴下tfcompile的具体用法其中具有编译对应平台ABI的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">tfcompile performs ahead-of-time compilation of a TensorFlow graph,</div><div class="line">resulting <span class="keyword">in</span> an object file compiled <span class="keyword">for</span> your target architecture, and a</div><div class="line">header file that gives access to the functionality <span class="keyword">in</span> the object file.</div><div class="line">A typical invocation looks like this:</div><div class="line"></div><div class="line">   $ tfcompile --graph=mygraph.pb --config=myfile.pbtxt --cpp_class=<span class="string">"mynamespace::MyComputation"</span></div><div class="line"></div><div class="line">usage: ./tfcompile</div><div class="line">Flags:</div><div class="line">        --graph=<span class="string">""</span>                              string  Input GraphDef file.  If the file ends <span class="keyword">in</span> <span class="string">'.pbtxt'</span> it is expected to be <span class="keyword">in</span> the human-readable proto text format, otherwise it is expected to be <span class="keyword">in</span> the proto binary format.</div><div class="line">        --config=<span class="string">""</span>                             string  Input file containing Config proto.  If the file ends <span class="keyword">in</span> <span class="string">'.pbtxt'</span> it is expected to be <span class="keyword">in</span> the human-readable proto text format, otherwise it is expected to be <span class="keyword">in</span> the proto binary format.</div><div class="line">        --dump_fetch_nodes=<span class="literal">false</span>                bool    If <span class="built_in">set</span>, only flags related to fetches are processed, and the resulting fetch nodes will be dumped to stdout <span class="keyword">in</span> a comma-separated list.  Typically used to format arguments <span class="keyword">for</span> other tools, e.g. freeze_graph.</div><div class="line">        --target_triple=<span class="string">"x86_64-pc-linux"</span>       string  Target platform, similar to the clang -target flag.  The general format is &lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;.  http://clang.llvm.org/docs/CrossCompilation.html<span class="comment">#target-triple.</span></div><div class="line">        --target_cpu=<span class="string">""</span>                         string  Target cpu, similar to the clang -mcpu flag.  http://clang.llvm.org/docs/CrossCompilation.html<span class="comment">#cpu-fpu-abi</span></div><div class="line">        --target_features=<span class="string">""</span>                    string  Target features, e.g. +avx2, +neon, etc.</div><div class="line">        --entry_point=<span class="string">"entry"</span>                   string  Name of the generated <span class="keyword">function</span>.  If multiple generated object files will be linked into the same binary, each will need a unique entry point.</div><div class="line">        --cpp_class=<span class="string">""</span>                          string  Name of the generated C++ class, wrapping the generated <span class="keyword">function</span>.  The syntax of this flag is [[&lt;optional_namespace&gt;::],...]&lt;class_name&gt;.  This mirrors the C++ syntax <span class="keyword">for</span> referring to a class, <span class="built_in">where</span> multiple namespaces may precede the class name, separated by double-colons.  The class will be generated <span class="keyword">in</span> the given namespace(s), or <span class="keyword">if</span> no namespaces are given, within the global namespace.</div><div class="line">        --out_function_object=<span class="string">"out_model.o"</span>     string  Output object file containing the generated <span class="keyword">function</span> <span class="keyword">for</span> the TensorFlow model.</div><div class="line">        --out_header=<span class="string">"out.h"</span>                    string  Output header file name.</div><div class="line">        --out_metadata_object=<span class="string">"out_helper.o"</span>    string  Output object file name containing optional metadata <span class="keyword">for</span> the generated <span class="keyword">function</span>.</div><div class="line">        --out_session_module=<span class="string">""</span>                 string  Output session module proto.</div><div class="line">        --gen_name_to_index=<span class="literal">false</span>               bool    Generate name-to-index data <span class="keyword">for</span> Lookup&#123;Arg,Result&#125;Index methods.</div><div class="line">        --gen_program_shape=<span class="literal">false</span>               bool    Generate program shape data <span class="keyword">for</span> the ProgramShape method.</div><div class="line">        --xla_generate_hlo_graph=<span class="string">""</span>             string  HLO modules matching this regex will be dumped to a .dot file throughout various stages <span class="keyword">in</span> compilation.</div><div class="line">        --xla_hlo_graph_addresses=<span class="literal">false</span>         bool    With xla_generate_hlo_graph, show addresses of HLO ops <span class="keyword">in</span> graph dump.</div><div class="line">        --xla_hlo_graph_path=<span class="string">""</span>                 string  With xla_generate_hlo_graph, dump the graphs into this path.</div><div class="line">        --xla_hlo_dump_as_graphdef=<span class="literal">false</span>        bool    Dump HLO graphs as TensorFlow GraphDefs.</div><div class="line">        --xla_hlo_graph_sharding_color=<span class="literal">false</span>    bool    Assign colors based on sharding assignments when generating the HLO graphs.</div><div class="line">        --xla_hlo_tfgraph_device_scopes=<span class="literal">false</span>   bool    When generating TensorFlow HLO graphs, <span class="keyword">if</span> the HLO instructions are assigned to a specific device, prefix the name scope with <span class="string">"devX"</span> with X being the device ordinal.</div><div class="line">        --xla_log_hlo_text=<span class="string">""</span>                   string  HLO modules matching this regex will be dumped to LOG(INFO).</div><div class="line">        --xla_generate_hlo_text_to=<span class="string">""</span>           string  Dump all HLO modules as text into the provided directory path.</div><div class="line">        --xla_enable_fast_math=<span class="literal">true</span>             bool    Enable unsafe fast-math optimizations <span class="keyword">in</span> the compiler; this may produce faster code at the expense of some accuracy.</div><div class="line">        --xla_llvm_enable_alias_scope_metadata=<span class="literal">true</span>     bool    In LLVM-based backends, <span class="built_in">enable</span> the emission of !alias.scope metadata <span class="keyword">in</span> the generated IR.</div><div class="line">        --xla_llvm_enable_noalias_metadata=<span class="literal">true</span> bool    In LLVM-based backends, <span class="built_in">enable</span> the emission of !noalias metadata <span class="keyword">in</span> the generated IR.</div><div class="line">        --xla_llvm_enable_invariant_load_metadata=<span class="literal">true</span>  bool    In LLVM-based backends, <span class="built_in">enable</span> the emission of !invariant.load metadata <span class="keyword">in</span> the generated IR.</div><div class="line">        --xla_llvm_disable_expensive_passes=<span class="literal">false</span>       bool    In LLVM-based backends, <span class="built_in">disable</span> a custom <span class="built_in">set</span> of expensive optimization passes.</div><div class="line">        --xla_backend_optimization_level=3      int32   Numerical optimization level <span class="keyword">for</span> the XLA compiler backend.</div><div class="line">        --xla_disable_hlo_passes=<span class="string">""</span>             string  Comma-separated list of hlo passes to be disabled. These names must exactly match the passes<span class="string">' names; no whitespace around commas.</span></div><div class="line">        --xla_embed_ir_in_executable=false      bool    Embed the compiler IR as a string in the executable.</div><div class="line">        --xla_dump_ir_to=""                     string  Dump the compiler IR into this directory as individual files.</div><div class="line">        --xla_eliminate_hlo_implicit_broadcast=true     bool    Eliminate implicit broadcasts when lowering user computations to HLO instructions; use explicit broadcast instead.</div><div class="line">        --xla_cpu_multi_thread_eigen=true       bool    When generating calls to Eigen in the CPU backend, use multi-threaded Eigen mode.</div><div class="line">        --xla_gpu_cuda_data_dir="./cuda_sdk_lib"        string  If non-empty, speficies a local directory containing ptxas and nvvm libdevice files; otherwise we use those from runfile directories.</div><div class="line">        --xla_gpu_ftz=false                     bool    If true, flush-to-zero semantics are enabled in the code generated for GPUs.</div><div class="line">        --xla_gpu_disable_multi_streaming=false bool    If true, multi-streaming in the GPU backend is disabled.</div><div class="line">        --xla_gpu_max_kernel_unroll_factor=4    int32   Specify the maximum kernel unroll factor for the GPU backend.</div><div class="line">        --xla_dump_optimized_hlo_proto_to=""    string  Dump Hlo after all hlo passes are executed as proto binary into this directory.</div><div class="line">        --xla_dump_unoptimized_hlo_proto_to=""  string  Dump HLO before any hlo passes are executed as proto binary into this directory.</div><div class="line">        --xla_dump_per_pass_hlo_proto_to=""     string  Dump HLO after each pass as an HloProto in binary file format into this directory.</div><div class="line">        --xla_test_all_output_layouts=false     bool    Let ClientLibraryTestBase::ComputeAndCompare* test all permutations of output layouts. For example, with a 3D shape, all permutations of the set &#123;0, 1, 2&#125; are tried.</div><div class="line">        --xla_test_all_input_layouts=false      bool    Let ClientLibraryTestBase::ComputeAndCompare* test all permutations of *input* layouts. For example, for 2 input arguments with 2D shape and 4D shape, the computation will run 2! * 4! times for every possible layouts</div><div class="line">        --xla_hlo_profile=false                 bool    Instrument the computation to collect per-HLO cycle counts</div><div class="line">        --xla_dump_computations_to=""           string  Dump computations that XLA executes into the provided directory path</div><div class="line">        --xla_dump_executions_to=""             string  Dump parameters and results of computations that XLA executes into the provided directory path</div><div class="line">        --xla_backend_extra_options=""          string  Extra options to pass to a backend; comma-separated list of 'key=val<span class="string">' strings (=val may be omitted); no whitespace around commas.</span></div><div class="line">        --xla_reduce_precision=""               string  Directions for adding reduce-precision operations. Format is 'LOCATION=E,M:OPS;NAMES<span class="string">' where LOCATION is the class of locations in which to insert the operations (e.g., '</span>OP_OUTPUTS<span class="string">'), E and M are the exponent and matissa bit counts respectively, and OPS and NAMES are comma-separated (no spaces) lists of the operation types and names to which to attach the reduce-precision operations.  The NAMES string and its preceding '</span>;<span class="string">' may be omitted.  This option may be repeated to define multiple sets of added reduce-precision operations.</span></div><div class="line">        --xla_gpu_use_cudnn_batchnorm=false     bool    Allows the GPU backend to implement batchnorm HLOs using cudnn, rather than expanding them to a soup of HLOs.</div><div class="line">        --xla_cpu_use_mkl_dnn=false             bool    Generate calls to MKL-DNN in the CPU backend.</div></pre></td></tr></table></figure><p>最终生成三个产物:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/30/5d3fcf560633657230.png" alt="产物" title="">                </div>                <div class="image-caption">产物</div>            </figure><ul><li><p><code>cat custom_interface_lib.h</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Generated by tfcompile, the TensorFlow graph compiler.  DO NOT EDIT!</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This header was generated via ahead-of-time compilation of a TensorFlow</span></div><div class="line"><span class="comment">// graph.  An object file corresponding to this header was also generated.</span></div><div class="line"><span class="comment">// This header gives access to the functionality in that object file.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// clang-format off</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TFCOMPILE_GENERATED___xla_tensorflow_compiler_aot_custom__custom_interface_H_  <span class="comment">// NOLINT(build/header_guard)</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TFCOMPILE_GENERATED___xla_tensorflow_compiler_aot_custom__custom_interface_H_  <span class="comment">// NOLINT(build/header_guard)</span></span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tensorflow/compiler/tf2xla/xla_compiled_cpu_function.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tensorflow/core/platform/types.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> Eigen &#123; <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPoolDevice</span>;</span> &#125;</div><div class="line"><span class="keyword">namespace</span> xla &#123; <span class="class"><span class="keyword">class</span> <span class="title">ExecutableRunOptions</span>;</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// (Implementation detail) Entry point to the function in the object file.</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">void</span> __xla_tensorflow_compiler_aot_custom__custom_interface(</div><div class="line">    <span class="keyword">void</span>* result, <span class="keyword">const</span> ::xla::ExecutableRunOptions* run_options,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span>** args, <span class="keyword">void</span>** temps, tensorflow::int64* profile_counters);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Classifier represents a computation previously specified in a</span></div><div class="line"><span class="comment">// TensorFlow graph, now compiled into executable code. This extends the generic</span></div><div class="line"><span class="comment">// XlaCompiledCpuFunction class with statically type-safe arg and result</span></div><div class="line"><span class="comment">// methods. Usage example:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   Classifier computation;</span></div><div class="line"><span class="comment">//   // ...set args using computation.argN methods</span></div><div class="line"><span class="comment">//   CHECK(computation.Run());</span></div><div class="line"><span class="comment">//   // ...inspect results using computation.resultN methods</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The Run method invokes the actual computation, with inputs read from arg</span></div><div class="line"><span class="comment">// buffers, and outputs written to result buffers. Each Run call may also use</span></div><div class="line"><span class="comment">// a set of temporary buffers for the computation.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// By default each instance of this class manages its own arg, result and temp</span></div><div class="line"><span class="comment">// buffers. The AllocMode constructor parameter may be used to modify the</span></div><div class="line"><span class="comment">// buffer allocation strategy.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Under the default allocation strategy, this class is thread-compatible:</span></div><div class="line"><span class="comment">// o Calls to non-const methods require exclusive access to the object.</span></div><div class="line"><span class="comment">// o Concurrent calls to const methods are OK, if those calls are made while it</span></div><div class="line"><span class="comment">//   is guaranteed that no thread may call a non-const method.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The logical function signature is:</span></div><div class="line"><span class="comment">//   (arg0: f32[1,160,160,3]) -&gt; (f32[1,30])</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Memory stats:</span></div><div class="line"><span class="comment">//   arg bytes total:    307200</span></div><div class="line"><span class="comment">//   arg bytes aligned:  307200</span></div><div class="line"><span class="comment">//   temp bytes total:   4143008</span></div><div class="line"><span class="comment">//   temp bytes aligned: 4143104</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classifier</span> <span class="title">final</span> :</span> <span class="keyword">public</span> tensorflow::XlaCompiledCpuFunction &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Number of input arguments for the compiled computation.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kNumArgs = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Byte size of each argument buffer. There are kNumArgs entries.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ::tensorflow::<span class="function">int64 <span class="title">ArgSize</span><span class="params">(::tensorflow::int32 index)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> BufferInfos()[ArgIndexToBufferIndex()[index]].size();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Returns static data used to create an XlaCompiledCpuFunction.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> tensorflow::XlaCompiledCpuFunction::<span class="function">StaticData&amp; <span class="title">StaticData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> XlaCompiledCpuFunction::StaticData* kStaticData = []()&#123;</div><div class="line">      XlaCompiledCpuFunction::StaticData* data =</div><div class="line">        <span class="keyword">new</span> XlaCompiledCpuFunction::StaticData;</div><div class="line">      set_static_data_raw_function(data, __xla_tensorflow_compiler_aot_custom__custom_interface);</div><div class="line">      set_static_data_buffer_infos(data, BufferInfos());</div><div class="line">      set_static_data_num_buffers(data, kNumBuffers);</div><div class="line">      set_static_data_arg_index_table(data, ArgIndexToBufferIndex());</div><div class="line">      set_static_data_num_args(data, kNumArgs);</div><div class="line">      set_static_data_result_index(data, kResultIndex);</div><div class="line">      set_static_data_arg_names(data, StaticArgNames());</div><div class="line">      set_static_data_result_names(data, StaticResultNames());</div><div class="line">      set_static_data_program_shape(data, StaticProgramShape());</div><div class="line">      set_static_data_hlo_profile_printer_data(</div><div class="line">          data, StaticHloProfilePrinterData());</div><div class="line"></div><div class="line">      <span class="keyword">return</span> data;</div><div class="line">    &#125;();</div><div class="line">    <span class="keyword">return</span> *kStaticData;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Classifier(AllocMode alloc_mode =</div><div class="line">            AllocMode::ARGS_VARIABLES_RESULTS_PROFILES_AND_TEMPS)</div><div class="line">      : XlaCompiledCpuFunction(StaticData(), alloc_mode) &#123;&#125;</div><div class="line"></div><div class="line">  Classifier(<span class="keyword">const</span> Classifier&amp;) = <span class="keyword">delete</span>;</div><div class="line">  Classifier&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Classifier&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Arg methods for managing input buffers. Buffers are in row-major order.</span></div><div class="line">  <span class="comment">// There is a set of methods for each positional argument, with the following</span></div><div class="line">  <span class="comment">// general form:</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// void set_argN_data(void* data)</span></div><div class="line">  <span class="comment">//   Sets the buffer of type T for positional argument N. May be called in</span></div><div class="line">  <span class="comment">//   any AllocMode. Must be called before Run to have an affect. Must be</span></div><div class="line">  <span class="comment">//   called in AllocMode::RESULTS_PROFILES_AND_TEMPS_ONLY for each positional</span></div><div class="line">  <span class="comment">//   argument, to set the argument buffers.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// T* argN_data()</span></div><div class="line">  <span class="comment">//   Returns the buffer of type T for positional argument N.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// T&amp; argN(...dim indices...)</span></div><div class="line">  <span class="comment">//   Returns a reference to the value of type T for positional argument N,</span></div><div class="line">  <span class="comment">//   with dim indices specifying which value. No bounds checking is performed</span></div><div class="line">  <span class="comment">//   on dim indices.</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_arg0_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data)</span> </span>&#123;</div><div class="line">    set_arg_data(<span class="number">0</span>, data);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">float</span>* <span class="title">arg0_data</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(arg_data(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">float</span>&amp; <span class="title">arg0</span><span class="params">(<span class="keyword">size_t</span> dim0, <span class="keyword">size_t</span> dim1, <span class="keyword">size_t</span> dim2, <span class="keyword">size_t</span> dim3)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>(*)[<span class="number">1</span>][<span class="number">160</span>][<span class="number">160</span>][<span class="number">3</span>]&gt;(</div><div class="line">        arg_data(<span class="number">0</span>)))[dim0][dim1][dim2][dim3];</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">float</span>* <span class="title">arg0_data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">float</span>*&gt;(arg_data(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">float</span>&amp; <span class="title">arg0</span><span class="params">(<span class="keyword">size_t</span> dim0, <span class="keyword">size_t</span> dim1, <span class="keyword">size_t</span> dim2, <span class="keyword">size_t</span> dim3)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">float</span>(*)[<span class="number">1</span>][<span class="number">160</span>][<span class="number">160</span>][<span class="number">3</span>]&gt;(</div><div class="line">        arg_data(<span class="number">0</span>)))[dim0][dim1][dim2][dim3];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Result methods for managing output buffers. Buffers are in row-major order.</span></div><div class="line">  <span class="comment">// Must only be called after a successful Run call. There is a set of methods</span></div><div class="line">  <span class="comment">// for each positional result, with the following general form:</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// T* resultN_data()</span></div><div class="line">  <span class="comment">//   Returns the buffer of type T for positional result N.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// T&amp; resultN(...dim indices...)</span></div><div class="line">  <span class="comment">//   Returns a reference to the value of type T for positional result N,</span></div><div class="line">  <span class="comment">//   with dim indices specifying which value. No bounds checking is performed</span></div><div class="line">  <span class="comment">//   on dim indices.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Unlike the arg methods, there is no set_resultN_data method. The result</span></div><div class="line">  <span class="comment">// buffers are managed internally, and may change after each call to Run.</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">float</span>* <span class="title">result0_data</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(result_data(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">float</span>&amp; <span class="title">result0</span><span class="params">(<span class="keyword">size_t</span> dim0, <span class="keyword">size_t</span> dim1)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (*<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>(*)[<span class="number">1</span>][<span class="number">30</span>]&gt;(</div><div class="line">        result_data(<span class="number">0</span>)))[dim0][dim1];</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">float</span>* <span class="title">result0_data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">float</span>*&gt;(result_data(<span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">float</span>&amp; <span class="title">result0</span><span class="params">(<span class="keyword">size_t</span> dim0, <span class="keyword">size_t</span> dim1)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">float</span>(*)[<span class="number">1</span>][<span class="number">30</span>]&gt;(</div><div class="line">        result_data(<span class="number">0</span>)))[dim0][dim1];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Methods for managing variable buffers. Buffers are in row-major order.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// For read-write variables we generate the following methods:</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// void set_var_X_data(T* data)</span></div><div class="line">  <span class="comment">//   Sets the buffer for variable X.  Must be called before Run if the</span></div><div class="line">  <span class="comment">//   allocation mode is RESULTS_PROFILES_AND_TEMPS_ONLY.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// T* var_X_data()</span></div><div class="line">  <span class="comment">//   Returns the buffer of type T for variable X.  If the allocation mode is</span></div><div class="line">  <span class="comment">//   RESULTS_PROFILES_AND_TEMPS_ONLY then this buffer is the same as the</span></div><div class="line">  <span class="comment">//   buffer passed to set_var_X_data.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// T&amp; var_X(...dim indices...)</span></div><div class="line">  <span class="comment">//   Returns a reference to the value of type T for variable X,</span></div><div class="line">  <span class="comment">//   with dim indices specifying which value. No bounds checking is performed</span></div><div class="line">  <span class="comment">//   on dim indices.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// For readonly variables we generate the same set of methods, except that we</span></div><div class="line">  <span class="comment">// use `const T` instead of `T`.  We use `const T` to avoid erasing the</span></div><div class="line">  <span class="comment">// constness of the buffer passed to `set_var_X_data` but the underlying</span></div><div class="line">  <span class="comment">// buffer is not const (and thus the const can be safely const-cast'ed away)</span></div><div class="line">  <span class="comment">// unless `set_var_X_data` is called with a pointer to constant storage.</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Number of buffers for the compiled computation.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kNumBuffers = <span class="number">50</span>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ::xla::cpu_function_runtime::<span class="function">BufferInfo* <span class="title">BufferInfos</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::xla::cpu_function_runtime::BufferInfo</div><div class="line">      kBufferInfos[kNumBuffers] = &#123;</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">2293760U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">1228802U</span>LL, <span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">614400U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">602112U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">301056U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">301056U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">301056U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">301056U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">301056U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">172032U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">98304U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">98304U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">98304U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">98304U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">98304U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">73728U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">55296U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">55296U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">55296U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">55296U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">55296U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">55296U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">55296U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">36864U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">24576U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">24576U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">24576U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">24576U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">24576U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">12288U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">6912U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">6144U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">6144U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">6144U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">6144U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">6144U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">2048U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">481U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">33U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">16U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">19U</span>LL, ~<span class="number">0U</span>LL&#125;),</div><div class="line">::xla::cpu_function_runtime::BufferInfo(&#123;<span class="number">16571521U</span>LL, ~<span class="number">0U</span>LL&#125;)</div><div class="line">      &#125;;</div><div class="line">    <span class="keyword">return</span> kBufferInfos;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ::tensorflow::<span class="function">int32* <span class="title">ArgIndexToBufferIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> ::tensorflow::int32 kArgIndexToBufferIndex[kNumArgs] = &#123;</div><div class="line"><span class="number">1</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> kArgIndexToBufferIndex;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// The 0-based index of the result tuple in the temporary buffers.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kResultIndex = <span class="number">38</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Array of names of each positional argument, terminated by nullptr.</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>** <span class="title">StaticArgNames</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Array of names of each positional result, terminated by nullptr.</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>** <span class="title">StaticResultNames</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Shape of the args and results.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ::xla::<span class="function">ProgramShapeProto* <span class="title">StaticProgramShape</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::xla::ProgramShapeProto* kShape = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">return</span> kShape;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Metadata that can be used to pretty-print profile counters.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ::xla::<span class="function">HloProfilePrinterData* <span class="title">StaticHloProfilePrinterData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::xla::HloProfilePrinterData* kHloProfilePrinterData =</div><div class="line">      <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">return</span> kHloProfilePrinterData;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// TFCOMPILE_GENERATED___xla_tensorflow_compiler_aot_custom__custom_interface_H_</span></span></div><div class="line"></div><div class="line"><span class="comment">// clang-format on</span></div></pre></td></tr></table></figure></li></ul><p>可以看到其中的具体图已经转换为对应运行时指令。</p><p>  其中的BufferInfo标记的是为.o文件中的具体运行时二进制字块</p><h1 id="Step-5-编写代码调用AOT模型"><a href="#Step-5-编写代码调用AOT模型" class="headerlink" title="Step 5: 编写代码调用AOT模型"></a>Step 5: 编写代码调用AOT模型</h1><blockquote><p>这一步中需要注意最终形成的.so在什么平台进行使用，当我们在移动端（Android）使用时，与C++进行通讯需要JNI的支持所以在这一步需要重新configure Tensorflow源码配置SDK、NDK支持，具体SDK\NDK对应target自行选择</p><p>下文中的调用C++代码将采用复合JNI规范的代码编写</p></blockquote><h2 id="项目Java书写对应native方法生成对应JNI头文件："><a href="#项目Java书写对应native方法生成对应JNI头文件：" class="headerlink" title="项目Java书写对应native方法生成对应JNI头文件："></a>项目Java书写对应native方法生成对应JNI头文件：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.qihoo.cleandroid.sdk.imageclassfier.core.classfier.process;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by zhanghongxin on 2019/7/22.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassifier</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIBNAME = <span class="string">"custom_interface"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CustomClassifier</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Load the TensorFlowLite runtime C library.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.loadLibrary(LIBNAME);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (UnsatisfiedLinkError e) &#123;</div><div class="line">            System.err.println(<span class="string">"custom_interface: failed to load native library: "</span> + e.getMessage());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">getPredictResult</span><span class="params">(<span class="keyword">float</span>[][][][] input, <span class="keyword">float</span>[][] output, <span class="keyword">int</span> inputSize, <span class="keyword">int</span> outputSize)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="生成头文件com-qihoo-cleandroid-sdk-imageclassfier-core-classfier-process-CustomClassifier-h"><a href="#生成头文件com-qihoo-cleandroid-sdk-imageclassfier-core-classfier-process-CustomClassifier-h" class="headerlink" title="生成头文件com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.h"></a>生成头文件<code>com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></div><div class="line"><span class="comment">/* Header for class com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier</div><div class="line"> * Method:    getPredictResult</div><div class="line"> * Signature: ([[[[F[[FII)V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier_getPredictResult</span></span></div><div class="line">  <span class="params">(JNIEnv *, jclass, jobjectArray, jobjectArray, jint, jint)</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><h2 id="编写C-代码实现模型调用com-qihoo-cleandroid-sdk-imageclassfier-core-classfier-process-CustomClassifier-cc"><a href="#编写C-代码实现模型调用com-qihoo-cleandroid-sdk-imageclassfier-core-classfier-process-CustomClassifier-cc" class="headerlink" title="编写C++代码实现模型调用com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.cc"></a>编写C++代码实现模型调用<code>com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.cc</code></h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">#define EIGEN_USE_THREADS</div><div class="line">#define EIGEN_USE_CUSTOM_THREAD_POOL</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;jni.h&gt;</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line">#include "custom_interface_lib.h"</div><div class="line">#include "third_party/eigen3/unsupported/Eigen/CXX11/Tensor"</div><div class="line"></div><div class="line">float* run(float* input, float* output, int input_size, int output_size)&#123;</div><div class="line">        std::cout &lt;&lt; "Load .so SUCCESS" &lt;&lt; std::endl;</div><div class="line">        Eigen::ThreadPool tp(std::thread::hardware_concurrency());</div><div class="line">        Eigen::ThreadPoolDevice device(&amp;tp, tp.NumThreads());</div><div class="line">        Classifier classifier;</div><div class="line">        classifier.set_thread_pool(&amp;device);</div><div class="line"></div><div class="line">        std::copy(input, input + input_size, classifier.arg0_data());</div><div class="line">        auto ok = classifier.Run();</div><div class="line">        if (not ok) std::cout &lt;&lt; "NOT OK" &lt;&lt; std::endl;</div><div class="line">//</div><div class="line">//        std::cout &lt;&lt; "input:";</div><div class="line">//        std::cout &lt;&lt; input &lt;&lt; std::endl;</div><div class="line">//</div><div class="line">//        std::cout &lt;&lt; "input_size:";</div><div class="line">//        std::cout &lt;&lt; input_size &lt;&lt; std::endl;</div><div class="line">//</div><div class="line">//        std::cout &lt;&lt; "classifier.arg0_data():";</div><div class="line">//        std::cout &lt;&lt; classifier.arg0_data() &lt;&lt; std::endl;</div><div class="line">//</div><div class="line">//        std::cout &lt;&lt; "output:";</div><div class="line">//        std::cout &lt;&lt; output &lt;&lt; std::endl;</div><div class="line">//</div><div class="line">//        std::cout &lt;&lt; "output_size:";</div><div class="line">//        std::cout &lt;&lt; output_size &lt;&lt; std::endl;</div><div class="line">//</div><div class="line">//        std::cout &lt;&lt; "result0_data():";</div><div class="line">//        std::cout &lt;&lt; classifier.result0_data() &lt;&lt; std::endl;</div><div class="line">//</div><div class="line">//        for(int i = 0; i &lt; 30; i++)&#123;</div><div class="line">//            std::cout &lt;&lt; "restul0_";</div><div class="line">//            std::cout &lt;&lt; i;</div><div class="line">//            std::cout &lt;&lt; " : ";</div><div class="line">//            std::cout &lt;&lt; classifier.result0(0,i) &lt;&lt; std::endl;</div><div class="line">//            __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~OUTPUT== %f~~~~~~~~~~~~~~~\n", classifier.result0(0,i));</div><div class="line">//        &#125;</div><div class="line"></div><div class="line">        std::copy(classifier.result0_data(), classifier.result0_data() + output_size, output);</div><div class="line"></div><div class="line">        return output;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#ifndef _Included_com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier</div><div class="line">#define _Included_com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier</div><div class="line">#ifdef __cplusplus</div><div class="line">extern "C" &#123;</div><div class="line">#endif</div><div class="line">    JNIEXPORT void JNICALL Java_com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier_getPredictResult</div><div class="line">      (JNIEnv *env, jobject obj, jobjectArray inputArray, jobjectArray outputArray, jint inputSize, jint outputSize)&#123;</div><div class="line">        jboolean isCopy = JNI_FALSE;</div><div class="line"></div><div class="line">          jint rows = env-&gt;GetArrayLength(inputArray);</div><div class="line">//          __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~inputRows== %d~~~~~~~~~~~~~~~\n", rows);</div><div class="line">          jobjectArray tempInputArray = (jobjectArray)env-&gt;GetObjectArrayElement(inputArray, 0);</div><div class="line">//          __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~input: 1~~~~~~~~~~~~~~\n");</div><div class="line">          jobjectArray tTempInputArray = (jobjectArray)env-&gt;GetObjectArrayElement(tempInputArray, 0);</div><div class="line">//          __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~input: 2~~~~~~~~~~~~~~~\n");</div><div class="line">          jobjectArray tTTempInputArray = (jobjectArray)env-&gt;GetObjectArrayElement(tTempInputArray, 0);</div><div class="line">//          __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~input: 3~~~~~~~~~~~~~~~\n");</div><div class="line">          jfloat* input = env-&gt;GetFloatArrayElements((jfloatArray)tTTempInputArray, 0);</div><div class="line">//          __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~input: %f~~~~~~~~~~~~~~~\n", input);</div><div class="line"></div><div class="line"></div><div class="line">        jobjectArray tempOutputArray = (jobjectArray)env-&gt;GetObjectArrayElement(outputArray,0);</div><div class="line">//        __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~output: 1~~~~~~~~~~~~~~~\n");</div><div class="line">        jfloat* output = env-&gt;GetFloatArrayElements((jfloatArray)tempOutputArray, 0);</div><div class="line">//        __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~output: %f~~~~~~~~~~~~~~~\n", output);</div><div class="line"></div><div class="line">        jfloat* resultPointer = run(input, output, inputSize, outputSize);</div><div class="line"></div><div class="line">//        jclass floatArrayClz = env-&gt;FindClass("[[F");</div><div class="line">//        if(floatArrayClz == NULL) return NULL;</div><div class="line">//        outputArray = env-&gt;NewObjectArray(outputSize, floatArrayClz, NULL );</div><div class="line">//        if(outputArray == NULL) return NULL;</div><div class="line">        for(int i = 0; i &lt; 1; i++)&#123;</div><div class="line">            jfloat temp[outputSize];</div><div class="line">            jfloatArray floatArray = env-&gt;NewFloatArray(outputSize);</div><div class="line">//            if(floatArray == NULL) return NULL;</div><div class="line">            for(int j=0; j &lt; outputSize; j++)&#123;</div><div class="line">                temp[j] = *(resultPointer + j);</div><div class="line">            &#125;</div><div class="line">//            __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~output: 2~~~~~~~~~~~~~~~\n");</div><div class="line">            env-&gt;SetFloatArrayRegion(floatArray, 0, outputSize, temp);</div><div class="line">//            __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~output: 3~~~~~~~~~~~~~~~\n");</div><div class="line">            env-&gt;SetObjectArrayElement(outputArray, i, floatArray);</div><div class="line">//            __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~output: 4~~~~~~~~~~~~~~~\n");</div><div class="line">            env-&gt;DeleteLocalRef(floatArray);</div><div class="line">        &#125;</div><div class="line">//        __android_log_print(ANDROID_LOG_INFO, "NATIVE", "~~~~~~~~~output: %f~~~~~~~~~~~~~~~\n", outputArray[0]);</div><div class="line">      &#125;</div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line">#endif</div></pre></td></tr></table></figure><p><em>此步骤结束</em></p><h1 id="Step-6-编写BUILD"><a href="#Step-6-编写BUILD" class="headerlink" title="Step 6: 编写BUILD"></a>Step 6: 编写BUILD</h1><blockquote><p>此步骤中所编写的BUILD文件与Step 3中所编写文件为同一文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">cc_library(</div><div class="line">    name = <span class="string">"library"</span>,</div><div class="line">    hdrs = [<span class="string">"custom_interface_lib.h"</span>],</div><div class="line">    srcs = [<span class="string">"custom_interface_tfcompile_function.o"</span>,<span class="string">"custom_interface_tfcompile_metadata.o"</span>],</div><div class="line">)</div><div class="line"></div><div class="line">cc_binary(</div><div class="line">    name = <span class="string">"libcustom_interface.so"</span>,</div><div class="line"></div><div class="line">    srcs = [</div><div class="line">    <span class="string">"com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.h"</span>,</div><div class="line">    <span class="string">"com_qihoo_cleandroid_sdk_imageclassfier_core_classfier_process_CustomClassifier.cc"</span>,</div><div class="line">    ],</div><div class="line"></div><div class="line">    deps = [</div><div class="line">    <span class="string">":library"</span>,</div><div class="line">    <span class="string">"//tensorflow/compiler/tf2xla:xla_compiled_cpu_function"</span>,</div><div class="line">    <span class="string">"//tensorflow/core:framework_lite"</span>,</div><div class="line">    <span class="string">"//tensorflow/compiler/xla:cpu_function_runtime"</span>,</div><div class="line">    <span class="string">"//tensorflow/compiler/xla/service/cpu:runtime_conv2d"</span>,</div><div class="line">    <span class="string">"//tensorflow/compiler/xla/service/cpu:runtime_matmul"</span>,</div><div class="line">    <span class="string">"//third_party/eigen3"</span>,</div><div class="line">    ],</div><div class="line"></div><div class="line">    linkopts = [</div><div class="line">    <span class="string">"-landroid"</span>,</div><div class="line">    <span class="string">"-shared"</span>,</div><div class="line">    ],</div><div class="line"></div><div class="line">    linkshared = 1,</div><div class="line"></div><div class="line">    linkstatic = 1,</div><div class="line"></div><div class="line">    copts = [<span class="string">"-fPIC"</span>],</div><div class="line">)</div></pre></td></tr></table></figure><p>其中cc_binary中的name即为生成.so的名称该名称应符合JNI规范</p><p>注意生成.so动态链接库时需配置<code>linkshared = 1</code> <code>linkstatic = 1</code> </p><h1 id="Step-7-编译对应平台最终产物-so"><a href="#Step-7-编译对应平台最终产物-so" class="headerlink" title="Step 7: 编译对应平台最终产物 .so"></a>Step 7: 编译对应平台最终产物 .so</h1><p>运行命令：<code>bazel build -c opt //tensorflow/compiler/aot/custom:libcustom_interface.so \ --crosstool_top=//external:android/crosstool \ --host_crosstool_top=@bazel_tools//tools/cpp:toolchain \ --cpu=armeabi-v7a</code></p><p>通过<code>--cpu=xxx</code>来控制编译对应平台ABI的.so</p><p><em>至此编译后所有步骤完成</em></p><h1 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h1><p>通过XLA加速接入移动端对比（其实并没有可比性因为没有控制变量）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/30/5d3fd9484d72823389.png" alt="对比" title="">                </div>                <div class="image-caption">对比</div>            </figure><p>上图中显示了在lite和xla两种方式下使用同一种机型预测174张图片的耗时对比数据</p><p>明显lite在这一方面速度非常有优势，但并不代表XLA不起作用，而是恰巧在我们的计算图中使用的卷积网络在这种情况下不适用于XLA进行优化，官方使用JIT的速度对比，其实在JIT的训练时数据和AOT的运行时数据事实上是对应关系恰巧反应了这一关系。</p><p>后附几张官方演示图：</p><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/30/5d3fdb4d90ce710040.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/30/5d3fd82750fad80574.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/30/5d3fd82760ed015529.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><p><a href="https://carlthome.github.io/posts/tfcompile /" target="_blank" rel="external">tfcompile | Carl Thomé</a></p></li><li><p><a href="https://www.tensorflow.org/xla/tfcompile" target="_blank" rel="external">Using AOT compilation  |  XLA  |  TensorFlow</a></p></li><li><p><a href="https://github.com/rongjiecomputer/tensorflow-xla-aot-windows" target="_blank" rel="external">GitHub - rongjiecomputer/tensorflow-xla-aot-windows: Guide to build and use Tensorflow XLA/AOT on Windows</a></p></li><li><p><a href="https://stackoverflow.com/questions/43673380/tensorflow-cross-compile-xla-to-android" target="_blank" rel="external">c++ - TensorFlow: cross-compile XLA to Android - Stack Overflow</a></p></li><li><p><a href="https://danny270degree.blogspot.com/" target="_blank" rel="external">danny270degree.blogspot.com</a></p></li><li><p><a href="https://qiita.com/qiita_kuru/items/71660124b807c00ace31" target="_blank" rel="external">Tensorflow AOT (tfcompile)の使い方 - Qiita</a></p></li><li><p><a href="https://danny270degree.blogspot.com/2018/06/xla-how-to-use-xla-aot-compilation-in.html" target="_blank" rel="external">Danny’s tech notebook | 丹尼技術手札: [XLA 研究] How to use XLA AOT compilation in TensorFlow</a></p></li><li><p><a href="http://www.bnee.net/article/73899.html" target="_blank" rel="external">学习笔记TF062:TensorFlow线性代数编译框架XLA / bnee.net</a></p></li><li><p><a href="https://www.wandouip.com/t5i207350/" target="_blank" rel="external">TF加速-AOT之tfcompile趟坑 - 豌豆ip代理</a></p></li><li><p><a href="https://github.com/bazelbuild/bazel/issues/5164" target="_blank" rel="external">Issue #5164 · bazelbuild/bazel · GitHub</a></p></li><li><p><a href="https://barkeywolf.consulting/posts/tf-aot-rust/" target="_blank" rel="external">Barkey Wolf Consulting - Ahead-of-time compilation of a Tensorflow model for lightweight inclusion in a Rust program</a></p></li><li><p><a href="https://github.com/tensorflow/tensorflow/issues/7288" target="_blank" rel="external">Are linkopts propagated from copts and/or deps ? · Issue #7288 · tensorflow/tensorflow</a></p></li><li><p><a href="https://blog.csdn.net/zhuiqiuk/article/details/54428818" target="_blank" rel="external">Build TensorFlow for armeabi-v7a and arm64-v8a - zhuiqiuk的专栏 - CSDN博客</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近团队在APM方向发力，需要在产品的深度学习模型的速度和占用空间大小两个维度来进行提升&lt;/p&gt;
&lt;p&gt;目前使用的是Tensorflow Lite的格式在进行模型运算，想通过Tensorflow官方在2017年推出的预研项目XLA对模型进行优化，在
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>想说却还没说的也不必再说了</title>
    <link href="https://edward7zhang.github.io/2019/06/01/%E6%83%B3%E8%AF%B4%E5%8D%B4%E8%BF%98%E6%B2%A1%E8%AF%B4%E7%9A%84%E4%B9%9F%E4%B8%8D%E5%BF%85%E5%86%8D%E8%AF%B4%E4%BA%86/"/>
    <id>https://edward7zhang.github.io/2019/06/01/想说却还没说的也不必再说了/</id>
    <published>2019-06-01T14:42:07.000Z</published>
    <updated>2019-06-01T16:06:37.404Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" marginwidth="0" marginheight="0" width="300" height="50" src="https://music.163.com/outchain/player?type=2&id=1218773&auto=0&height=32"></iframe><h1 id="想说却还没说的还很多"><a href="#想说却还没说的还很多" class="headerlink" title="想说却还没说的还很多"></a>想说却还没说的还很多</h1><ul><li>从一开始听大哥的歌“想说却还没说的还很多，攒着是因为想写成歌让人轻轻地唱着、淡淡地记着”，开始了大学四年的修行，到今天拍完毕业照、结束毕业答辩才感到拔剑四顾心茫然的惆怅。</li><li>四年来，同学也只是同学了，我也明白多少故事里的同学叫做同窗、同门的含义，再也没有 18 岁前那份同学情谊的真诚炙热，大学四年没有出生入死、没有知己知彼、没有懂我念我，同学间仅有的只有利益的纠葛、和资源的争夺，少了些纯粹，多了些市侩，现在回顾这也就是低级学府的表达，只能怪自己前 18 年没有让自己到达高等的 level。</li><li>今天是我在武汉的最后一天了，同班同学合照留念聚餐的例行公事矛盾又和谐，这四年里最喜爱的两位老师也是给我资源最多的两位老师（现在可以称为通俗意义上的恩师）对于我的意义之重不必多言，遗憾在于只能与其一合影，恰巧今天正值儿童节，也不太好意思打扰老师陪伴孩子的时间，对于我只能算是遗憾。</li><li>今年我们学院的就业质量报告会搞了一帮考研成功的上去讲…今年我们院就业率和考研率都特别低…搞不懂在就业分析的场合为什么要搞几个考研成功的人上去给学弟学妹打鸡血…每年这样都会让更多人蒙蔽双眼冲去考研然后错过就业的档口结果也很失败…这种垃圾书记辅导员就只能做出这样的事情…我们学院每年都换宿舍然后就导致现在大家就完全没有一点毕业的感觉…哀其不幸…人啊…大多数只想做好自己的工作永远没有大局观永远用别人的苦乐作为自己的看点…我为我高中的不努力感到悲哀我为我在这样的环境里四年感到不幸…大学四年说实在的没有任何一个人真的影响到我…同门之间的斗争充斥在整个大学生活中…我不清楚是我的问题还是这个环境的问题…惋惜我遗失的四年…我感谢这四年的每一个人的帮助…我痛恨这四年的每一个人的丑恶…但还好在最后遇到了你可以让我信任和守护…希望我们都能在有限的时间里追上命运实现我们的价值…希望这个社会在未来能够得以改变但我也知道这是不可能的至少在所有人的伪善中是不可能的。</li><li>由于更换宿舍的原因大家之间的生疏，因此想在最后的时刻和以往的室友们一一道别，结果去了三个人的宿舍一个不在两个在专注游戏甚至没有察觉到我（我没有把自己抬高的意思），唉，想和大家聊的还真多，但这样的场景还有谁能说得出口呢？还不如把这些思绪全部封存，在跨越长江的时候全部倾泻，不要在意过去的人际关系、不要介意这四年来他们的看法，过去就让他过去，每个人都孤立、没有谁能兼济四下，更不要说是兼济天下了。</li></ul><h1 id="转身跳进西湖"><a href="#转身跳进西湖" class="headerlink" title="转身跳进西湖"></a>转身跳进西湖</h1><ul><li>从艰难的春招走过所幸还得到了社会的信赖，目前只实习了 9 天，这 9 天里有一说一没有自我、没有想象的感觉，四下的陌生、跨年龄的代沟让我疲倦，找不到我的锐气…可能这也是父亲说挫挫你的锐气的实际体现。</li><li>如果我挺不过来更不要说实现自己的志向了，虽然现在整体还没有轮廓，但已经看到它就在那了。</li><li>一杯长岛下肚，转身跳进西湖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;300&quot; height=&quot;50&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=12187
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>解析SharePreferences</title>
    <link href="https://edward7zhang.github.io/2019/03/23/%E8%A7%A3%E6%9E%90SharePreferences/"/>
    <id>https://edward7zhang.github.io/2019/03/23/解析SharePreferences/</id>
    <published>2019-03-23T04:07:14.000Z</published>
    <updated>2019-03-23T13:08:40.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="彻底搞懂-SharedPreferences"><a href="#彻底搞懂-SharedPreferences" class="headerlink" title="彻底搞懂 SharedPreferences"></a>彻底搞懂 SharedPreferences</h1><p>我们知道 <code>SharedPreferences</code> 会从文件读取 xml 文件, 并将其以 <code>getXxx/putXxx</code> 的形式提供读写服务. 其中涉及到如下几个问题:</p><ol><li>如何从磁盘读取配置到内存</li><li>getXxx 如何从内存中获取配置</li><li>最终配置如何从内存回写到磁盘</li><li>多线程/多进程是否会有问题</li><li>最佳实践</li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li><code>SharedPreferences</code> 是线程安全的. 内部由大量 <code>synchronized</code> 关键字保障</li><li><code>SharedPreferences</code> <strong>不是进程安全的</strong></li><li>第一次 <code>getSharedPreferences</code> 会读取磁盘文件, 后续的 <code>getSharedPreferences</code> 会从内存缓存中获取. 如果第一次调用 <code>getSharedPreferences</code> 时还没从磁盘加载完毕就调用 getXxx/putXxx , 则 getXxx/putXxx 操作会卡主, 直到数据从磁盘加载完毕后返回</li><li>所有的 getXxx 都是从内存中取的数据</li><li><code>apply</code> 是同步回写内存, 然后把异步回写磁盘的任务放到一个单线程的队列中等待调度. <code>commit</code> 和前者一样, 只不过要等待异步磁盘任务结束后才返回</li><li><code>MODE_MULTI_PROCESS</code> 是在每次 <code>getSharedPreferences</code> 时检查磁盘上配置文件上次修改时间和文件大小, 一旦所有修改则会重新从磁盘加载文件. 所以并不能保证多进程数据的实时同步</li><li>从 Android N 开始, 不再支持 MODE_WORLD_READABLE &amp; MODE_WORLD_WRITEABLE. 一旦指定, 会抛异常</li></ul><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul><li>不要多进程使用, 很小几率会造成数据全部丢失, 现象是配置文件被删除</li><li>不要依赖 <code>MODE_MULTI_PROCESS</code>. 这个标记就像 <code>MODE_WORLD_READABLE/MODE_WORLD_WRITEABLE</code> 未来会被废弃</li><li>每次 <code>apply</code> / <code>commit</code> 都会把全部的数据一次性写入磁盘, 所以单个的配置文件不应该过大, 影响整体性能</li></ul><h1 id="源码全面分析"><a href="#源码全面分析" class="headerlink" title="源码全面分析"></a>源码全面分析</h1><p>现在我们从源码入手, 彻底搞懂 <code>SharedPreferences</code> 有关的所有问题. 本文并不是入门教程, 主要面向有 <code>SharedPreferences</code> 基础的同学</p><h3 id="SharedPreferences-对象的获取"><a href="#SharedPreferences-对象的获取" class="headerlink" title="SharedPreferences 对象的获取"></a>SharedPreferences 对象的获取</h3><p>一般来说有如下方式:<br>1. PreferenceManager.getDefaultSharedPreferences<br>2. ContextImpl.getSharedPreferences</p><p>我们以上述 [1] 为例来看看源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// PreferenceManager.java</div><div class="line">public static SharedPreferences getDefaultSharedPreferences(Context context) &#123;</div><div class="line">    return context.getSharedPreferences(getDefaultSharedPreferencesName(context),</div><div class="line">            getDefaultSharedPreferencesMode());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述无论那种方法, 最终都是调用到了 <code>ContextImpl.getSharedPreferences</code>. 源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// ContextImpl.java</div><div class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</div><div class="line">    checkMode(mode);</div><div class="line">    SharedPreferencesImpl sp;</div><div class="line">    synchronized (ContextImpl.class) &#123;</div><div class="line">        final ArrayMap&amp;lt;File, SharedPreferencesImpl&amp;gt; cache = getSharedPreferencesCacheLocked();</div><div class="line">        sp = cache.get(file);</div><div class="line">        if (sp == null) &#123;</div><div class="line">            sp = new SharedPreferencesImpl(file, mode);</div><div class="line">            cache.put(file, sp);</div><div class="line">            return sp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if ((mode &amp;amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">        getApplicationInfo().targetSdkVersion &amp;lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        // If somebody else (some other process) changed the prefs</div><div class="line">        // file behind our back, we reload it.  This has been the</div><div class="line">        // historical (if undocumented) behavior.</div><div class="line">        sp.startReloadIfChangedUnexpectedly();</div><div class="line">    &#125;</div><div class="line">    return sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可见 sdk 是先取了缓存, 如果缓存未命中, 才构造对象. 也就是说, <strong>多次 <code>getSharedPreferences</code> 几乎是没有代价的</strong>. 同时, 实例的构造被 <code>synchronized</code> 关键字包裹, 因此构造过程是多线程安全的</p><h3 id="SharedPreferences-的构造"><a href="#SharedPreferences-的构造" class="headerlink" title="SharedPreferences 的构造"></a>SharedPreferences 的构造</h3><p>我们再来看看第一次构建对象时发生了什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">SharedPreferencesImpl(File file, int mode) &#123;</div><div class="line">    mFile = file;</div><div class="line">    mBackupFile = makeBackupFile(file);</div><div class="line">    mMode = mode;</div><div class="line">    mLoaded = false;</div><div class="line">    mMap = null;</div><div class="line">    startLoadFromDisk();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有这么几个关键信息:</p><ol><li><code>mFile</code> 代表我们磁盘上的配置文件</li><li><code>mBackupFile</code> 是一个灾备文件, 用户写入失败时进行恢复, 后面会再说. 其路径是 <code>mFile</code> 加后缀 ‘.bak’</li><li><code>mMap</code> 用于在内存中缓存我们的配置数据, 也就是 <code>getXxx</code> 数据的来源</li></ol><p>还涉及到一个 <code>startLoadFromDisk</code>, 我们来看看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mLoaded = false;</div><div class="line">    &#125;</div><div class="line">    new Thread(&amp;quot;SharedPreferencesImpl-load&amp;quot;) &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            loadFromDisk();</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>开启了一个线程从文件读取, 其源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">private void loadFromDisk() &#123;</div><div class="line">    synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">        if (mLoaded) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (mBackupFile.exists()) &#123;</div><div class="line">            mFile.delete();</div><div class="line">            mBackupFile.renameTo(mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ... 略去无关代码 ...</div><div class="line"></div><div class="line">    str = new BufferedInputStream(</div><div class="line">            new FileInputStream(mFile), 16*1024);</div><div class="line">    map = XmlUtils.readMapXml(str);</div><div class="line"></div><div class="line">    synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">        mLoaded = true;</div><div class="line">        if (map != null) &#123;</div><div class="line">            mMap = map;</div><div class="line">            mStatTimestamp = stat.st_mtime;</div><div class="line">            mStatSize = stat.st_size;</div><div class="line">        &#125; else &#123;</div><div class="line">            mMap = new HashMap&amp;lt;&amp;gt;();</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>loadFromDisk</code> 这个函数很关键. 它就是实际从磁盘读取配置文件的函数. 可见, 它做了如下几件事:</p><ol><li>如果有 ‘灾备’ 文件, 则直接使用灾备文件回滚.</li><li>把配置从磁盘读取到内存的并保存在 <code>mMap</code> 字段中(看代码最后 <code>mMap = map</code>)</li><li>标记读取完成, 这个字段后面 <code>awaitLoadedLocked</code> 会用到. 记录读取文件的时间, 后面 <code>MODE_MULTI_PROCESS</code> 中会用到</li><li>发一个 <code>notifyAll</code> 通知已经读取完毕, 激活所有等待加载的其他线程</li></ol><p>总结一下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/23/5c962fa2af626.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="getXxx-的流程"><a href="#getXxx-的流程" class="headerlink" title="getXxx 的流程"></a>getXxx 的流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">public String getString(String key, @Nullable String defValue) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">        String v = (String)mMap.get(key);</div><div class="line">        return v != null ? v : defValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可见, 所有的 <strong>get 操作都是线程安全的</strong>. 并且 get 仅仅是从内存中(<code>mMap</code>) 获取数据, 所以<strong>无性能问题</strong>.</p><p>考虑到 <em>配置文件的加载</em> 是在单独的线程中异步进行的(参考 ‘SharedPreferences 的构造’), 所以这里的 <code>awaitLoadedLocked</code> 是在等待配置文件加载完毕. 也就是说如果我们第一次构造 SharedPreferences 后就立刻调用 getXxx 方法, 很有可能读取配置文件的线程还未完成, 所以这里要等待该线程做完相应的加载工作. 来看看 <code>awaitLoadedLocked</code> 的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java private void awaitLoadedLocked() &#123; if (!mLoaded) &#123; // Raise an explicit StrictMode onReadFromDisk for this // thread, since the real read will be in a different // thread and otherwise ignored by StrictMode. BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">    &#125; while (!mLoaded) &#123; try &#123; wait(); &#125; catch (InterruptedException unused) &#123; &#125; &#125; &#125;</div></pre></td></tr></table></figure><p>很明显, 如果加载还未完成(<code>mLoaded == false</code>), getXxx 会卡在 <code>awaitLoadedLocked</code>, 一旦加载配置文件的线程工作完毕, 则这个加载线程会通过 <code>notifyAll</code> 会通知所有在 <code>awaitLoadedLocked</code> 中等待的线程, getXxx 就能够返回了. 不过大部分情况下, <code>mLoaded == true</code>. 这样的话 <code>awaitLoadedLocked</code> 会直接返回</p><h3 id="putXxx-的流程"><a href="#putXxx-的流程" class="headerlink" title="putXxx 的流程"></a>putXxx 的流程</h3><p>set 比 get 稍微麻烦一点儿, 因为涉及到 <code>Editor</code> 和 <code>MemoryCommitResult</code> 对象</p><p>先来看看 <code>edit()</code> 方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">public Editor edit() &#123;</div><div class="line">    // TODO: remove the need to call awaitLoadedLocked() when</div><div class="line">    // requesting an editor.  will require some work on the</div><div class="line">    // Editor, but then we should be able to do:</div><div class="line">    //</div><div class="line">    //      context.getSharedPreferences(..).edit().putString(..).apply()</div><div class="line">    //</div><div class="line">    // ... all without blocking.</div><div class="line">    synchronized (this) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new EditorImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h6 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h6><p><code>Editor</code> 没有构造函数, 只有两个属性被初始化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">public final class EditorImpl implements Editor &#123;</div><div class="line">    private final Map&amp;lt;String, Object&amp;gt; mModified = Maps.newHashMap();</div><div class="line">    private boolean mClear = false;</div><div class="line"></div><div class="line">    ... 略去方法定义 ...</div><div class="line">    public Editor putString(String key, @Nullable String value) &#123; ... &#125;</div><div class="line">    public boolean commit() &#123; ... &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>mModified</code> 是我们每次 putXxx 后所改变的配置项</li><li><code>mClear</code> 标识要清空配置项, 但是只清了 <code>SharedPreferences.mMap</code>. 所以不要写这样的愚蠢代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sharedPreferences.edit()</div><div class="line">        .putBoolean(&amp;quot;foo&amp;quot;, true)        // foo 无法被 clear 掉</div><div class="line">        .clear()</div><div class="line">        .putBoolean(&amp;quot;bar&amp;quot;, true)</div><div class="line">        .commit()</div></pre></td></tr></table></figure><p><code>edit()</code> 会保障配置已从磁盘读取完毕, 然后仅仅创建了一个对象. 接下来看看 <code>putXxx</code> 的真身:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">public Editor putString(String key, @Nullable String value) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mModified.put(key, value);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>很简单, 仅仅是把我们设置的配置项放到了 <code>mModified</code> 属性里保存. 等到 <code>apply</code> 或者 <code>commit</code> 的时候回写到内存和磁盘. 咱们分别来看看</p><h6 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h6><p>apply 是各种 ‘最佳实践’ 推荐的方式, 那么它到底是怎么异步工作的呢? 我们来看个究竟:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">public void apply() &#123;</div><div class="line">    final MemoryCommitResult mcr = commitToMemory();</div><div class="line">    final Runnable awaitCommit = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    mcr.writtenToDiskLatch.await();</div><div class="line">                &#125; catch (InterruptedException ignored) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    QueuedWork.add(awaitCommit);</div><div class="line"></div><div class="line">    Runnable postWriteRunnable = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                awaitCommit.run();</div><div class="line">                QueuedWork.remove(awaitCommit);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</div><div class="line"></div><div class="line">    // Okay to notify the listeners before it&amp;#039;s hit disk</div><div class="line">    // because the listeners should always get the same</div><div class="line">    // SharedPreferences instance back, which has the</div><div class="line">    // changes reflected in memory.</div><div class="line">    notifyListeners(mcr);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出大致的脉络:</p><ol><li><code>commitToMemory</code> 应该是把修改的配置项回写到内存</li><li><code>QueuedWork.add(awaitCommit)</code> 貌似没什么卵用</li><li><code>SharedPreferencesImpl.this.enqueueDiskWrite</code> 把配置项加入到一个异步队列中, 等待调度</li></ol><p>我们来看看 <code>commitToMemory</code> 的实现(略去大量无关代码):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">private MemoryCommitResult commitToMemory() &#123;</div><div class="line">    MemoryCommitResult mcr = new MemoryCommitResult();</div><div class="line">    synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line"></div><div class="line">        ... 略去无关 ...</div><div class="line"></div><div class="line">        mcr.mapToWriteToDisk = mMap;</div><div class="line">        mDiskWritesInFlight++;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            for (Map.Entry&amp;lt;String, Object&amp;gt; e : mModified.entrySet()) &#123;</div><div class="line">                String k = e.getKey();</div><div class="line">                Object v = e.getValue();</div><div class="line">                // &amp;quot;this&amp;quot; is the magic value for a removal mutation. In addition,</div><div class="line">                // setting a value to &amp;quot;null&amp;quot; for a given key is specified to be</div><div class="line">                // equivalent to calling remove on that key.</div><div class="line">                if (v == this || v == null) &#123;</div><div class="line">                    mMap.remove(k);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mMap.put(k, v);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mModified.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return mcr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总结来说就两件事:<br>1. 把 <code>Editor.mModified</code> 中的配置项回写到 <code>SharedPreferences.mMap</code> 中, 完成了内存的同步<br>2. 把 <code>SharedPreferences.mMap</code> 保存在了 <code>mcr.mapToWriteToDisk</code> 中. 而后者就是即将要回写到磁盘的数据源</p><p>我们再来回头看看 <code>apply</code> 方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">public void apply() &#123;</div><div class="line">    final MemoryCommitResult mcr = commitToMemory();</div><div class="line"></div><div class="line">    ... 略无关 ...</div><div class="line"></div><div class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>commitToMemory</code> 完成了内存的同步回写</li><li><code>enqueueDiskWrite</code> 完成了硬盘的异步回写, 我们接下来具体看看</li></ul><h6 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</div><div class="line">                                final Runnable postWriteRunnable) &#123;</div><div class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>QueuedWork.singleThreadExecutor</code> 实际上就是 ‘一个线程的线程池’, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// QueuedWork.java</div><div class="line">public static ExecutorService singleThreadExecutor() &#123;</div><div class="line">    synchronized (QueuedWork.class) &#123;</div><div class="line">        if (sSingleThreadExecutor == null) &#123;</div><div class="line">            // TODO: can we give this single thread a thread name?</div><div class="line">            sSingleThreadExecutor = Executors.newSingleThreadExecutor();</div><div class="line">        &#125;</div><div class="line">        return sSingleThreadExecutor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出 google 工程师这里还留了一个 todo, 想要给这个专门负责向磁盘同步配置项的线程起一个名字. 这里坐等大神你给 google 提个 pr</p><p>回到 <code>enqueueDiskWrite</code> 中, 这里还有一个重要的函数叫做 <code>writeToFile</code>:</p><h6 id="writeToFile"><a href="#writeToFile" class="headerlink" title="writeToFile"></a>writeToFile</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">    // Rename the current file so it may be used as a backup during the next read</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mBackupFile.exists()) &#123;</div><div class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFile.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attempt to write the file, delete the backup and return true as atomically as</div><div class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</div><div class="line">    // from the backup.</div><div class="line">    try &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        try &#123;</div><div class="line">            final StructStat stat = Os.stat(mFile.getPath());</div><div class="line">                mStatTimestamp = stat.st_mtime;</div><div class="line">                mStatSize = stat.st_size;</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Clean up an unsuccessfully written file</div><div class="line">    mFile.delete();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码大致分为三个过程:<br>1. 先把已存在的老的配置文件重命名(加 ‘.bak’ 后缀), 然后删除老的配置文件. 这相当于做了灾备<br>2. 向 <code>mFile</code> 中一次性写入所有配置项. 即 <code>mcr.mapToWriteToDisk</code>(这就是 <code>commitToMemory</code> 所说的保存了所有配置项的字段) 一次性写入到磁盘. 如果写入成功则删除灾备文件, 同时记录了这次同步的时间<br>3. 如果上述过程 [2] 失败, 则删除这个半成品的配置文件</p><p>好了, 我们来总结一下 <code>apply</code>:<br>1. 通过 <code>commitToMemory</code> 将修改的配置项同步回写到内存 <code>SharedPreferences.mMap</code> 中. 此时, 任何的 getXxx 都可以获取到最新数据了<br>2. 通过 <code>enqueueDiskWrite</code> 调用 <code>writeToFile</code> 将所有配置项一次性异步回写到磁盘. 这是一个单线程的线程池</p><p>来看个时序图压压惊(<a href="https://link.juejin.im/?target=http%3A%2F%2Fandroid.walfud.com%2Fwp-content%2Fuploads%2F2017%2F07%2Fapply.png" target="_blank" rel="external">点击大图</a>):</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/7/24/a1918098002429beac3c2c3f52d70fce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h6 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h6><p>看过了 <code>apply</code> 再看 <code>commit</code> 就非常容易了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// SharedPreferencesImpl.java</div><div class="line">public boolean commit() &#123;</div><div class="line">    MemoryCommitResult mcr = commitToMemory();</div><div class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</div><div class="line">        mcr, null /* sync write on this thread okay */);</div><div class="line">    try &#123;</div><div class="line">        mcr.writtenToDiskLatch.await();</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    notifyListeners(mcr);</div><div class="line">    return mcr.writeToDiskResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>直接看时序图吧(<a href="https://link.juejin.im/?target=http%3A%2F%2Fandroid.walfud.com%2Fwp-content%2Fuploads%2F2017%2F07%2Fcommit.png" target="_blank" rel="external">点击大图</a>):</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/7/24/ab15dd8a3af142fe7c092903381c87e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>只需关注最后一条 ‘等待异步任务返回’ 的线, 对比 <code>apply</code> 的时序图, 一眼就看出差别</p><h6 id="registerOnSharedPreferenceChangeListener"><a href="#registerOnSharedPreferenceChangeListener" class="headerlink" title="registerOnSharedPreferenceChangeListener"></a>registerOnSharedPreferenceChangeListener</h6><p>最后需要提一下的就是 listener:</p><ul><li>对于 <code>apply</code>, listener 回调时内存已经完成同步, 但是异步磁盘任务不保证是否完成</li><li>对于 <code>commit</code>, listener 回调时内存和磁盘都已经同步完毕</li></ul><h1 id="各种标记的作用"><a href="#各种标记的作用" class="headerlink" title="各种标记的作用"></a>各种标记的作用</h1><h3 id="MODE-PRIVATE-MODE-WORLD-READABLE-MODE-WORLD-WRITEABLE"><a href="#MODE-PRIVATE-MODE-WORLD-READABLE-MODE-WORLD-WRITEABLE" class="headerlink" title="MODE_PRIVATE/MODE_WORLD_READABLE/MODE_WORLD_WRITEABLE:"></a>MODE_PRIVATE/MODE_WORLD_READABLE/MODE_WORLD_WRITEABLE:</h3><p>指的是, 在保存文件的时候设置的文件属性. PRIVATE 就只有自己和所属组的读写权限, READABLE/WRITEABLE 是对 other 用户和组的读写权限. 主要源码位于: FileUtils.setPermissions</p><h3 id="MODE-MULTI-PROCESS"><a href="#MODE-MULTI-PROCESS" class="headerlink" title="MODE_MULTI_PROCESS:"></a>MODE_MULTI_PROCESS:</h3><p>阅读过本文的话你会知道, 一个 prefs 实例通常有两种获得途径, 一个是第一次被 new 创建出来的, 这种方式会实际的读取磁盘文件. 还一种是后续从缓存(sSharedPrefsCache) 中取出来了.</p><p>而这个标记的意思就是: 使用 getSharedPrefercences 获取实例时, 无论是从磁盘读文件构造对象还是从缓存获取, 都会检查实例的 ‘内存中保存的时间’ 和 ‘磁盘上文件的最后修改时间’, 如果内存中保存的时间和磁盘上文件的最后修改时间, 则重新加载文件. 可以认为如果实例是从磁盘读取构造出来的, 那么他的 ‘内存中保存的时间’ 和 ‘文件的最后修改时间’ 一定是一样的, 而从缓存中来的实例就不一样了, 因为它可能很早就被创建(那个时候就已经读取了磁盘的文件并记录了当时文件的最后修改时间), 在随后的期间里其他进程很可能修改过磁盘上的配置文件导致最后修改时间变化, 这时候当我们从缓存中再次获取这个实例的时候, 系统会帮你检查这个文件在这段时间是否被修改过(‘内存中保存的时间’ 和 ‘磁盘上文件的最后修改时间’ 是否一致), 如果被修改过, 则重新从磁盘读取配置文件, 保证获取实例的内容是最新的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;彻底搞懂-SharedPreferences&quot;&gt;&lt;a href=&quot;#彻底搞懂-SharedPreferences&quot; class=&quot;headerlink&quot; title=&quot;彻底搞懂 SharedPreferences&quot;&gt;&lt;/a&gt;彻底搞懂 SharedPreferenc
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>说23种设计模式，也说算法与数据结构</title>
    <link href="https://edward7zhang.github.io/2019/03/19/%E8%AF%B423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B9%9F%E8%AF%B4%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://edward7zhang.github.io/2019/03/19/说23种设计模式，也说算法与数据结构/</id>
    <published>2019-03-19T04:07:14.000Z</published>
    <updated>2019-03-20T08:26:56.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h1><p> 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。简单说：</p><p><strong>模式：在某些场景下，针对某类问题的某种通用的解决方案。</strong></p><p>场景：项目所在的环境</p><p>问题：约束条件，项目目标等</p><p>解决方案：通用、可复用的设计，解决约束达到目标。</p><h1 id="设计模式的三个分类"><a href="#设计模式的三个分类" class="headerlink" title="设计模式的三个分类"></a>设计模式的三个分类</h1><p> <strong>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong></p><p><strong>结构型模式：把类或对象结合在一起形成一个更大的结构。</strong></p><p><strong>行为型模式：类和对象如何交互，及划分责任和算法。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/19/5c9089a16c426.png" alt="设计模式.png" title="">                </div>                <div class="image-caption">设计模式.png</div>            </figure><h1 id="概说-23-种设计模式"><a href="#概说-23-种设计模式" class="headerlink" title="概说 23 种设计模式"></a>概说 23 种设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p> 单例模式，它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。</p><p>单例模式具备典型的 3 个特点：</p><ol><li>只有一个实例。 </li><li>自我实例化。 </li><li>提供全局访问点。</li></ol><p>因此当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。</p><p>单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了 “单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难。其 UML 结构图非常简单，就只有一个类，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/20/5c91dbf433523.png" alt="Design Patterns - Singleton.png" title="">                </div>                <div class="image-caption">Design Patterns - Singleton.png</div>            </figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>作为抽象工厂模式的孪生兄弟，工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。</p><p>工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无需修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无需关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品就需要增加两个类，这样势必会导致系统的复杂度增加。其 UML 结构图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/20/5c91db7799896.png" alt="Design Patterns - Factory.png" title="">                </div>                <div class="image-caption">Design Patterns - Factory.png</div>            </figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。它允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更改接口及其下所有子类。其 UML 结构图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/20/5c91db77aeffe.png" alt="Design Patterns - AbstractFactory.png" title="">                </div>                <div class="image-caption">Design Patterns - AbstractFactory.png</div>            </figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>对于建造者模式，它主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂。</p><p>建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式，毕竟这个世界上存在相同点多的两个产品不是很多，所以它的使用范围有限。其 UML 结构图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/20/5c91db779984e.png" alt="Design Patterns - Builder.png" title="">                </div>                <div class="image-caption">Design Patterns - Builder.png</div>            </figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>在我们应用程序可能有某些对象的结构比较复杂，但是我们有需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><p>它主要应用于那些创建新对象的成本过大时。它的主要优点就是简化了新对象的创建过程，提高了效率，同时原型模式提供了简化的创建结构。UML 结构图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/20/5c91db77a1c73.png" alt="Design Patterns - Prototype.png" title="">                </div>                <div class="image-caption">Design Patterns - Prototype.png</div>            </figure><p> <strong>模式结构</strong><br>原型模式包含如下角色：<br>Prototype：抽象原型类<br>ConcretePrototype：具体原型类<br>Client：客户类</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>在我们的应用程序中我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。</p><p>作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/20/5c91db77bb492.png" alt="Design Patterns - Adapter.png" title="">                </div>                <div class="image-caption">Design Patterns - Adapter.png</div>            </figure><p>适配器模式包含如下角色：<br>Target：目标抽象类<br>Adapter：适配器类<br>Adaptee：适配者类<br>Client：客户类</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>别名：柄体模式</p><ul><li>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是讲这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，这个分离过程就使用了桥接模式。所谓桥接模式就是讲抽象部分和实现部分隔离开来，使得他们能够独立变化。</li></ul><p>桥接模式将继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/20/5c91e6dac4806.png" alt="Design Patterns - Handle-Body.png" title="">                </div>                <div class="image-caption">Design Patterns - Handle-Body.png</div>            </figure><p>桥接模式包括如下角色：</p><ul><li>抽象（Abstraction）：是一个抽象类，该抽象类含有 Implementor 声明的变量，即维护一个 Implementor 类型对象。</li><li>实现者（Implementor）：实现者角色是一个接口（抽象类），该接口（抽象类）中的方法不一定与 Abstraction 类中的方法一致。Implementor 接口（抽象类）负责定义基本操作，而 Abstraction 类负责定义基于操作的较高层次的操作。</li><li>细化抽象（Refined Abstraction）：细化抽象是抽象角色的一个子类，该子类在重写（覆盖）抽象角色中的抽象方法时，在给出一些必要的操作后，将委托所维护 Implementor 类型对象调用相应的方法。</li><li>具体实现者（Concrete Implementor）：具体实现者是实现（扩展）Implementor 接口（抽象类）的类。</li></ul><blockquote><p>未完待续。。。</p></blockquote><hr><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/19/5c90a189cccd1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(n^2)$</td><td>$O(1)$</td><td>√</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;<span class="comment">//第0位独自作为有序数列，从第1位开始向后遍历</span></div><div class="line">        <span class="keyword">if</span>(array[i]&lt;array[i-<span class="number">1</span>])(&#123;<span class="comment">//0~i-1位为有序，若第i位小于i-1位，继续寻位并插入，否则认为0~i位也是有序的，忽略此次循环，相当于continue</span></div><div class="line">            <span class="keyword">int</span> temp=array[i];<span class="comment">//保存第i位的值</span></div><div class="line">            <span class="keyword">int</span> k = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;array[j];j--)&#123;<span class="comment">//从第i-1位向前遍历并移位，直至找到小于第i位值停止</span></div><div class="line">                array[j+<span class="number">1</span>]=array[j];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            array[k+<span class="number">1</span>]=temp;<span class="comment">//插入第i位的值</span></div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"><span class="comment">//时间复杂度O(n*n) 性能上优于冒泡排序和选择排序</span></div></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(n^2)$</td><td>$O(1)$</td><td>√</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> temp = array[i];</div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> high = i - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (temp &lt; array[mid]) &#123;</div><div class="line">                high = mid - <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                low = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= low + <span class="number">1</span>; j--) &#123;</div><div class="line">            array[j] = array[j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        array[low] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h3><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(n^{1.3})$ ~ $O(n^2)$</td><td>$O(1)$</td><td>×</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序的原理:根据需求，如果你想要结果从小到大排列，它会首先将数组进行分组，然后将较小值移到前面，较大值</div><div class="line"> * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数，</div><div class="line"> * 可以说希尔排序是加强 版的插入排序 拿数组5, 2,8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列</div><div class="line"> * 5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较</div><div class="line"> * 此例子是按照从小到大排列，所以小的会排在前面，第一次排序后数组为5, 1, 3, 4, 2, 8，9</div><div class="line"> * 第一次后increment的值变为3/2=1,此时对数组进行插入排序， 实现数组从大到小排</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 每次将步长缩短为原来的一半</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> increment = data.length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; data.length; i++) &#123;</div><div class="line">            temp = data[i];</div><div class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment; j -= increment) &#123;</div><div class="line">                <span class="keyword">if</span> (temp &lt; data[j - increment])<span class="comment">// 从小到大排</span></div><div class="line">                &#123;</div><div class="line">                    data[j] = data[j - increment];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            data[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(n^2)$</td><td>$O(1)$</td><td>×</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> size = numbers.length;</div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size-<span class="number">1</span>&amp;&amp;flag; i++)&#123;</div><div class="line">flag = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size-<span class="number">1</span>-i; j++)&#123;</div><div class="line"><span class="keyword">if</span>(numbers[j] &gt;numbers[j+<span class="number">1</span>])&#123;</div><div class="line">temp = numbers[j];</div><div class="line">numbers[j] = numbers[j + <span class="number">1</span>];</div><div class="line">numbers[j + <span class="number">1</span>] = temp;</div><div class="line">flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(nlogn)$</td><td>$O(log_2n)$ ~ $O(n)$</td><td>×</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> numbers</div><div class="line"> *            带排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (numbers.length &gt; <span class="number">0</span>) <span class="comment">// 查看数组是否为空</span></div><div class="line">    &#123;</div><div class="line">        quickSort(numbers, <span class="number">0</span>, numbers.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> numbers</div><div class="line"> *            带排序数组</div><div class="line"> * <span class="doctag">@param</span> low</div><div class="line"> *            开始位置</div><div class="line"> * <span class="doctag">@param</span> high</div><div class="line"> *            结束位置</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> middle = getMiddle(numbers, low, high); <span class="comment">// 将numbers数组进行一分为二</span></div><div class="line">    quickSort(numbers, low, middle - <span class="number">1</span>); <span class="comment">// 对低字段表进行递归排序</span></div><div class="line">    quickSort(numbers, middle + <span class="number">1</span>, high); <span class="comment">// 对高字段表进行递归排序</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> numbers</div><div class="line"> *            带查找数组</div><div class="line"> * <span class="doctag">@param</span> low</div><div class="line"> *            开始位置</div><div class="line"> * <span class="doctag">@param</span> high</div><div class="line"> *            结束位置</div><div class="line"> * <span class="doctag">@return</span> 中轴所在位置</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = numbers[low]; <span class="comment">// 数组的第一个作为中轴</span></div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[high] &gt; temp) &#123;</div><div class="line">            high--;</div><div class="line">        &#125;</div><div class="line">        numbers[low] = numbers[high];<span class="comment">// 比中轴小的记录移到低端</span></div><div class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[low] &lt; temp) &#123;</div><div class="line">            low++;</div><div class="line">        &#125;</div><div class="line">        numbers[high] = numbers[low]; <span class="comment">// 比中轴大的记录移到高端</span></div><div class="line">    &#125;</div><div class="line">    numbers[low] = temp; <span class="comment">// 中轴记录到尾</span></div><div class="line">    <span class="keyword">return</span> low; <span class="comment">// 返回中轴的位置</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//时间复杂度O(nlogn）</span></div></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(n^2)$</td><td>$O(1)$</td><td>×</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = numbers.length; <span class="comment">// 数组长度</span></div><div class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 中间变量</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size-<span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="keyword">int</span> k = i; <span class="comment">// 待确定的位置</span></div><div class="line">        <span class="comment">// 选择出应该在第i个位置的数</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt; i; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (numbers[j] &lt; numbers[k]) &#123;</div><div class="line">                k = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 交换两个数</span></div><div class="line">        temp = numbers[i];</div><div class="line">        numbers[i] = numbers[k];</div><div class="line">        numbers[k] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//时间复杂度O(n*n) 性能上优于冒泡排序 交换次数少</span></div></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(nlog_2n)$</td><td>$O(1)$</td><td>×</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> arrayLength = a.length;</div><div class="line">    <span class="comment">// 循环建堆</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayLength - <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="comment">// 建堆</span></div><div class="line">        buildMaxHeap(a, arrayLength - <span class="number">1</span> - i);</div><div class="line">        <span class="comment">// 交换堆顶和最后一个元素</span></div><div class="line">        swap(a, <span class="number">0</span>, arrayLength - <span class="number">1</span> - i);</div><div class="line">        System.out.println(Arrays.toString(a));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 对data数组从0到lastIndex建大顶堆</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从lastIndex处节点（最后一个节点）的父节点开始</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (lastIndex - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">// k保存正在判断的节点</span></div><div class="line">        <span class="keyword">int</span> k = i;</div><div class="line">        <span class="comment">// 如果当前k节点的子节点存在</span></div><div class="line">        <span class="keyword">while</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt;= lastIndex) &#123;</div><div class="line">            <span class="comment">// k节点的左子节点的索引</span></div><div class="line">            <span class="keyword">int</span> biggerIndex = <span class="number">2</span> * k + <span class="number">1</span>;</div><div class="line">            <span class="comment">// 如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span></div><div class="line">            <span class="keyword">if</span> (biggerIndex &lt; lastIndex) &#123;</div><div class="line">                <span class="comment">// 若果右子节点的值较大</span></div><div class="line">                <span class="keyword">if</span> (data[biggerIndex] &lt; data[biggerIndex + <span class="number">1</span>]) &#123;</div><div class="line">                    <span class="comment">// biggerIndex总是记录较大子节点的索引</span></div><div class="line">                    biggerIndex++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果k节点的值小于其较大的子节点的值</span></div><div class="line">            <span class="keyword">if</span> (data[k] &lt; data[biggerIndex]) &#123;</div><div class="line">                <span class="comment">// 交换他们</span></div><div class="line">                swap(data, k, biggerIndex);</div><div class="line">                <span class="comment">// 将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值</span></div><div class="line">                k = biggerIndex;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 交换</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> tmp = data[i];</div><div class="line">    data[i] = data[j];</div><div class="line">    data[j] = tmp;</div><div class="line">&#125;</div><div class="line"><span class="comment">//时间复杂度O(nlogn）不适合待排序序列较少的情况</span></div></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(nlog_2n)$</td><td>$O(n)$</td><td>√</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序</div><div class="line"> * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列</div><div class="line"> * 时间复杂度为O(nlogn)</div><div class="line"> * 稳定排序方式</div><div class="line"> * <span class="doctag">@param</span> nums 待排序数组</div><div class="line"> * <span class="doctag">@return</span> 输出有序数组</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</div><div class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">        <span class="comment">// 左边</span></div><div class="line">        sort(nums, low, mid);</div><div class="line">        <span class="comment">// 右边</span></div><div class="line">        sort(nums, mid + <span class="number">1</span>, high);</div><div class="line">        <span class="comment">// 左右归并</span></div><div class="line">        merge(nums, low, mid, high);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nums;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将数组中low到high位置的数进行排序</div><div class="line"> * <span class="doctag">@param</span> nums 待排序数组</div><div class="line"> * <span class="doctag">@param</span> low 待排的开始位置</div><div class="line"> * <span class="doctag">@param</span> mid 待排中间位置</div><div class="line"> * <span class="doctag">@param</span> high 待排结束位置</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></div><div class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 把较小的数先移到新数组中</span></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</div><div class="line">            temp[k++] = nums[i++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            temp[k++] = nums[j++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把左边剩余的数移入数组</span></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">        temp[k++] = nums[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></div><div class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</div><div class="line">        temp[k++] = nums[j++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把新数组中的数覆盖nums数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</div><div class="line">        nums[k2 + low] = temp[k2];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//时间复杂度O(nlogn）</span></div></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>$O(d(n+r))$</td><td>$O(r)$</td><td>√</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是设计模式？&quot;&gt;&lt;a href=&quot;#什么是设计模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式？&quot;&gt;&lt;/a&gt;什么是设计模式？&lt;/h1&gt;&lt;p&gt; 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代
      
    
    </summary>
    
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
      <category term="Algorithm" scheme="https://edward7zhang.github.io/tags/Algorithm/"/>
    
      <category term="Design Pattern" scheme="https://edward7zhang.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Android各版本新特性【持续更新...】</title>
    <link href="https://edward7zhang.github.io/2019/03/18/Android%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91/"/>
    <id>https://edward7zhang.github.io/2019/03/18/Android各版本新特性【持续更新】/</id>
    <published>2019-03-18T04:07:14.000Z</published>
    <updated>2019-03-18T03:16:04.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-各版本特性总结、"><a href="#Android-各版本特性总结、" class="headerlink" title="Android 各版本特性总结、"></a>Android 各版本特性总结、</h1><blockquote><p>持续更新中…</p></blockquote><h2 id="Android-9-0"><a href="#Android-9-0" class="headerlink" title="Android 9.0"></a>Android 9.0</h2><ul><li><p>室内 WIFI RTT  定位</p><p>  Android P 为 IEEE 802.11mc WiFi 协议添加了平台支持 (也称为 WiFi 往返时间，RTT)，这可以让您在应用中使用室内定位。<br>  拥有硬件支持的 Android P 设备可以让您的应用使用 RTT API 测量与附近 WiFi 接入点 (AP) 的距离，设备不需要连接到 AP 便可以使用 RTT。为了保持隐私，只有手机能够确定距离，AP 无法做到这一点。<br>  通过测量从设备到三个或更多 AP 的距离，您可以以 1 到 2 米的精度确定设备位置。这种精确度允许您创建更多新的体验：室内导航、基于位置的细粒度服务，例如，模糊语音控制 ( “打开这里的灯” ) ；基于位置的资讯服务 ( “这些优惠是针对这个产品的吗？” )。</p></li><li><p>“刘海”屏幕支持</p><p> 现在应用可以充分利用最新的全面屏设备来展示内容。我们在 Android 平台加入了对凹口屏幕的支持，並提供 API 供您使用，从而管理内容展示方式。<br> 本功能可以在应用中无缝工作，系统会管理状态栏的高度从而将您的内容与裁切区域分开。如果您拥有重要的沉浸式内容，则还可以使用新的 API 查看裁切形状并创建全屏布局。您可以调用 getDisplayCutout() 来判断本地设备是否具有凹口屏幕，然后再确定裁切区域的位置和形状。平台添加了一个新的窗口布局属性 layoutInDisplayCutoutMode 让您告诉系统如何以及何时将您的内容相对于裁剪区域进行布局。</p></li><li><p>通知</p><ul><li>增强体验</li><li>通道设置、广播以及免打扰</li></ul></li><li>多相机支持和相机更新</li><li>新的图片解码</li><li>动画</li><li>HDR VP9视频，HEIF图像压缩和媒体API</li><li>JobScheduler中的数据成本敏感度</li><li>神经网络API 1.1</li><li>改进表单自动填充</li><li>安全增强</li><li>Android 备份加密</li><li>用于 NFC 支付和安全交易的 Open Mobile API</li></ul><h2 id="Android-8-1"><a href="#Android-8-1" class="headerlink" title="Android 8.1"></a>Android 8.1</h2><ul><li><strong>Android Go 简介</strong></li><li><strong>人工智能神经网络 API</strong>(如：TensorFlow)</li><li>自动填充框架更新</li><li>Notification 通知变更</li><li>EditText 更新</li><li>WebView 安全浏览更新</li><li>视频缩略图提取器更新</li><li>共享内存API</li><li>WallpaperColors API</li><li>指纹更新</li></ul><h2 id="Android-8-0"><a href="#Android-8-0" class="headerlink" title="Android 8.0"></a>Android 8.0</h2><ul><li>APP“安装未知应用”功能默认被限制</li><li><strong>优化通知</strong><ul><li>通知渠道 Notification Channel</li><li>通知标志</li><li>休眠</li><li>通知超时</li><li>通知设置</li><li>通知清除</li></ul></li><li>自动填充框架</li><li>画中画模式：清单中Activity设置android:supportsPictureInPicture</li><li><strong>可下载字体</strong>：<a href="https://link.jianshu.com/?t=https://developer.android.google.cn/reference/android/provider/FontsContract.html" target="_blank" rel="external">FontRequest</a></li><li>XML 中的字体</li><li><strong>自动调整 TextView 的大小</strong></li><li><a href="https://link.jianshu.com/?t=https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive.html" target="_blank" rel="external">自适应图标</a></li><li>颜色管理</li><li><a href="https://link.jianshu.com/?t=https://developer.android.google.cn/guide/webapps/managing-webview.html" target="_blank" rel="external">WebView API</a></li><li>多显示器支持</li><li>统一的布局外边距和内边距</li><li>指针捕获</li><li>应用类别</li><li>Android TV 启动器</li><li>AnimatorSet</li><li>新的 StrictMode 检测程序</li><li>缓存数据</li><li>findViewById() 签名变更</li><li>权限</li><li>更新的 Java 支持</li></ul><h2 id="Android-7-1"><a href="#Android-7-1" class="headerlink" title="Android 7.1"></a>Android 7.1</h2><ul><li>加入重启按钮</li><li>App圆形图标</li><li>添加新的Emoji</li></ul><h2 id="Android-7-0"><a href="#Android-7-0" class="headerlink" title="Android 7.0"></a>Android 7.0</h2><ul><li><p><strong>分屏多任务</strong></p><p>进入后台多任务管理页面，然后按住其中一个卡片，然后向上拖动至顶部即可开启分屏多任务，支持上下分栏和左右分栏，允许拖动中间的分割线调整两个APP所占的比例。</p></li><li><p>全新下拉快捷开关页</p><p>Android 7.0中，下拉打开通知栏顶部即可显示5个用户常用的快捷开关，支持单击开关以及长按进入对应设置。如果继续下拉通知栏即可显示全部快捷开关，此外在快捷开关页右下角也会显示一个编辑按钮，点击之后即可自定义添加/删除快捷开关，或拖动进行排序。</p></li><li><p><strong>新通知消息</strong></p><p><strong>通知消息快捷回复</strong></p><p>加入了全新的API，支持第三方应用通知的快捷操作和回复，例如来电会以横幅方式在屏幕顶部出现，提供接听/挂断两个按钮；信息/社交类应用通知，还可以直接打开键盘，在输入栏里进行快捷回复。</p><p><strong>通知消息归拢</strong></p><p>Android7.0会将同一应用的多条通知提示消息归拢为一项，点击该项即可展开此前的全部通知，允许用户对每个通知执行单独操作。</p></li><li><p>流量保护模式</p><p>新增的流量保护模式不仅可以禁止应用在后台使用流量，还会进一步减少该应用在前台时的流量使用。推测其有可能使用了类似Chrome浏览器的数据压缩技术。此外，谷歌还扩展了ConnectivityManager API的能力，使得应用可以检测系统是否开启了流量保护模式，或者检测自己是否在白名单中。Android7.0允许用户单独针对每个应用，选择是否开启数据保护模式。</p></li><li><p>菜单键快速应用切换</p></li><li><p><strong>支持VR</strong></p></li><li><p>引入JIT编译器</p><p>使得App安装速度快了75%，编译代码的规模减少了50%</p></li><li><p><strong>画中画</strong></p></li><li><p>Project Svelte: 后台优化</p></li></ul><h2 id="Android-6-x"><a href="#Android-6-x" class="headerlink" title="Android 6.x"></a>Android 6.x</h2><ul><li><p><strong>动态权限管理</strong></p><p>Android 6.0引入了动态权限管理，将标记为危险的权限从安装时权限模型移动到运行时权限模型。</p><blockquote><p>安装时权限模型(Android5.1以及更早)：用户在应用安装和更新时，对危险权限授权。但是OEM和运行商预装的应用将自动预授权。</p><p>运行时权限(Android6.0及以后)：用户在应用运行时，对应用授予危险权限。由应用决定何时去申请权限（例如，在应用启动时或者用户访问某个特性时），但必须容许用户来授予或者拒绝应用对特定权限组的访问。OEM和运营商可以预装应用，但是不能对权限进行预授权。</p><p>运行时权限提供给用户关于应用所需权限更多的相关上下文和可视性，这也让开发者帮助用户更好的理解：为什么应用需要所请求的权限，授权将有什么样的好处，拒绝将有何种不便。用户可以通过设置中的菜单来撤销应用的权限。</p></blockquote></li><li><p>指纹识别Finger Support</p><p>说到指纹识别，很多用户都会觉得现在的中高端android手机都支持，但事实上这些android手机的指纹识别都是各个厂商自行开发的并没有系统底层的支持。Android 6.0则在系统层面加入指纹识别，能提供原生指纹识别API，这不但降低了厂商开发指纹识别模块的成本，最重要的是原生指纹识别将会大大提升android手机的指纹识别支付安全性</p></li><li><p>电池管理</p><p>Android 6.0使用下列特性来延长电池使用时间：</p><blockquote><p>App Standby（应用待机）: 系统可以将未使用的应用置为AppStandby模式，临时限制这些应用的网络访问，延迟同步和后台job</p><p>Doze（瞌睡）: 如果用户在某个时间期限内未主动使用设备（屏幕关闭、设备静止），平台将进入深度睡眠状态。因为该特性要求平台检测静止状态，因此只有那些在Sensor HAL中实现了显式移动检测API的设备中才有效。</p><p>Exemptions（豁免）: 预装在设备上的系统应用和云消息服务，默认通常被豁免。应用开发者可以要求其应用使用这种设定。用户也可以在设置中来豁免某些应用。</p></blockquote></li><li><p>Android Pay</p><p>Android支付统一标准。新的M系统中集成了Android Pay。其特性在于简洁、安全、可选性。Android Pay是一个开放性平台，用户可以选择谷歌的服务或者使用银行的APP来使用它，Android Pay支持4.4以后的系统设备，Google宣布Android Pay已经与美国三大运营商700多家商店达成合作，支付功能可以使用指纹支付。</p></li><li><p>存储</p><p>在之前，安卓系统虽然可以支持TF卡扩展，但TF卡扩展的容量只能当成外置存储。虽然用户可以把照片、音乐等内容放进去，但App不能安装到其中。在安卓6.0中，当首次插入TF卡的时候，系统会询问会将TF卡作为外置还是内置储存。如果选择作为内置存储，系统则会对TF卡格式化并加密——注意，这会丢失数据！然后，TF卡的容量就和设备的内置存储融合了。</p></li><li><p><strong>取消支持 Apache HTTP 客户端</strong></p></li><li><p>BoringSSL</p></li><li><p>硬件标识符访问权</p></li><li><p>通知</p></li><li><p>音频管理器变更</p></li><li><p><strong>支持文本选择</strong></p></li><li><p>Android 密钥库不再支持 DSA。但仍支持 ECDSA</p></li><li><p>WLAN 和网络连接变更</p></li><li><p>相机服务变更</p></li><li><p>APK 验证</p></li><li><p>USB 连接</p></li></ul><h2 id="Android-5-0"><a href="#Android-5-0" class="headerlink" title="Android 5.0"></a>Android 5.0</h2><ul><li><p><strong>Android Runtime (ART)默认运行平台设置</strong></p><p>支持64位ART虚拟机。新系统放弃了之前一直使用的Dalvik虚拟机，改用了ART模式，实现了真正的跨平台编译。ART虚拟机编译器在内存占用及应用程序加载时间上进行了大幅提升，谷歌承诺所有性能都会比原来提升一倍。另外，对64位的支持也让ART虚拟机如鱼得水，开发者可以针对像ART Cortex-A57这样的64位架构核心开发应用程序。 Android L支持更大的寄存器，支持新的指令集，提升了内存寻址空间，未来Android智能手机将支持4GB以上的内存。</p></li><li><p><strong>全新通知中心设计</strong></p><ul><li>Material Design 样式</li><li>声音和振动</li><li>锁定屏幕可见性</li><li>媒体播放</li></ul><ul><li>浮动通知</li></ul><p>Google在android L中加入了全新风格的通知系统。改进后的通知系统会优先显示对用户来说比较重要的信息，而将不太紧急的内容隐藏起来。用户只需轻轻向下滑动就可以查看全部的通知内容。</p><p>新的通知系统另外一个很酷的新功能是在锁屏界面也可以直接查看通知消息了。不仅如此，用户还可以直接在锁屏的情况下回复或进入应用。另外，如果在操作手机的过程中有电话进入，也不会进行全画面的切换，而是同样以通知的方式告知用户。</p></li><li><p><strong>引入Material Design设计</strong></p><p><strong>扁平化的设计理念，新的视觉语言，在基本元素的处理上，几件了传统的印刷设计，字体版式、网格系统、空间、比例、调色、图像使用等这些基础的平面设计规范。</strong><br>作为我们开发者，最关心的还是如何在项目中使用Material Design风格：<br>设置应用的 targetSdkVersion 和 targetSdkVersion 为21<br>在values目录下的style资源文件中创建一个style，让其继承自 android:Theme.Material<br>在AndroidManifest中指定应用的主题或者Activity的主题为我们设定的样式<br>谷歌官方我们提供了三种配色风格的Material Design样式：</p><pre><code>黑色主题 Theme.Material明亮主题 Theme.Material.Light明亮主题黑色ActionBar Theme.Material.Light.DarkActionBar我们也可以继承系统提供的Material Design样式，进行配色修改：themecolor</code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">android:colorPrimaryDark应用的主要暗色调，statusBarColor默认使用该颜色</div><div class="line">android:statusBarColor状态栏颜色，默认使用colorPrimaryDark</div><div class="line">android:colorPrimary应用的主要色调，actionBar默认使用该颜色</div><div class="line">android:windowBackground窗口背景颜色</div><div class="line">android:navigationBarColor底部栏颜色</div><div class="line">android:colorForeground应用的前景色，ListView的分割线，switch滑动区默认使用该颜色</div><div class="line">android:colorBackground应用的背景色，popMenu的背景默认使用该颜色</div><div class="line">android:colorAccent 一般控件的选种效果默认采用该颜色</div><div class="line">android:colorControlNormal 控件的默认色调　</div><div class="line">android:colorControlHighlight控件按压时的色调</div><div class="line">android:colorControlActivated控件选中时的颜色，默认使用colorAccent</div><div class="line">android:colorButtonNormal默认按钮的背景颜色</div><div class="line">android:textColor Button，textView的文字颜色</div><div class="line">android:textColorPrimaryDisableOnly RadioButton checkbox等控件的文字</div><div class="line">android:textColorPrimary 应用的主要文字颜色，actionBar的标题文字默认使用该颜色</div></pre></td></tr></table></figure><p>主题不仅可以对Application和Activity使用，也可以对某一个控件单使用，或者是在xml布局中给一个根节点控件设置Android:theme属性，来修改它和它所有子控件的主题。<br>如果我们要对特定控件实例做自定义修改，更建议大家可以通过控件自身的API进行设置修改。</p><ul><li><p><strong>Project Volta电池续航改进计划</strong></p><p>Project Volta计划增加了新工具可以让开发者能够更容易的找出为何自己的应用程序会对电量产生比较大的影响，同时确保在执行某些任务时将手机电量的影响降至最低。首先，Battery Historian可以列出手机电量消耗的详细情况，帮助开发者识别电量消耗的原因或者是哪个硬件或任务对电池寿命的影响比较大；而Job Scheduler API则可以让开发者更容易的选择合适的时机触发电量消耗比较高的任务，避免在低电量或未完成充电时更新应用程序。</p><p>而对于用户层面上，Android L 增加了Battery Saver模式，在低电量时系统会调整某些耗电设置，如降低屏幕亮度、限制自动更换背景等。</p></li><li><p>全新的”最近应用程序“</p><p>除了界面风格设计的改变之外，新的最近应用界面还借鉴了Chrome浏览器的理念，采用单独的标签展示方式。而且，谷歌已经向开发者开放了API，所以第三方开发人员可以利用这个改进为特定的应用增加全新的功能。getAppTasks()</p></li><li><p>改进安全性</p></li><li><p>支持多种设备</p><p>可以在智能手机、平板电脑、笔记本电脑、智能电视、汽车、智能手表甚至是各种家用电子产品等设备上使用Android系统。</p></li><li><p>支持OpenGL ES3.1</p></li><li><p>媒体控件和 RemoteControlClient</p></li><li><p><strong>支持Android NDK中的64位</strong></p></li><li><p><strong>只能显示绑定到服务，取消隐藏绑定服务</strong></p></li><li><p>WebView API修改</p></li><li><p>自定义权限唯一性要求</p></li><li><p><strong>TLS/SSL 默认配置变更</strong></p><ul><li>服务器不支持任何已启用的加密套件</li><li>应用对用于连接服务器的加密套件做出错误的假设</li><li>服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展</li></ul></li><li>支持托管配置文件</li></ul><h2 id="Android-4-4"><a href="#Android-4-4" class="headerlink" title="Android 4.4"></a>Android 4.4</h2><ul><li><strong>支持Android Beam</strong></li><li><strong>添加打印框架</strong></li><li>存储访问框架</li><li>低功耗传感器</li><li>添加短信提供程序</li><li><strong>添加全屏沉浸模式</strong><ul><li>Android 沉浸式状态栏的三种实现方式</li><li>兼容库SystemBarTint</li></ul></li><li><strong>添加透明系统 UI 样式</strong></li><li>添加新的媒体功能</li><li>RenderScript Compute<ul><li>持续性能提升</li><li><strong>GPU 加速</strong></li><li>Android NDK 中的 RenderScript</li></ul></li><li>图形<ul><li>GLES2.0 SurfaceFlinge</li><li>新的硬件合成器支持虚拟显示</li></ul></li><li>支持新的连接类型<ul><li>新的蓝牙配置文件</li><li>红外发射器</li><li>Wi-Fi TDLS 支持</li></ul></li><li>无障碍功能</li><li>安全增强功能</li><li>内存使用率分析工具<ul><li>Procstats</li></ul></li></ul><h2 id="Android-4-0-4-1-4-2-4-3"><a href="#Android-4-0-4-1-4-2-4-3" class="headerlink" title="Android 4.0,4.1,4.2,4.3"></a>Android 4.0,4.1,4.2,4.3</h2><ul><li>支持OpenGL ES 3.0</li><li>增强蓝牙连接</li><li>优化位置和传感器</li><li><strong>添加转场动画</strong></li><li>支持Daydream</li><li><strong>人脸识别解锁</strong></li><li><strong>Photo Sphere 全景相片</strong></li></ul><h1 id="Android-API-对照表"><a href="#Android-API-对照表" class="headerlink" title="Android API 对照表"></a>Android API 对照表</h1><p>Android Beta，发布于2007年11月5日，同时的软件开发套件(SDK)，发布于2007年11月12日。 11月5日被认为是Android的”生日”。</p><p>Android每个版本都有个API Level，对应着某个Android发布版本的名称。</p><table><thead><tr><th>Android版本名称Code name</th><th>Android版本</th><th>版本发布时间</th><th>对应API</th></tr></thead><tbody><tr><td>(no code name)</td><td>1.0</td><td>2008年9月23日</td><td>API level 1</td></tr><tr><td>(no code name)</td><td>1.1</td><td>2009年2月9日</td><td>API level 2</td></tr><tr><td>Cupcake 纸杯蛋糕</td><td>1.5</td><td>2009年4月27日</td><td>API level 3,NDK 1</td></tr><tr><td>Donut 甜甜圈</td><td>1.6</td><td>2009年9月15日</td><td>API level 4,NDK 2</td></tr><tr><td>Eclair 泡芙</td><td>2</td><td>2009年10月26日</td><td>API level 5</td></tr><tr><td>Eclair</td><td>2.0.1</td><td>2009年12月3日</td><td>API level 6</td></tr><tr><td>Eclair</td><td>2.1</td><td>2010年1月12日</td><td>API level 7,NDK3</td></tr><tr><td>Froyo 冻酸奶</td><td>2.2.x</td><td>2010年5月20日</td><td>API level 8,NDK 4</td></tr><tr><td>Gingerbread 姜饼</td><td>2.3 – 2.3.2</td><td>2010年12月6日</td><td>API level 9,NDK5</td></tr><tr><td>Gingerbread</td><td>2.3.3 – 2.3.7</td><td>2011年2月9日</td><td>API level 10</td></tr><tr><td>Honeycomb 蜂巢</td><td>3.0</td><td>2011年2月22日</td><td>API level 11</td></tr><tr><td>Honeycomb</td><td>3.1</td><td>2011年5月10日</td><td>API level 12,NDK 6</td></tr><tr><td>Honeycomb</td><td>3.2.x</td><td>2011年7月15日</td><td>API level 13</td></tr><tr><td>Ice Cream Sandwich</td><td>4.0.1 – 4.0.2</td><td>2011年10月18日</td><td>API level 14,NDK 7</td></tr><tr><td>Ice Cream Sandwich</td><td>4.0.3 – 4.0.4</td><td>2011年12月16日</td><td>API level 15,NDK 8</td></tr><tr><td>Jelly Bean 果冻豆</td><td>4.1.x</td><td>2012年7月9日</td><td>API level 16</td></tr><tr><td>Jelly Bean</td><td>4.2.x</td><td>2012年11月13日</td><td>API level 17</td></tr><tr><td>Jelly Bean</td><td>4.3.x</td><td>2013年7月24日</td><td>API level 18</td></tr><tr><td>KitKat 奇巧</td><td>4.4.x</td><td>2013年10月31日</td><td>API level 19</td></tr><tr><td>KitKat</td><td>4.4W.x</td><td>2014年6月25日</td><td>API level 20</td></tr><tr><td>Lollipop(Android L) 棒棒糖</td><td>5.0 – 5.0.2</td><td>2014年11月12日</td><td>API level 21</td></tr><tr><td>Lollipop(Android L)</td><td>5.1 – 5.1.1</td><td>2015年3月9日</td><td>API level 22</td></tr><tr><td>Marshmallow(Android M)</td><td>6.0 – 6.0.1</td><td>2015年10月5日</td><td>API level 23</td></tr><tr><td>Nougat(Android N) 牛轧糖</td><td>7.0</td><td>2016年8月22日</td><td>API level 24</td></tr><tr><td>Nougat(Android N)</td><td>7.1.1</td><td>2016年10月</td><td>API level 25</td></tr><tr><td>Oreo(Android O) 奥利奥</td><td>8.0</td><td>2017年3月21日</td><td>API level 26</td></tr><tr><td>Oreo(Android O) Android Go</td><td>8.1</td><td>2017年12月6日</td><td>API level 27</td></tr><tr><td>Pistachio Ice Cream(Android P)</td><td>9</td><td>2018年8月6日</td><td>API level 28</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-各版本特性总结、&quot;&gt;&lt;a href=&quot;#Android-各版本特性总结、&quot; class=&quot;headerlink&quot; title=&quot;Android 各版本特性总结、&quot;&gt;&lt;/a&gt;Android 各版本特性总结、&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;持
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android中的内存泄漏总结</title>
    <link href="https://edward7zhang.github.io/2019/03/11/Android%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://edward7zhang.github.io/2019/03/11/Android中的内存泄漏总结/</id>
    <published>2019-03-11T04:07:14.000Z</published>
    <updated>2019-03-12T07:21:37.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。<br>我会从 Java 内存泄漏的基础知识开始，并且通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。<br>篇幅略长，大家可以分几节来看！</p></blockquote><h1 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h1><p>Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配、堆式分配，对应的三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p><ul><li>静态存储区(方法区)：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</li><li>栈区：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>堆区：又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</li></ul><h2 id="栈与堆的区别："><a href="#栈与堆的区别：" class="headerlink" title="栈与堆的区别："></a>栈与堆的区别：</h2><p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。挡在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。<br>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。<br>举个🌰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Sample</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> s1 = <span class="number">0</span>;</div><div class="line">  Sample mSample1 = <span class="keyword">new</span> Sample();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> s2 = <span class="number">1</span>;</div><div class="line">    Sample mSample2 = <span class="keyword">new</span> Sample();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sample mSample3 = <span class="keyword">new</span> Sample();</div></pre></td></tr></table></figure></p><p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。<br>结论：</p><ul><li>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。因为它们属于方法中的变量，生命周期随方法而结束。</li><li>成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）。因为它们属于类，类对象终究是要被 new 出来使用的。</li></ul><p>了解了 Java 的内存分配之后，我们来看看 Java 是怎么管理内存的。</p><h1 id="Java-是如何管理内存"><a href="#Java-是如何管理内存" class="headerlink" title="Java 是如何管理内存"></a>Java 是如何管理内存</h1><p>Java 的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存（基本类型除外），所有的对象都在堆（Heap）中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了 JVM 的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。</p><p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p><p>为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用这指向被引用对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点科大的对象都是有效对象，GC 将不回收这些对象。如果某个对象（连通子图）与这个根顶点不可达（注意，该图为有向图），那么我们认为这个（这些）对象不再被引用，可以被 GC 回收。一下，我们举一个例子说明 JVM 的内存分配情况。以下右图，就是左边程序运行到第 6 行的示意图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/11/5c8674f523b99.jpg" alt="1552315574(1).jpg" title="">                </div>                <div class="image-caption">1552315574(1).jpg</div>            </figure><br>Java 使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如 COM 模型采用计数器方式管理构建，它与有向图相比，精度很低（很难处理循环引用的问题），但执行效率很高。</p><h1 id="什么是-Java-中的内存泄漏"><a href="#什么是-Java-中的内存泄漏" class="headerlink" title="什么是 Java 中的内存泄漏"></a>什么是 Java 中的内存泄漏</h1><p>在 Java 中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即 程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。<br>在 C++ 中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于 C++ 中没有 GC，这些内存将永远回收不回来。在 Java 中，这些不可达的对象都是由 GC 负责回收，因此程序员不需要考虑这部分的内存泄漏。<br>通过分析，我们得知，对于 C++，程序员需要自己管理边和顶点，而对于 Java 程序员只要管理边就可以了（不需要管理顶点的释放）。通过这种方式，Java 提高了编程的效率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/12/5c871a5d9d98d.jpg" alt="1552357959(1).jpg" title="">                </div>                <div class="image-caption">1552357959(1).jpg</div>            </figure><p>因此，通过以上分析，我们知道在 Java 中也有内存泄漏，但范围比 C++ 要小一些。因为 Java 从语言上保证，任何对象都是可达，所有的不可达对象都是由 GC 管理。</p><p>对于程序员来说，GC 基本是透明的，不可见的。虽然我们只有几个函数可以访问 GC，例如运行 GC 的函数 System.gc()，但是根据 Java 语言规范定义，该函数不保证 JVM 的垃圾收集器一定会执行。因为，不同的 JVM 实现者可能使用不同的算法管理 GC。通常，GC 的线程的优先级别较低。JVM 调用 GC 的策略也有很多种，有的是内存使用达到一定程度时，GC 才开始工作，也有定时执行的，有的是平缓执行 GC，有的是中断式执行 GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC 的执行影响应用程序的性能，例如对于基本 Web 的实时系统，如网络游戏等，用户不希望 GC 突然中断应用程序执行而进行垃圾回收，那么我们需要调整 GC 的参数，让 GC 能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun 提供的 HotSpot JVM 就支持这一特性。<br>同样给出一个 Java 内存泄漏的典型例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)&#123;</div><div class="line">  Object o = <span class="keyword">new</span> Object();</div><div class="line">  v.add</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p><h1 id="Android-中常见的内存泄漏汇总"><a href="#Android-中常见的内存泄漏汇总" class="headerlink" title="Android 中常见的内存泄漏汇总"></a>Android 中常见的内存泄漏汇总</h1><ul><li><p>集合类泄漏<br>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量（比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它），那么没有相应的删除机制，很可能导致集合锁占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况要多留一些心眼。</p></li><li><p>单例造成的内存泄漏<br>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">  <span class="keyword">private</span> Context context;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = context;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">      instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context，所以这个 Context 的生命周期的长短至关重要：</p><ol><li>如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</li><li>如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，友谊当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</li></ol><p>正确的方式应该改为下面这种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">  <span class="keyword">private</span> Context context;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = context.getApplicationContext();<span class="comment">//使用Application的context</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">      instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>或者这样写，连 Context 都不用传过来了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在你的Application中添加一个静态方法，getContext() 返回 Application 的 context</span></div><div class="line">···</div><div class="line">context = getApplicationContext();</div><div class="line">···</div><div class="line"><span class="comment">/** </span></div><div class="line">  * 获取全局的context </div><div class="line">  * <span class="doctag">@return</span> 返回全局context对象 </div><div class="line">  */</div><div class="line">  <span class="function">pulic <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">  <span class="keyword">private</span> Context context;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.context = MyApplication.getContext();<span class="comment">//使用Application的context</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">      instance = <span class="keyword">new</span> AppManager();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>匿名内部类/非静态内部类和异步线程<ul><li>非静态内部类创建静态实例造成的内存泄漏<br>有时候我们为了避免可能会在启动频繁的 Activity 中，为了避免重复创建相同的数据资源，可能会出现这种写法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">     setContentView(R.layout.activity_main);</div><div class="line">     <span class="keyword">if</span>(mManager == <span class="keyword">null</span>)&#123;</div><div class="line">       mManager = <span class="keyword">new</span> TestResource();</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//···</span></div><div class="line">   &#125;</div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span></span>&#123;</div><div class="line">   <span class="comment">//···</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul><p>这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法会造成内存泄漏，因为非静态内部类默认会有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或者将该内部类抽取出来封装成一个单例，如果需要使用 Context，请按照上面推荐的使用 Application 的 context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于 Application，Service，Activity 三者的 Context 的应用场景如下：</p><table><thead><tr><th>功能</th><th>Application</th><th style="text-align:right">Service</th><th style="text-align:right">Acativity</th></tr></thead><tbody><tr><td>Start an Activity</td><td>NO1</td><td style="text-align:right">NO1</td><td style="text-align:right">YES</td></tr><tr><td>Show a Dialog</td><td>NO</td><td style="text-align:right">NO</td><td style="text-align:right">YES</td></tr><tr><td>Layout Inflation</td><td>YES</td><td style="text-align:right">YES</td><td style="text-align:right">YES</td></tr><tr><td>Start a Service</td><td>YES</td><td style="text-align:right">YES</td><td style="text-align:right">YES</td></tr><tr><td>Bind to a Service</td><td>YES</td><td style="text-align:right">YES</td><td style="text-align:right">YES</td></tr><tr><td>Send a Broadcast</td><td>YES</td><td style="text-align:right">YES</td><td style="text-align:right">YES</td></tr><tr><td>Register BroadcastReceiver</td><td>YES</td><td style="text-align:right">YES</td><td style="text-align:right">YES</td></tr><tr><td>Load Resource Values</td><td>YES</td><td style="text-align:right">YES</td><td style="text-align:right">YES</td></tr></tbody></table><p>  其中：NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建</p><ul><li>匿名内部类<br>Android 开发经常会继承实现 Activity/Fragment/View,此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄漏<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line">  ···</div><div class="line">  Runnable ref1 = <span class="keyword">new</span> MyRunnable();</div><div class="line">  Runnable ref2 = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  ···</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>ref1 和 ref2 的区别是，ref2 使用了匿名内部类。我们来看看运行时这两个引用的内存：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/03/12/5c874d760fdfd.png" alt="1552370991(1).png" title="">                </div>                <div class="image-caption">1552370991(1).png</div>            </figure><br>可以看到，ref1 没有什么特别的。但 ref2 这个匿名类的实现对象里面多了一个引用：<br>this$0 这个引用指向 MainActivity.this，也就是说当前的 MainActivity 实例会被 ref2 持有，如果将这个引用再传入一个异步线程，此线程和此 Activity 生命周期不一致的时候，就造成了 Activity 的泄漏。</p><ul><li>Handler 造成的内存泄漏<br>Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等 api 都借助 Handler 来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象被线程 MessageQueue 一直持有。由于 Handler 属于 TLS（Thread Local Storage）变量，生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正常释放。<br>举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="comment">// Post a message and delay its execution for 10 minutes.</span></div><div class="line">    mLeakyHandler.postDdelayed(<span class="keyword">new</span> Runnable &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">/** ... */</span>&#125;</div><div class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</div><div class="line">    <span class="comment">//Go back to the previous Activity.</span></div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>在该 SampleActivity 中声明了一个延迟 10 分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish()掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。<br>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * Instances of static inner classes do not hold an implicit</div><div class="line">    * reference to their outer class</div><div class="line">    */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;SampleActivity&gt; mActivity;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(SampleActivity activity)</span></span>&#123;</div><div class="line">      mActivity = <span class="keyword">new</span> WeakReference&lt;SampleActivity&gt;(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">      SampleActivity activity = mActivity.get();</div><div class="line">      <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * Instances of anonymous classes do not hold an implicit</div><div class="line">    * reference to their outer class when they are "static"</div><div class="line">    */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable sRunnable = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。&lt;br&gt;我会从 Java 内存泄漏的基础知识开
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java深入源码</title>
    <link href="https://edward7zhang.github.io/2019/03/10/Java%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81/"/>
    <id>https://edward7zhang.github.io/2019/03/10/Java深入源码/</id>
    <published>2019-03-10T04:07:14.000Z</published>
    <updated>2019-03-10T12:38:51.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下面那些情况下的对象会被垃圾回收机制处理掉？"><a href="#下面那些情况下的对象会被垃圾回收机制处理掉？" class="headerlink" title="下面那些情况下的对象会被垃圾回收机制处理掉？"></a>下面那些情况下的对象会被垃圾回收机制处理掉？</h1><p>利用可达性分析算法，虚拟机会将一些对象定义为 GC Roots，从 GC Roots 出发沿着引用链向下寻找，如果某个对象不能通过 GC Roots 寻找到，虚拟机就认为该对象可以被回收掉。</p><h2 id="那些对象可以被看做是-GC-Roots-呢？"><a href="#那些对象可以被看做是-GC-Roots-呢？" class="headerlink" title="那些对象可以被看做是 GC Roots 呢？"></a>那些对象可以被看做是 GC Roots 呢？</h2><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中的类静态属性引用的对象，常量引用的对象；</li><li>本地方法栈中 JNI（Native 方法）引用的对象；</li></ol><h2 id="对象不可达，一定会被垃圾收集器回收么？"><a href="#对象不可达，一定会被垃圾收集器回收么？" class="headerlink" title="对象不可达，一定会被垃圾收集器回收么？"></a>对象不可达，一定会被垃圾收集器回收么？</h2><p>即使不可达，对象也不一定会被垃圾收集器回收。</p><ol><li>先判断对象是否有必要执行 finalize()方法，对象必须重写 finalize()方法且没有被运行过。</li><li>若有必要执行，会把对象放到一个队列中，JVM 会开一个线程去回收它们，这是对象最后一次可以逃逸清理的机会。</li></ol><h1 id="讲一下常见的编码方式？"><a href="#讲一下常见的编码方式？" class="headerlink" title="讲一下常见的编码方式？"></a>讲一下常见的编码方式？</h1><p>编码的意义：计算机中存储的最小单元是一个字节即 8bit，所能表示的自付范围是 255 个，而人类要表示的符号太多，无法用一个字节来完全表示，故需要将符号编码，将各种语言翻译成机器语言。</p><ol><li>ASCII 码：总共 128 个，用一个字节的低 7 位表示，0 ~ 31 控制字符如换回车删除等；32 ~ 126 是打印字符，可通过键盘输入并显示出来；</li><li>ISO-8859-1，用来扩展 ASCII 编码，256 个字符，涵盖了大多数西欧语言字符；</li><li>GB2312:双字节编码，总编码范围是 A1-A7,A1-A9 是符号区，包含 682 个字符，B0-B7 是汉字区，包含 6763 个汉字；</li><li>GBK 为了扩展 GB2312，加入了更多的汉字，编码范围是 8140~FEFE，有 23940 个码位，能表示 21003 个汉字；</li><li>UTF-16: ISO试图想创建一个全新的超语言字典，世界上所有语言都可通过这本字典Unicode来相互翻译，而UTF-16定义了Unicode字符在计算机中存取方法，用两个字节来表示Unicode转化格式。不论什么字符都可用两字节表示，即16bit，故叫UTF-16。</li><li>UTF-8：UTF-16统一采用两字节表示一个字符，但有些字符只用一个字节就可表示，浪费存储空间，而UTF-8采用一种变长技术，每个编码区域有不同的字码长度。 不同类型的字符可以由1~6个字节组成。</li></ol><h1 id="utf-8-编码中的中文占几个字节？int-型占几个字节？"><a href="#utf-8-编码中的中文占几个字节？int-型占几个字节？" class="headerlink" title="utf-8 编码中的中文占几个字节？int 型占几个字节？"></a>utf-8 编码中的中文占几个字节？int 型占几个字节？</h1><p>utf-8 是一种变长编码技术，utf-8 编码中的中文占用的字节不确定，可能是 2 个、3 个、4 个，int 型占 4 个字节。</p><h1 id="静态代理和动态代理的区别，什么场景使用？"><a href="#静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="静态代理和动态代理的区别，什么场景使用？"></a>静态代理和动态代理的区别，什么场景使用？</h1><p>代理是一种常用的设计模式，目的是：为其他对象提供一个代理以控制对某个对象的访问，将两个类的关系解耦。代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。<br>区别：</p><ol><li>静态代理：由程序员创建或是由特定工具生成，在代码编译时就确定了被代理的类哪一个是静态代理。静态代理通常只代理一个类；</li><li>动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类；<br>实现步骤：a. 实现 InvocationHandler 接口创建自己的调用处理器；b. 给 Proxy 类提供 ClassLoader 和代理接口类型数组创建动态代理类；c. 利用反射机制得到动态代理类的构造函数；d. 利用动态代理类的构造函数创建动态代理类对象；<br>使用场景：Retrofit 中直接调用接口的方法；</li></ol><h1 id="Java-的异常体系"><a href="#Java-的异常体系" class="headerlink" title="Java 的异常体系"></a>Java 的异常体系</h1><p>Java 中 Throwable 是所有异常和错误的超类，两个直接子类是 Error(错误)和 Exception(异常)：</p><ol><li>Error 是程序无法处理的错误，由 JVM 产生和抛出，如 OOM、ThreadDeath 等。这些异常发生时，JVM 一般会选择终止程序。</li><li>Exception 是程序本身可以处理的异常，又分为运行时异常(RuntimeException)(也叫 CheckedException)和非运行时异常（不检查异常 Unchecked Exception）。运行时异常又 NullPointerException、IndexOutOfBoundsException 等，这些异常一般是由程序逻辑错误引起的，应尽可能避免。非运行时异常有 IOException、SQLException、FileNotFoundException 以及由用户自定义的 Exception 异常等。</li></ol><h1 id="谈谈你对解析与分派的认识"><a href="#谈谈你对解析与分派的认识" class="headerlink" title="谈谈你对解析与分派的认识"></a>谈谈你对解析与分派的认识</h1><p><strong>解析</strong>指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用。<br><strong>分派</strong>可分为静态分派和动态分派，重载属于静态分派，重载属于静态分派，覆盖属于动态分派。静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。动态分派则需要根据实际类型来调用相应的方法。</p><h1 id="修改对象-A-的-equals-方法的签名，那么使用-HashMap-存放这个对象实例的时候，会调用哪个-equals-方法？"><a href="#修改对象-A-的-equals-方法的签名，那么使用-HashMap-存放这个对象实例的时候，会调用哪个-equals-方法？" class="headerlink" title="修改对象 A 的 equals 方法的签名，那么使用 HashMap 存放这个对象实例的时候，会调用哪个 equals 方法？"></a>修改对象 A 的 equals 方法的签名，那么使用 HashMap 存放这个对象实例的时候，会调用哪个 equals 方法？</h1><p>会调用对象的 equals 方法，如果对象的 equals 方法没有被重写，equals 方法和 == 都是比较栈内局部变量表中指向堆内存地址值是否相等。</p><h1 id="Java-中实现多态的机制是什么？"><a href="#Java-中实现多态的机制是什么？" class="headerlink" title="Java 中实现多态的机制是什么？"></a>Java 中实现多态的机制是什么？</h1><p><strong>多态</strong>是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时不确定，在运行期间才确定，一个引用变量到底会指向哪个类的实例。这样就可以不用修改源代码，就可以让引用变量绑定到各种不同的类实现上。Java 实现多态多三个必要条件：继承、重定、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法。</p><h1 id="如何将一个-Java-对象序列化到文件里？"><a href="#如何将一个-Java-对象序列化到文件里？" class="headerlink" title="如何将一个 Java 对象序列化到文件里？"></a>如何将一个 Java 对象序列化到文件里？</h1><p>ObjectOutputStream.writeObject()负责将指定的流写入，ObjectInputStream.readObject()从指定 流读取序列化数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写入</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream</div><div class="line">    os.writeObject(studentList);</div><div class="line">    os.close();</div><div class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="说说你对-Java-反射的理解"><a href="#说说你对-Java-反射的理解" class="headerlink" title="说说你对 Java 反射的理解"></a>说说你对 Java 反射的理解</h1><p>在运行状态中，对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性。这种能动态获取信息及动态调用对象方法的功能称为 Java 语言的反射机制。<br>反射的作用：开发过程中，经常会遇到某个类的某个成员变量、方法或属性是私有的，或只对系统应用开放，这里就可以利用 Java 的反射机制通过反射来获取所需的私有成员或是方法。</p><ol><li>获取类的 Class 对象实例 Class clz = Class.forName(“com.zhenai.api.Apple”);</li><li>根据 Class 对象实例获取 Constructor 对象 Constructor appConstructor = clz.getConstructor();</li><li>使用 Constructor 对象的 newInstance 方法获取反射类对象 Object appleObj = appConstructor.newInstance();</li><li>获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(“setPrice”,int.class);</li><li>利用 invoke 方法调用方法 setPriceMethod.invoke(appleObj, 14);</li><li>通过 getFields() 可以获取 Class 类的属性，但无法获取私有属性，而 getDeclareFields()可以获取到包括私有属性在内的所有属性。带有 Declared 修饰的方法可以反射到私有的方法，没有 Declared 修饰的只能用来反射公有的方法，其他如 Annotation\Field\Constructor 也是如此。</li></ol><h1 id="说说你对-Java-注解的理解"><a href="#说说你对-Java-注解的理解" class="headerlink" title="说说你对 Java 注解的理解"></a>说说你对 Java 注解的理解</h1><p>注解是通过@interface 关键字来进行定义的，形式和接口差不多，只是前面多了一个@<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation&#123;&#125;</div></pre></td></tr></table></figure></p><p>使用时@TestAnnotation 来引用，要使注解能正常工作，还需要使用元注解，它是可以注解到注解上的注解。元标签有@Retention @Documented @Target @Inherited @Repeatable 五种</p><p>@Retention 说明注解的存活时间，取值有 RetentionPolicy.SOURCE 注解旨在源码阶段保留，在编译器进行编译时被丢弃；RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到 JVM 中。RetentionPolicy.RUNTIME 可以留到程序运行的时候，它会被加载进入到 JVM 中，所以再程序运行时可以获取到它们。</p><p>@Documented 注解中的元素包含到 javadoc 中去；</p><p>@Target 限定注解的应用场景，ElementType.FIELD 给属性进行注解；ElemenType.LOCAL_VARIABLE 可以给局部变量进行注解；ElementType.METHOD 可以给方法进行注解；ElementType.PACKAGE 可以给一个包进行注解 ElementType.TYPE 可以给一个类型进行注解，如类、接口、枚举；</p><p>@Inherited 若一个超类被@Inherited 注解过的注解进行注解，它的子类没有被任何注解应用的话，该子类就可继承超类的注解；</p><p><strong>注解的作用：</strong></p><ol><li>提供信息给编译器：编译器可以利用注解来探测错误和警告信息  </li><li>编译阶段：软件工具可以利用注解信息来生成代码、html 文档或做其它相应处理；</li><li>运行阶段：程序运行时可利用注解提取代码；<br>注解是通过反射获取的，可以通过 Class 对象的 isAnnotationPresent()方法判断它是否应用了某个注解，在通过 getAnnotation()方法获取 Annotation 对象。</li></ol><h1 id="说一下泛型原理，并举例说明"><a href="#说一下泛型原理，并举例说明" class="headerlink" title="说一下泛型原理，并举例说明"></a>说一下泛型原理，并举例说明</h1><p>泛型就是将类型变成参数传入，使得可以使用的类型多样化，从而实现解耦。Java泛型是在Java1.5以后出现的，为保持对以前版本的兼容，使用了擦除的方法实现泛型。擦除是指在一定程度无视类型参数T，直接从T所在的类开始向上T的父类去擦除，如调用泛型方法，传入类型参数T进入方法内部，若没在声明时做类似public T methodName(T extends Father t){}，Java就进行了向上类型的擦除，直接把参数t当做Object类来处理，而不是传进去的T。即在有泛型的任何类和方法内部，它都无法知道自己的泛型参数，擦除和转型都是在边界上发生，即传进去的参在进入类或方法时被擦除掉，但传出来的时候又被转成了我们设置的T。在泛型类或方法内，任何涉及到具体类型（即擦除后的类型的子类）操作都不能进行，如new T()，或者T.play()（play为某子类的方法而不是擦除后的类的方法）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下面那些情况下的对象会被垃圾回收机制处理掉？&quot;&gt;&lt;a href=&quot;#下面那些情况下的对象会被垃圾回收机制处理掉？&quot; class=&quot;headerlink&quot; title=&quot;下面那些情况下的对象会被垃圾回收机制处理掉？&quot;&gt;&lt;/a&gt;下面那些情况下的对象会被垃圾回收机制处理
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>论：线程、多线程和线程池</title>
    <link href="https://edward7zhang.github.io/2019/03/06/%E8%AE%BA%EF%BC%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://edward7zhang.github.io/2019/03/06/论：线程、多线程和线程池/</id>
    <published>2019-03-06T04:07:14.000Z</published>
    <updated>2019-03-09T15:09:41.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原 理、⑨ReentranLock源码，设计原理，整体过程 等等问题。 </p></blockquote><h1 id="开启线程的三种方式？"><a href="#开启线程的三种方式？" class="headerlink" title="开启线程的三种方式？"></a>开启线程的三种方式？</h1><ul><li><p>继承 Thread 类，重写 run()方法，在 run()方法中编写要完成的任务 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread().start();</div></pre></td></tr></table></figure></li><li><p>实现 Runnable 接口，实现 run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</div></pre></td></tr></table></figure></li><li><p>实现 Callable 接口 MyCallable 类，实现 call()方法，使用 FutureTask 类来包装 Callable 对象，使用 FutureTask 对象作为 Thread 对象的 target 创建并启动线程；调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> MyCallable());</div><div class="line"><span class="keyword">new</span> Thread(ft).start();</div></pre></td></tr></table></figure></li></ul><h1 id="run-和-start-方法的区别"><a href="#run-和-start-方法的区别" class="headerlink" title="run() 和 start() 方法的区别"></a>run() 和 start() 方法的区别</h1><p>run()方法只是线程的主方法体，和普通方法一样，不会创建新的线程。只有调用 start()方法，才会启动一个新的线程，新线程才会调用 run()方法，线程才会开始执行。</p><h1 id="如何控制某个方法允许并发访问的线程数？"><a href="#如何控制某个方法允许并发访问的线程数？" class="headerlink" title="如何控制某个方法允许并发访问的线程数？"></a>如何控制某个方法允许并发访问的线程数？</h1><p>创建 Semaphore 变量，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>当方法进入时，请求一个信号，如果信号被用完则等待，方法运行完，释放一个信号，释放的信号新的线程就可以使用。</p><h1 id="在-Java-中-wait-和-sleep-方法的不同"><a href="#在-Java-中-wait-和-sleep-方法的不同" class="headerlink" title="在 Java 中 wait 和 sleep 方法的不同"></a>在 Java 中 wait 和 sleep 方法的不同</h1><ul><li>wait()方法属于 Object 类，调用该方法时，线程会放弃对象锁，只有该对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li><li>sleep()方法属于 Thread 类，sleep 导致程序暂停执行指定的时间，让出 CPU，但他的监控状态依然保存着，当指定时间到了又会回到运行状态，sleep()方法中线程不会释放对象锁。<h1 id="谈谈-wait-notfiy-方法的理解"><a href="#谈谈-wait-notfiy-方法的理解" class="headerlink" title="谈谈 wait()/notfiy() 方法的理解"></a>谈谈 wait()/notfiy() 方法的理解</h1></li><li>notify()：唤醒在此对象监视器上等待的单个线程</li><li>notifyAll()：通知所有等待竞争该资源的线程</li><li>wait()：释放 obj 的锁，导致当前的线程等待，直接其他线程调用此对象的 notify()或 notifyAll();</li><li>当要调用 wait()或 notify()/notifyAll()方法时，一定要对竞争资源进行加锁，一般放到 synchronized(obj)代码中。当调用 obj.notify/notifyAll 后，调用线程依旧持有 obj 锁，因此等待线程虽被唤醒，但仍无法获得 obj 锁，知道调用线程退出 synchronized 块，释放 obj 锁后，其他等待线程才有机会获得锁继续执行。<h1 id="什么导致线程阻塞？"><a href="#什么导致线程阻塞？" class="headerlink" title="什么导致线程阻塞？"></a>什么导致线程阻塞？</h1></li><li>线程执行了 Thread.sleep(int millsecond)方法，放弃 CPU，睡眠一段时间，一段时间过后恢复执行；</li><li>线程执行一段同步代码，但无法获得相关的同步锁，只能进入阻塞状态，等到获取同步锁，才能恢复执行；</li><li>线程执行了一个对象的 wait()方法，直接进入阻塞态，等待其他线程执行 notify()/notifyAll()操作；</li><li>线程执行某些 IO 操作，因为等待相关资源而进入了阻塞态，如 System.in，但没有收到键盘的输入，则进入阻塞态。</li><li>线程礼让，Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程，但并不会使线程进入阻塞态，线程仍处于可执行态，随时可能再次分得 CPU 时间。线程自闭，join()方法，在当前线程调用另一个线程的 join()方法，则当前线程进入阻塞态，直到另一个线程运行结束，当前线程再由阻塞转为就绪态。</li><li>线程执行 suspend()使线程进入阻塞态，必须 resume()方法被调用，才能使线程重新进入可执行状态。<h1 id="线程如何关闭？"><a href="#线程如何关闭？" class="headerlink" title="线程如何关闭？"></a>线程如何关闭？</h1></li><li>使用标志位</li><li>使用 stop() 方法，但该方法就像关掉电脑电源一样，可能会发生预料不到的问题</li><li>使用中断 interrupt()<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="comment">//中断当前线程</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//判断当前线程是否被中断</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupt</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//清除当前线程的中断状态，并返回之前的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolen <span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>但调用 interrupt()方法只是传递中断请求消息，并不代表要立马停止目标线程</p><h1 id="讲一下-Java-中的同步的方法"><a href="#讲一下-Java-中的同步的方法" class="headerlink" title="讲一下 Java 中的同步的方法"></a>讲一下 Java 中的同步的方法</h1><p>之所以需要同步，因为在多线程并发控制，当多个线程同时操作一个可共享的资源时，如果没有采取同步机制，将会导致数据不准确，因此需要加入同步锁，确保在该线程没有完成操作前被其他线程调用，从而保证该变量的唯一性和准确性。</p><h2 id="synchronized-修饰同步代码块或方法"><a href="#synchronized-修饰同步代码块或方法" class="headerlink" title="synchronized 修饰同步代码块或方法"></a>synchronized 修饰同步代码块或方法</h2><p>由于 Java 的每个对象都有一个内置锁，用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需获得内置锁，否则就处于阻塞状态</p><h2 id="volatile-修饰变量"><a href="#volatile-修饰变量" class="headerlink" title="volatile 修饰变量"></a>volatile 修饰变量</h2><p>保证变量在线程间的可见性每次线程要访问 volatile 修饰的变量时都从主存中读取，而不是缓存中，这样每个线程访问到的变量都是一样的。且使用内存屏障。</p><h2 id="ReentrantLock-重入锁，它常用的方法有-ReentrantLock-：创建一个-ReentrantLock-实例"><a href="#ReentrantLock-重入锁，它常用的方法有-ReentrantLock-：创建一个-ReentrantLock-实例" class="headerlink" title="ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例"></a>ReentrantLock 重入锁，它常用的方法有 ReentrantLock()：创建一个 ReentrantLock 实例</h2><p>lock()获得锁 unlock()释放锁</p><h2 id="使用局部变量-ThreadLocal-实现线程同步"><a href="#使用局部变量-ThreadLocal-实现线程同步" class="headerlink" title="使用局部变量 ThreadLocal 实现线程同步"></a>使用局部变量 ThreadLocal 实现线程同步</h2><p>每个线程都会保存一份该变量的副本，副本之间相互独立，这样每个线程都可以随意修改自己的副本，而不影响其他线程。<br>常用方法：</p><ul><li>ThreadLocal()创建一个线程本地变量；</li><li>get()返回此线程就不懂当前线程副本变量；</li><li>initialValue()返回次线程局部变量的当前线程的出事值；</li><li>set(T value)将此线程变量的当前线程副本中的值设置为 value<h2 id="使用原子变量"><a href="#使用原子变量" class="headerlink" title="使用原子变量"></a>使用原子变量</h2>如 AtomicInteger<br>常用方法：</li><li>AtomicInteger(int value)创建个有给定初试值的 AtomicInteger 整数；</li><li>addAndGet(int data)以原子方式将给定值与当前值相加<h2 id="使用阻塞队列实现线程同步"><a href="#使用阻塞队列实现线程同步" class="headerlink" title="使用阻塞队列实现线程同步"></a>使用阻塞队列实现线程同步</h2>LinkedBlockingQueue<e></e></li></ul><h1 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h1><p><strong>线程安全性体现的三方法：</strong></p><ol><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作。JDK 中提供了很多 atomic 类，如 AtomicInteger\AtomicBoolean\AtomicLong，它们是通过 CAS 完成原子性。JDK 提供锁分为两种：synchronized 依赖 JVM 实现锁，该关键字对对象的作用范围内同一时刻只能有一个线程进行操作。另一种是 LOCK，是 JDK 提供的代码层面的锁，依赖 CPU 指令，代表性是 ReentrantLock。</li><li>可见性：一个线程对主内存的修改及时被其他线程看到。JVM 提供了 synchronized 和 volatile，volatile 的可见性是通过内存屏障和禁止重排序实现的，volatile 会在写操作时，在写操作后加一条 store 屏障指令，将本地内存中的共享变量刷新到主内存；会在读操作时，在读操作前加一条 load 指令，从内存中读取共享变量。</li><li>有序性：指令没有被编译器重排序。可通过 volatile、synchronized、Lock 保证有序性 4. </li></ol><h1 id="static-synchronized-方法的多线程访问和作用"><a href="#static-synchronized-方法的多线程访问和作用" class="headerlink" title="static synchronized 方法的多线程访问和作用"></a>static synchronized 方法的多线程访问和作用</h1><p>static synchronized 控制的是类的所有实例访问，不管 new 了多少对象，只有一份，所以对该类的所有对象都加了锁。限制多线程中该类的所有实例同时访问 JVM 中该类对应的代码。</p><h1 id="面试中关于-synchronized-关键字的-5-连击"><a href="#面试中关于-synchronized-关键字的-5-连击" class="headerlink" title="面试中关于 synchronized 关键字的 5 连击"></a>面试中关于 synchronized 关键字的 5 连击</h1><h2 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。<br>另外，在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙来完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h2 id="说一说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><a href="#说一说自己是怎么使用-synchronized-关键字，在项目中用到了吗？" class="headerlink" title="说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？"></a>说一说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h2><p>synchronized 关键字最主要的三种使用方式：</p><ul><li>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。也是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而 B 线程需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是给 Class 类上锁。这里再提醒一下：synchronized 关键字加到 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a)因为 JVM 中，字符串常量池具有缓冲功能。<br>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”<br>双重校验锁实现对象单例(线程安全)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></div><div class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="comment">//类对象加锁</span></div><div class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">          uniqueInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> uniqueInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分 为三步执行： </p><ol><li>为 uniqueInstance 分配内存空间 </li><li>初始化 uniqueInstance </li><li>将 uniqueInstance 指向分配的内存地址 </li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，但此时 uniqueInstance 还未被 初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h2 id="讲一下-synchronized-关键字的底层原理"><a href="#讲一下-synchronized-关键字的底层原理" class="headerlink" title="讲一下 synchronized 关键字的底层原理"></a>讲一下 synchronized 关键字的底层原理</h2><p>synchronized 关键字底层原理属于 JVM 层面。</p><ol><li>synchronized 同步语句块的情况 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</div><div class="line">    <span class="keyword">synchronized</span>（<span class="keyword">this</span>）&#123;</div><div class="line">      System.out.println(<span class="string">"synchronized 代码块"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的.class 文件，然后执行 <code>javap -c -s -v -l SynchronizedDemo.class</code>。<br>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程识图获取锁也是获取 monitor(monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因)的持有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1.相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><ol><li>synchronized 修饰方法的情况 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"synchronized 方法"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的却是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来 辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h2 id="说一说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><a href="#说一说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="说一说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"></a>说一说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h2><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减 少锁操作的开销。<br>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐 渐升级。<br>注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。<br>关于这几种优化的详细信息可以查看：synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和 ReenTrantLock 的对比</p><h2 id="谈谈-synchronized-和-ReenTrantLock-的区别"><a href="#谈谈-synchronized-和-ReenTrantLock-的区别" class="headerlink" title="谈谈 synchronized 和 ReenTrantLock 的区别"></a>谈谈 synchronized 和 ReenTrantLock 的区别</h2><p>① 两者都是可重入锁 两者都是可重入锁。<br>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时 这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死 锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。<br>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API<br>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多 优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。<br>③ ReenTrantLock 比 synchronized 增加了一些高级功能 相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁； ③可实现选择性通知（锁可以绑定多个条件）</p><ul><li>ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也 就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 </li><li>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等 待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过ReenTrantLock类的 ReentrantLock(boolean fair) 构造方法来制定是否是公平的。 </li><li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也 可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很 好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视 器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵 活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合 Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而 synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果 执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的 signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。<br>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</li><li>性能已不是选择标准<h1 id="面试中关于线程池的-2-连击"><a href="#面试中关于线程池的-2-连击" class="headerlink" title="面试中关于线程池的 2 连击"></a>面试中关于线程池的 2 连击</h1><h2 id="讲一下-Java-内存模型"><a href="#讲一下-Java-内存模型" class="headerlink" title="讲一下 Java 内存模型"></a>讲一下 Java 内存模型</h2></li></ul><h2 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h2><h1 id="面试中关于线程池的-2-连击-1"><a href="#面试中关于线程池的-2-连击-1" class="headerlink" title="面试中关于线程池的 2 连击"></a>面试中关于线程池的 2 连击</h1><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><h2 id="实现-Runnable-接口和-Callable-接口的区别"><a href="#实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="实现 Runnable 接口和 Callable 接口的区别"></a>实现 Runnable 接口和 Callable 接口的区别</h2><h2 id="执行-execute-方法和-submit-方法的区别是什么？"><a href="#执行-execute-方法和-submit-方法的区别是什么？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么？"></a>执行 execute()方法和 submit()方法的区别是什么？</h2><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区 别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android端各类图片加载框架对比</title>
    <link href="https://edward7zhang.github.io/2019/03/04/Android%E7%AB%AF%E5%90%84%E7%B1%BB%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
    <id>https://edward7zhang.github.io/2019/03/04/Android端各类图片加载框架对比/</id>
    <published>2019-03-04T04:07:14.000Z</published>
    <updated>2019-03-04T01:13:13.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间的面试过程中被问到用过什么图片加载框架，我随口而出Glide，面试官继续追问下去是做过什么比较得出Glide比较高效吗？我就阻塞了…所以在此做一次复盘，针对Android端的各种加载框架进行对比</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ul><li>图片加载是Android开发中最最基础的功能，同时图片加载OOM也一直困扰着很多开发者，因此为了降低开发周期和难度，我们经常会选用一些图片加载的开源库。</li><li>老牌的有ImageLoader，UIL,  Volley，主流的有，Picasso，Glide，Fresco等等，选择一款好的图片加载裤就成了我们的首要问题。</li><li>接下来我们对比一下主流的三款 Picasso，Glide，Fresco框架的优缺点。</li></ul></blockquote><h1 id="Picasso，Glide，Fresco的前世今生"><a href="#Picasso，Glide，Fresco的前世今生" class="headerlink" title="Picasso，Glide，Fresco的前世今生"></a>Picasso，Glide，Fresco的前世今生</h1><h2 id="基本项对比"><a href="#基本项对比" class="headerlink" title="基本项对比"></a>基本项对比</h2><table><thead><tr><th>对比项</th><th>Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>地址</td><td><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fpicasso" target="_blank" rel="external">github.com/square/pica…</a></td><td><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fbumptech%2Fglide" target="_blank" rel="external">github.com/bumptech/gl…</a></td><td><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Ffresco" target="_blank" rel="external">github.com/facebook/fr…</a></td></tr><tr><td>发布时间</td><td>2013年5月</td><td>2014年9月</td><td>2015年5月</td></tr><tr><td>是否支持gif</td><td>false</td><td>true</td><td>true</td></tr><tr><td>是否支持webP</td><td>true</td><td>true</td><td>true</td></tr><tr><td>视频缩略图</td><td>false</td><td>true</td><td>true</td></tr><tr><td>大小</td><td>100k</td><td>500 KB</td><td>2～3M</td></tr><tr><td>加载速度</td><td>中</td><td>高</td><td>高</td></tr><tr><td>Disk+Men Cache</td><td>true</td><td>true</td><td>true</td></tr><tr><td>Easy of use</td><td>low</td><td>mediun</td><td>difficult</td></tr><tr><td>star</td><td>13160</td><td>14709</td><td>12444</td></tr><tr><td>开发者</td><td>Square主导</td><td>Google主导</td><td>Facebook主导</td></tr></tbody></table><h2 id="加载图片耗时及内存对比"><a href="#加载图片耗时及内存对比" class="headerlink" title="加载图片耗时及内存对比"></a>加载图片耗时及内存对比</h2><h3 id="without-animations"><a href="#without-animations" class="headerlink" title="without animations"></a>without animations</h3><table><thead><tr><th>对比项</th><th>Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>java heap／native heap/平均耗时（without animations）</td><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d4ab13d?imageslim" alt="Picasso加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d2b55e8?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d1496bb?imageslim) | ![Fresco加载无动画图片" title="">                </div>                <div class="image-caption">Picasso加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d2b55e8?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d1496bb?imageslim) | ![Fresco加载无动画图片</div>            </figure></td></tr><tr><td>max java heap</td><td>12.6MB</td><td>11.1MB</td><td>13.9MB</td></tr><tr><td>max native heap</td><td>43.8MB</td><td>43.8MB</td><td>43.8MB</td></tr><tr><td>avg wait time</td><td>241ms</td><td>34ms</td><td>44ms</td></tr></tbody></table><p>从上面的加载静态图片可以看出三大主流框架性能都不错，不过用数据说话整体而言Glide更胜一筹。</p><hr><h3 id="allow-animations"><a href="#allow-animations" class="headerlink" title="allow animations"></a>allow animations</h3><table><thead><tr><th>对比项</th><th>Picasso</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>java heap／native heap/平均耗时（allow animations）</td><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/5/14/1635f431b88df0e0?imageslim" alt="Picasso加载动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d57eddb?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f431b031be09?imageslim) | ![Fresco加载动画图片" title="">                </div>                <div class="image-caption">Picasso加载动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f4318d57eddb?imageslim) | ![Glide加载无动画图片](https://user-gold-cdn.xitu.io/2018/5/14/1635f431b031be09?imageslim) | ![Fresco加载动画图片</div>            </figure></td></tr><tr><td>max java heap</td><td>6.8MB</td><td>74.8.1MB</td><td>36.1MB</td></tr><tr><td>max native heap</td><td>18.2MB</td><td>66.8MB</td><td>545.3MB</td></tr><tr><td>avg wait time</td><td>1707ms</td><td>33910ms</td><td>15142ms</td></tr></tbody></table><p><em>上面的数据我们可以忽略Picasso了，因为它根本不支持gif，那么Glide和Fresco可以看出Fresco的java heap基本保持较低平稳状态，而Glide的java heap基本为Fresco的一倍，所以OOM的风险也比fresco大一倍。</em><br><em>从时间上glide是有一定差距，不过fresco有两张图片没加载完成，所以时间不是完全可靠的数据</em><br><em>从native heap可以看出Fresco最高545MB，这个有点恐怖，下面我们看个知识点。</em></p><p><strong><em>知识点</em></strong></p><blockquote><ul><li>Java Heap是对于Java 虚拟机而说的，一般的大小上限是 16M 24M 48M 76M 具体视手机而定。</li><li>Native Heap是对于C/C++直接操纵的系统堆内存，所以它的上限一般是具体RAM的2/3左右。</li><li>所以对于2G的手机而言，Java Heap 大概76M，而Native Heap是760M左右，相差10倍。</li></ul></blockquote><p>所以Fresco也是存在一定风险的，因为native heap数据实在是太恐怖了。</p><h2 id="详细属性对比"><a href="#详细属性对比" class="headerlink" title="详细属性对比"></a>详细属性对比</h2><p>接下来只详细对比Fresco和Glide<br>Picasso从各方面都比这两个弱，这里就不浪费时间了。</p><table><thead><tr><th>对比项</th><th>Glide</th><th>Fresco</th></tr></thead><tbody><tr><td>配置</td><td><code>compile &#39;com.github.bumptech.glide:glide:XXX.XXX&#39;</code></td><td><code>compile &#39;com.facebook.fresco:fresco:XXX.XXX</code></td></tr><tr><td>初始化</td><td>直接使用</td><td><code>Fresco.initialize(this);</code></td></tr><tr><td>layout</td><td>普通ImageView</td><td>独有的SimpleDraweeView</td></tr><tr><td>圆角， 圆形</td><td>需要自己实现圆角，继承自BitmapTransformation操作bitmap对象实现</td><td>通过RoundingParams设置参数</td></tr><tr><td>缓存</td><td>Glide内存和磁盘缓存</td><td>三级缓存，分别是 Bitmap缓存，未解码图片缓存， 文件缓存。</td></tr><tr><td>缓存图像大小</td><td>Glide则会根据ImageView控件尺寸获得对应的大小的bitmap来展示，从而缓存也可以针对不同的对象：原始图像（source），结果图像(result)</td><td>缓存原始图像</td></tr><tr><td>加载策略</td><td>Glide只有占位图</td><td>先加载小尺寸图片，再加载大尺寸的</td></tr><tr><td>加载进度</td><td>false</td><td>true</td></tr></tbody></table><p>从上面的对比中可以看出来Fresco蛮强大的，不过使用起来相对Glide要复杂一点，而且需要自己的SimpleDraweeView，这一点在切换框架的时候最让人头疼了。而且Glide直接缓存相对大小的图片，节省空间的同时下场如果是同样大小的图片就不要再次请求，直接可以使用。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p><strong>Glide</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">  mavenCentral()</div><div class="line">  google()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.github.bumptech.glide:glide:4.9.0'</span></div><div class="line">  annotationProcessor <span class="string">'com.github.bumptech.glide:compiler:4.9.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Fresco</strong><br>要使用完整的Fresco功能就要导入如下的依赖<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.facebook.fresco:fresco:1.12.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="bitmap操作"><a href="#bitmap操作" class="headerlink" title="bitmap操作"></a>bitmap操作</h3><p><strong>Glide</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bitmap myBitmap = Glide.with(上下文)  </div><div class="line">    .load(url)  </div><div class="line">    .asBitmap() //必须    </div><div class="line">    .get()</div></pre></td></tr></table></figure><p><strong>Fresco</strong><br>Fresco要获取bitmap更加复杂， 而且使用起来也并不是那么顺畅。首先，Fresco为了更好地管理bitmap 对象（bitmap对象申请和释放会引起频繁的GC操作，从而引起界面卡顿）， 引入了可关闭的引用（CloseableReference）, 持有者在离开作用域的时候需要关闭该引用，而我们要获取的bitmap 对象就是可关闭的引用。也就是说，我们不能像上面Glide那样把bitmap 对象取出来传递给其它地方使用， 只能在Fresco提供的作用域范围内使用。<br>实际项目中会获取缓冲的文件对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//同样在DataSubscriber中获取</div><div class="line">FileBinaryResource resource = (FileBinaryResource) Fresco.getImagePipelineFactory().getMainFileCache().getResource(new SimpleCacheKey(url));</div><div class="line">if (resource != null &amp;&amp; resource.getFile() != null) &#123;           </div><div class="line">    setImage(ImageSource.uri(Uri.fromFile(resource.getFile())));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>Glide</strong></p><blockquote><ul><li>多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video）</li><li>生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）</li><li>高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）</li><li>高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）</li></ul></blockquote><p><strong>Fresco</strong></p><blockquote><ul><li>最大的优势在于5.0以下(最低2.3)的bitmap加载。在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem区)</li><li>大大减少OOM（在更底层的Native层对OOM进行处理，图片将不再占用App的内存）</li><li>适用于需要高性能加载大量图片的场景</li></ul></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>Glide</strong></p><blockquote><p>-没有文件缓存 -java heap比Fresco高</p></blockquote><p><strong>Fresco</strong></p><blockquote><ul><li>包较大（2~3M）</li><li>用法复杂</li><li>底层涉及c++领域，阅读源码深入学习难度大</li></ul></blockquote><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Fresco虽然很强大，但是包很大，依赖很多，使用复杂，而且还要在布局使用SimpleDraweeView控件加载图片。相对而言Glide会轻好多，上手快，使用简单，配置方便，而且从加载速度和性能方面不相上下。对于一般的APP来说Glide是一个不错的选择，如果是专业的图片APP那么Fresco还是必要的。</p><p><em><a href="https://juejin.im/entry/5af9aabf51882542bd69d0c0" target="_blank" rel="external">文章部分转载于</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前段时间的面试过程中被问到用过什么图片加载框架，我随口而出Glide，面试官继续追问下去是做过什么比较得出Glide比较高效吗？我就阻塞了…所以在此做一次复盘，针对Android端的各种加载框架进行对比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2.0 使用教程（与常见网络请求库对比）</title>
    <link href="https://edward7zhang.github.io/2019/03/03/Retrofit2.0%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
    <id>https://edward7zhang.github.io/2019/03/03/Retrofit2.0 使用教程（与常见网络请求库对比）/</id>
    <published>2019-03-03T04:07:14.000Z</published>
    <updated>2019-03-03T09:11:48.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在<strong>Android</strong>开发中，网络请求十分常用</li><li>当下的网络请求加载库中，<strong>Retrofit</strong>则是当下hottest的一个网络请求库</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-a3109ad0446b0540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>特别注意：</p><ul><li>准确来说，<strong>Retrofit是一个 RESTful 的 HTTP 网络请求框架的封装</strong></li><li>原因：网络请求的工作本质上是<code>OkHttp</code>完成的，而<code>Retrofit</code>仅负责网络请求接口的封装<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-b5194f1d16673589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>App应用程序通过 Retrofit 请求网络，实际上是使用Retrofit接口层封装请求参数、Header、Url等信息，之后由OkHttp完成后续的请求操作</li><li>在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析</li></ul><h1 id="与其他开源库对比"><a href="#与其他开源库对比" class="headerlink" title="与其他开源库对比"></a>与其他开源库对比</h1><p>除了 Retrofit，如今 Android 中主流的网络请求框架有：</p><ul><li>Android-Async-Http</li><li>Volly</li><li>OkHttp<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-3089d23889f04d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="介绍" title="">                </div>                <div class="image-caption">介绍</div>            </figure></li></ul><p>几种网络请求库之间的区别对比<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-58819416dfd2767a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>附：各个主流网络请求库的 Github 地址</p><ul><li><a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">Android-Async-Http</a></li><li><a href="https://github.com/stormzhang/AndroidVolley" target="_blank" rel="external">Volley</a></li><li><a href="https://github.com/square/okhttp" target="_blank" rel="external">OkHttp</a></li><li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a></li></ul><h1 id="Retrofit使用介绍"><a href="#Retrofit使用介绍" class="headerlink" title="Retrofit使用介绍"></a>Retrofit使用介绍</h1><p>使用Retrofit的步骤共有7个：</p><pre><code>步骤1：添加 Retrofit 库的依赖步骤2：创建 接受服务器返回数据 的类步骤3：创建 用于描述网络请求 的接口步骤4：创建 Retrofit 实例步骤5：创建 网络请求接口实例 并 配置网络请求参数步骤6：发送网络请求（异步\同步）    &gt; 封装了 数据转换、线程切换的操作步骤7：处理服务器返回的数据</code></pre><p>接下来我们将这些步骤进行分解</p><h2 id="步骤1：添加-Retrofit-库的依赖"><a href="#步骤1：添加-Retrofit-库的依赖" class="headerlink" title="步骤1：添加 Retrofit 库的依赖"></a>步骤1：添加 Retrofit 库的依赖</h2><h3 id="1-在Gradle加入Retrofit库的依赖"><a href="#1-在Gradle加入Retrofit库的依赖" class="headerlink" title="1.在Gradle加入Retrofit库的依赖"></a>1.在<code>Gradle</code>加入<code>Retrofit</code>库的依赖</h3><blockquote><p>由于<code>Retrofit</code>是基于<code>OkHttp</code>，所以还需要添加<code>OkHttp</code>库依赖</p></blockquote><p><em>build.gradle</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123; </div><div class="line">  compile&apos;com.squareup.retrofit2:retrofit:2.0.2&apos;  </div><div class="line">  // Retrofit库 </div><div class="line">  compile &apos;com.squareup.okhttp3:okhttp:3.1.2&apos;  </div><div class="line">  // Okhttp库 </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-添加-网络权限"><a href="#2-添加-网络权限" class="headerlink" title="2.添加 网络权限"></a>2.添加 网络权限</h3><p><em>AndroidManifest.xml</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</div></pre></td></tr></table></figure><h2 id="步骤2：创建-接受服务器返回数据-的类"><a href="#步骤2：创建-接受服务器返回数据-的类" class="headerlink" title="步骤2：创建 接受服务器返回数据 的类"></a>步骤2：创建 接受服务器返回数据 的类</h2><p><em>Reception.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reception</span></span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">//根据返回数据的格式和数据解析方式（Json、XML等）定义</span></div><div class="line">  <span class="comment">//下面会在实例中进行说明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="步骤3：创建-用于描述网络请求-的接口"><a href="#步骤3：创建-用于描述网络请求-的接口" class="headerlink" title="步骤3：创建 用于描述网络请求 的接口"></a>步骤3：创建 用于描述网络请求 的接口</h2><ul><li>Retrofit将Http请求抽象成Java接口：采用<strong>注解</strong>描述网络请求的参数 和 配置网络请求参数</li></ul><blockquote><p>1.用 动态代理 动态 将该接口的注解“翻译”成一个Http请求，最后再执行Http请求<br>2.注：接口中的每个方法的参数都需要使用注解标注，否则会报错</p></blockquote><p>_GetRequest<em>Interface.interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span></span>&#123;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>)</div><div class="line">    <span class="function">Call&lt;Translation&gt; <span class="title">getCall</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//@GET注解的作用：采用Get方法发送网络请求</span></div><div class="line">    <span class="comment">//getCall() = 接受网络请求数据的方法</span></div><div class="line">    <span class="comment">//其中返回类型为Call&lt;*&gt;,*是接收数据的类（即上面定义的Translation类）</span></div><div class="line">    <span class="comment">//如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面详细介绍Retrofit网络请求接口 的注解类型<br><strong>注解类型</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-ee747d1e331ed5a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注解说明</strong></p><h3 id="第一类：网络请求方法"><a href="#第一类：网络请求方法" class="headerlink" title="第一类：网络请求方法"></a>第一类：网络请求方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-e97379b8e0942459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="详细说明："><a href="#详细说明：" class="headerlink" title="详细说明："></a>详细说明：</h3><h4 id="a-GET、-POST、-PUT、-DELETE、-HEAD"><a href="#a-GET、-POST、-PUT、-DELETE、-HEAD" class="headerlink" title="a.@GET、@POST、@PUT、@DELETE、@HEAD"></a>a.@GET、@POST、@PUT、@DELETE、@HEAD</h4><p>以上方法分别对应HTTP中的网络请求方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123; </div><div class="line">  <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>) </div><div class="line">  <span class="function">Call&lt;Translation&gt; <span class="title">getCall</span><span class="params">()</span></span>; </div><div class="line">  <span class="comment">// @GET注解的作用:采用Get方法发送网络请求  </span></div><div class="line">  <span class="comment">// getCall() = 接收网络请求数据的方法  </span></div><div class="line">  <span class="comment">// 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类） </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>此处特意说明URL的组成：Retrofit把 网络请求的URL分成了两部分设置：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第1部分：在网络请求接口的注解设置</span></div><div class="line"> <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>)</div><div class="line"><span class="function">Call&lt;Translation&gt;  <span class="title">getCall</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 第2部分：在创建Retrofit实例时通过.baseUrl()设置</span></div><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                .baseUrl(<span class="string">"http://fanyi.youdao.com/"</span>) <span class="comment">//设置网络请求的Url地址</span></div><div class="line">                .addConverterFactory(GsonConverterFactory.create()) <span class="comment">//设置数据解析器</span></div><div class="line">                .build();</div><div class="line"></div><div class="line"><span class="comment">// 从上面看出：一个请求的URL可以通过 替换块 和 请求方法的参数 来进行动态的URL更新。</span></div><div class="line"><span class="comment">// 替换块是由 被&#123;&#125;包裹起来的字符串构成</span></div><div class="line"><span class="comment">// 即：Retrofit支持动态改变网络请求根目录</span></div></pre></td></tr></table></figure></p><ul><li>网络请求的完整 Url = 在创建 Retrofit 实例时通过.baseUrl() 设置 + 网络请求接口的注解设置（下面称“path”）</li><li>具体整合的规则如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-3dc42017038302d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>建议采用第三种方式来配置，并尽量使用同一种路径形式。</p></blockquote></li></ul><h4 id="b-HTTP"><a href="#b-HTTP" class="headerlink" title="b.@HTTP"></a>b.@HTTP</h4><ul><li>作用：替换@GET、@POST、@PUT、@DELETE、@HEAD注解的作用 及 更多功能拓展</li><li>具体使用：通过属性 method、path、hasBody进行设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * method：网络请求的方法（区分大小写）</div><div class="line">     * path：网络请求地址路径</div><div class="line">     * hasBody：是否有请求体</div><div class="line">     */</div><div class="line">    <span class="meta">@HTTP</span>(method = <span class="string">"GET"</span>, path = <span class="string">"blog/&#123;id&#125;"</span>, hasBody = <span class="keyword">false</span>)</div><div class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getCall</span><span class="params">(@Path(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;</div><div class="line">    <span class="comment">// &#123;id&#125; 表示是一个变量</span></div><div class="line">    <span class="comment">// method 的值 retrofit 不会做处理，所以要自行保证准确</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="第二类：标记"><a href="#第二类：标记" class="headerlink" title="第二类：标记"></a>第二类：标记</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-a6f1fc997c23a2e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="a-FormUrlEncoded"><a href="#a-FormUrlEncoded" class="headerlink" title="a.@FormUrlEncoded"></a>a.@FormUrlEncoded</h4><ul><li>作用：表示发送form-encoded 的数据<blockquote><p>每个键值对需要用 @Filed 来注解键名，随后的对象需要提供值。</p></blockquote></li></ul><h4 id="b-Multipart"><a href="#b-Multipart" class="headerlink" title="b.@Multipart"></a>b.@Multipart</h4><ul><li>作用：表示发送form-encoded 的数据（适用于 有文件 上传的场景）<blockquote><p>每个键值对需要用 @Part 来注解键名，随后的对象需要提供值。</p></blockquote></li></ul><p>具体使用如下：<br>_GetRequest<em>Interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）</div><div class="line">         * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@FormUrlEncoded</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded1</span><span class="params">(@Field(<span class="string">"username"</span>)</span> String name, @<span class="title">Field</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * &#123;<span class="doctag">@link</span> Part&#125; 后面支持三种类型，&#123;<span class="doctag">@link</span> RequestBody&#125;、&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 、任意类型</div><div class="line">         * 除 &#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 以外，其它类型都必须带上表单字段(&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 中已经包含了表单字段的信息)，</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@Multipart</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFileUpload1</span><span class="params">(@Part(<span class="string">"name"</span>)</span> RequestBody name, @<span class="title">Part</span><span class="params">(<span class="string">"age"</span>)</span> RequestBody age, @Part MultipartBody.Part file)</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体使用</span></div><div class="line">       GetRequest_Interface service = retrofit.create(GetRequest_Interface.class);</div><div class="line">        <span class="comment">// @FormUrlEncoded </span></div><div class="line">        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(<span class="string">"Carson"</span>, <span class="number">24</span>);</div><div class="line"></div><div class="line">        <span class="comment">//  @Multipart</span></div><div class="line">        RequestBody name = RequestBody.create(textType, <span class="string">"Carson"</span>);</div><div class="line">        RequestBody age = RequestBody.create(textType, <span class="string">"24"</span>);</div><div class="line"></div><div class="line">        MultipartBody.Part filePart = MultipartBody.Part.createFormData(<span class="string">"file"</span>, <span class="string">"test.txt"</span>, file);</div><div class="line">        Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);</div></pre></td></tr></table></figure><h3 id="第三类：网络请求参数"><a href="#第三类：网络请求参数" class="headerlink" title="第三类：网络请求参数"></a>第三类：网络请求参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-c547f2344eef630b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>详细说明</strong></p><h4 id="a-Header-amp-Headers"><a href="#a-Header-amp-Headers" class="headerlink" title="a.@Header &amp; @Headers"></a>a.@Header &amp; @Headers</h4><ul><li>作用：添加请求头 &amp; 添加不固定的请求头</li><li>具体使用如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @Header</span></div><div class="line"><span class="meta">@GET</span>(<span class="string">"user"</span>)</div><div class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Header(<span class="string">"Authorization"</span>)</span> String authorization)</span></div><div class="line"></div><div class="line"><span class="comment">// @Headers</span></div><div class="line">@<span class="title">Headers</span><span class="params">(<span class="string">"Authorization: authorization"</span>)</span></div><div class="line">@<span class="title">GET</span><span class="params">(<span class="string">"user"</span>)</span></div><div class="line">Call&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></div><div class="line"></div><div class="line"><span class="comment">// 以上的效果是一致的。</span></div><div class="line"><span class="comment">// 区别在于使用场景和使用方式</span></div><div class="line"><span class="comment">// 1. 使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头</span></div><div class="line"><span class="comment">// 2. 使用方式：@Header作用于方法的参数；@Headers作用于方法</span></div></pre></td></tr></table></figure></li></ul><h4 id="b-Body"><a href="#b-Body" class="headerlink" title="b.@Body"></a>b.@Body</h4><ul><li>作用：以<code>post</code>方式 传递 自定义数据类型给服务器</li><li>特别注意：如果提交的是一个Map，那么作用相当于<code>@Field</code><blockquote><p>不过 Map 要经过<code>FormBody.Builder</code>类处理成为符合OkHttp格式的表单，如：</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FormBody.Builder builder = <span class="keyword">new</span> ForBody.Builder();</div><div class="line">builder.add(<span class="string">"key"</span>,<span class="string">"value"</span>);</div></pre></td></tr></table></figure><h4 id="c-Field-amp-FieldMap"><a href="#c-Field-amp-FieldMap" class="headerlink" title="c.@Field &amp; @FieldMap"></a>c.@Field &amp; @FieldMap</h4><ul><li>作用：发送 Post 请求 时提交请求的表单字段</li><li>具体使用：与 @FormUrlEncoded 注解配合使用<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）</div><div class="line">         * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@FormUrlEncoded</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded1</span><span class="params">(@Field(<span class="string">"username"</span>)</span> String name, @<span class="title">Field</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">         * Map的key作为表单的键</div><div class="line">         */</div><div class="line">        <span class="meta">@POST</span>(<span class="string">"/form"</span>)</div><div class="line">        <span class="meta">@FormUrlEncoded</span></div><div class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded2</span><span class="params">(@FieldMap Map&lt;String, Object&gt; map)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体使用</span></div><div class="line">         <span class="comment">// @Field</span></div><div class="line">        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(<span class="string">"Carson"</span>, <span class="number">24</span>);</div><div class="line"></div><div class="line">        <span class="comment">// @FieldMap</span></div><div class="line">        <span class="comment">// 实现的效果与上面相同，但要传入Map</span></div><div class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"username"</span>, <span class="string">"Carson"</span>);</div><div class="line">        map.put(<span class="string">"age"</span>, <span class="number">24</span>);</div><div class="line">        Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map);</div></pre></td></tr></table></figure></li></ul><h4 id="d-Part-amp-PartMap"><a href="#d-Part-amp-PartMap" class="headerlink" title="d.@Part &amp; @PartMap"></a>d.@Part &amp; @PartMap</h4><h4 id="e-Query-amp-QueryMap"><a href="#e-Query-amp-QueryMap" class="headerlink" title="e.@Query &amp; @QueryMap"></a>e.@Query &amp; @QueryMap</h4><h4 id="f-Path"><a href="#f-Path" class="headerlink" title="f.@Path"></a>f.@Path</h4><h4 id="g-Url"><a href="#g-Url" class="headerlink" title="g.@Url"></a>g.@Url</h4><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-f9f8994497df7fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="步骤4：创建-Retrofit-实例"><a href="#步骤4：创建-Retrofit-实例" class="headerlink" title="步骤4：创建 Retrofit 实例"></a>步骤4：创建 Retrofit 实例</h2><h2 id="步骤5：创建-网络请求接口实例-并-配置网络请求参数"><a href="#步骤5：创建-网络请求接口实例-并-配置网络请求参数" class="headerlink" title="步骤5：创建 网络请求接口实例 并 配置网络请求参数"></a>步骤5：创建 网络请求接口实例 并 配置网络请求参数</h2><h2 id="步骤6：发送网络请求（异步-同步）"><a href="#步骤6：发送网络请求（异步-同步）" class="headerlink" title="步骤6：发送网络请求（异步\同步）"></a>步骤6：发送网络请求（异步\同步）</h2><h2 id="步骤7：处理服务器返回的数据"><a href="#步骤7：处理服务器返回的数据" class="headerlink" title="步骤7：处理服务器返回的数据"></a>步骤7：处理服务器返回的数据</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;Android&lt;/strong&gt;开发中，网络请求十分常用&lt;/li&gt;
&lt;li&gt;当下的网络请求加载库中，&lt;stro
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio编译过程</title>
    <link href="https://edward7zhang.github.io/2019/03/02/AndroidStudio%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://edward7zhang.github.io/2019/03/02/AndroidStudio编译过程/</id>
    <published>2019-03-02T04:07:14.000Z</published>
    <updated>2019-03-04T07:35:29.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在此记录一下AndroidStudio编译过程</p></blockquote><p>其中使用到的编译工具：<br>aapt、aidl、Java Compiler、dex、zipalign</p><p>主要步骤描述：</p><pre><code>1.通过aapt打包res资源文件，生成R.java、resource.arsc和res文件（二进制&amp;非二进制如res/raw和pic保持原样）2.处理.aidl文件，生成对应的Java接口文件3.通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件4.通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex5.通过apkbuilder工具，将aapt生成的resource.arsc和res文件、assets文件和classes.dex一起打包生成apk6.通过Jarsigner工具，对上面的apk进行debug或release签名7.通过zipalign工具，将签名后的apk进行对齐处理</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/1420866-79b675761018ff57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/536/format/webp" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/1420866-1402494a5225964e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/993/format/webp" alt="link" title="">                </div>                <div class="image-caption">link</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在此记录一下AndroidStudio编译过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中使用到的编译工具：&lt;br&gt;aapt、aidl、Java Compiler、dex、zipalign&lt;/p&gt;
&lt;p&gt;主要步骤描述：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记一道简单的Java面试题【转载自 知乎——方志宏】</title>
    <link href="https://edward7zhang.github.io/2019/03/01/%E8%AE%B0%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://edward7zhang.github.io/2019/03/01/记一道简单的Java面试题/</id>
    <published>2019-03-01T11:07:14.000Z</published>
    <updated>2019-03-01T08:35:17.911Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是历史上最简单的一道java面试题了。</p><p>题目很简单，完成代码，判断一个整数是否是奇数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span></span></div></pre></td></tr></table></figure><p>相信相当数量的人都已经在准备吐槽了，只要看过《编程珠玑》的人都知道这道题的答案和其中极为简单的道理。不过别着急骂街，不管你信不信，这道笔试题我拿到的答案好多都长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"是奇数"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"是偶数"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后编译一下，发现错误了，挠挠头，顶多改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好吧，我承认我在筛选简历的能力可能有一些问题，不过不管你信不信，好多大厂工作了几年的程序员，都会写出如上风格的代码。</p><p>于是我继续进行引导：</p><p>我：“这个函数的定义要求返回一个什么类型的值？”</p><p>候选人看了看题干：“布尔类型。”</p><p>我：“那么，你if后面的括号里面的表达式的值是一个什么类型的？”</p><p>引导到这一步的时候，依然有高达两成的候选人选择了放弃，表示他们不知道。好吧，我真的不知道你们来面试这个职位的信心何在。不过大部分人想了想，还会回答出正确答案：</p><p>候选人：“也是布尔类型。”</p><p>我：“然后呢？”</p><p>有少量候选人虽然没说出来，但是我能看出来他们觉得这只是一个巧合，并不知道怎么进行下一步。不过，大多数人想了想之后，还是会优化成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>终于过了第一关了，进行第二关的引导：</p><p>我：“那我传进来一个-1呢？”</p><p>将近一半的人在想了想之后会嘴硬地表示他们从小被教导只有自然数才有奇数偶数之分，负数没有奇偶这一说。剩余的人接受了这个设定，想了一会儿，改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span> || i % <span class="number">2</span> == -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>并且在提示之后优化成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好吧，这是迄今为止第一个能通过编译且完全满足了需求的代码实现了。说实话，一开始就写成这样的人，如果没有其他什么明显的缺点的话，我这里基本就能通过了。我承认我的要求比较低，但是来面试的人能直接写出这样的真的不太多，粗略地估计的话，大概占一到两成吧。</p><p>但是这里还没完呢，还有最重要的第三关呢：</p><p>我：“有更好的办法吗？”</p><p>候选人：“？”</p><p>我：“我觉得取模操作比较慢，有更快的解决方案吗？”</p><p>除了少数人能自己想想就想出来了之外，绝大部分（毫不夸张）候选人表示没有或者不知道，于是进行下一步提示：</p><p>我：“奇数和偶数转换成二进制有什么区别？”</p><p>相当一部分候选人表示自己不懂什么叫二进制和位运算，有的还表示java不是c语言，不用研究这些，就跟很多评论会吐槽我在装逼一样。少部分候选人想了想，会怯怯地回答。</p><p>候选人：“奇数最后一位是1，偶数最后一位是0。”</p><p>我：“然后呢？”</p><p>这里很奇怪的点是，大部分能聊到这里来的候选人会想起来移位操作，我真的不知道是为什么，虽然这道题确实可以有这种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i &gt;&gt; <span class="number">1</span> &lt;&lt; <span class="number">1</span> != i;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是这根本不是重点好吧！！！</p><p>总之，无论如何，能在第三关的各种引导之后，能写出下面这个结果来的人，真的不多。能一开始没有任何引导的就写出来的人，至今只见过两个，一个我去哪儿都带着，一个拒了我的offer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i &amp; <span class="number">1</span>) == <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>别以为这就完了！终极boss来了：</p><p>我：“这样是不是比上面取模运算要快？”</p><p>候选人：“那当然了，位运算肯定快啊。”</p><p>我：“但是我们实际代码测试过，发现上面的按位与操作和取模操作，实际运行的时间是差不多的，为什么呢？”</p><p>候选人心里mmp：“闹了半天你这是在逗我玩啊？？？”</p><p>然而真正能回答出原因来的人，面试过程中我没见过，可能是大牛都看不上我所在的公司吧。只有在某公司的时候，一个同事想了想，给出了我正确答案：“编译器会将对2的指数的取模操作，优化成位运算操作。”</p><p>难道是我经历的公司都太low了么……</p><p>作者：方志宏<br>链接：<a href="https://zhuanlan.zhihu.com/p/57859872" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/57859872</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这可能是历史上最简单的一道java面试题了。&lt;/p&gt;
&lt;p&gt;题目很简单，完成代码，判断一个整数是否是奇数：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;l
      
    
    </summary>
    
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance【一面总结】</title>
    <link href="https://edward7zhang.github.io/2019/02/18/ByteDance%E3%80%90%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93%E3%80%91/"/>
    <id>https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/</id>
    <published>2019-02-18T11:07:14.000Z</published>
    <updated>2019-03-02T14:28:47.932Z</updated>
    
    <content type="html"><![CDATA[<p>大概在数天前投递了字节跳动-抖音方向的实习生岗位<br>昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题）</p><h2 id="1-Java中的引用类型有没有什么了解？"><a href="#1-Java中的引用类型有没有什么了解？" class="headerlink" title="1.Java中的引用类型有没有什么了解？"></a>1.Java中的引用类型有没有什么了解？</h2><p>Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。</p><pre><code>StrongReference（强引用）SoftReference（软引用）WeakReference（弱引用）PhantomReference（虚引用）</code></pre><h3 id="引用类型对比"><a href="#引用类型对比" class="headerlink" title="引用类型对比"></a>引用类型对比</h3><table><thead><tr><th>序号</th><th>引用类型</th><th>取得目标对象方式</th><th>垃圾回收条件</th><th>是否可能内存泄漏</th></tr></thead><tbody><tr><td>1</td><td>强引用</td><td>直接调用</td><td>不回收</td><td>可能</td></tr><tr><td>2</td><td>软引用</td><td>通过 get()方法</td><td>视内存情况回收</td><td>不可能</td></tr><tr><td>3</td><td>弱引用</td><td>通过 get()方法</td><td>永远回收</td><td>不可能</td></tr><tr><td>4</td><td>虚引用</td><td>无法取得</td><td>不回收</td><td>可能</td></tr></tbody></table><h4 id="1-StrongReference（强引用）"><a href="#1-StrongReference（强引用）" class="headerlink" title="1.StrongReference（强引用）"></a>1.StrongReference（强引用）</h4><p>如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</div></pre></td></tr></table></figure><h4 id="2-SoftReference（软引用）"><a href="#2-SoftReference（软引用）" class="headerlink" title="2.SoftReference（软引用）"></a>2.SoftReference（软引用）</h4><p>如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h4 id="3-WeakReference（弱引用）"><a href="#3-WeakReference（弱引用）" class="headerlink" title="3.WeakReference（弱引用）"></a>3.WeakReference（弱引用）</h4><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>    弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>    <br><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">WeakReference&lt;String[]&gt; weakBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">WeakReference&lt;String[]&gt; softBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h4 id="4-PhantomReference（虚引用）"><a href="#4-PhantomReference（虚引用）" class="headerlink" title="4.PhantomReference（虚引用）"></a>4.PhantomReference（虚引用）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">PhantomReference&lt;String[]&gt; referent = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h2 id="2-Java中创建线程的方式有哪些"><a href="#2-Java中创建线程的方式有哪些" class="headerlink" title="2.Java中创建线程的方式有哪些"></a>2.Java中创建线程的方式有哪些</h2><h3 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h3><pre><code>(1) 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。(2) 创建Thread子类的实例，即创建了线程对象。(3) 调用线程对象的start()方法来启用该线程。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">FirstThreadTest</span>  <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</div><div class="line"><span class="keyword">int</span>  i  =  <span class="number">0</span>; <span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">System.out.println(getName() +  <span class="string">" "</span>  + i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i  =  <span class="number">0</span>; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">System.out.println(Thread.currentThread().getName() +  <span class="string">" : "</span>  + i);</div><div class="line"><span class="keyword">if</span> (i ==  <span class="number">20</span>) &#123;</div><div class="line"><span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line"><span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName() 方法返回调用该方法的线程的名字。</p><h3 id="2-通过Runnable接口创建线程类"><a href="#2-通过Runnable接口创建线程类" class="headerlink" title="2.通过Runnable接口创建线程类"></a>2.通过Runnable接口创建线程类</h3><pre><code>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法 体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread 对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。</code></pre><h3 id="3-通过Callable和Future创建线程"><a href="#3-通过Callable和Future创建线程" class="headerlink" title="3.通过Callable和Future创建线程"></a>3.通过Callable和Future创建线程</h3><pre><code>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行 体，并且有返回值。（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该 FutureTask对象封装了该Callable对象的call()方法的返回值。（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用 get()方法会阻塞线程。</code></pre><h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><p>采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程 来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型， 较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接 使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。</p><h2 id="3-Object类对象含有的方法有哪些？"><a href="#3-Object类对象含有的方法有哪些？" class="headerlink" title="3.Object类对象含有的方法有哪些？"></a>3.Object类对象含有的方法有哪些？</h2><p>Java中的Object类是所有类的父类，它提供了以下11个方法：</p><pre><code>1.public final native Class&lt;?&gt;getClass()2.public native int hashCode()3.public boolean equals(Object obj)4.protected native Object clone() throws CloneNotSupportedException5.public String toString()6.public final native void notify()7.public final native void notifyAll()8.public final native void wait(long timeout) throws InterruptedException9.public final void wait(long timeout,int nanos)throws InterruptedException10.public final void wait() throws InterruptedException11.protected void finalize() throws Throwable{}</code></pre><h2 id="4-Android中的进程间通信有哪些方式？具体说说Binder"><a href="#4-Android中的进程间通信有哪些方式？具体说说Binder" class="headerlink" title="4.Android中的进程间通信有哪些方式？具体说说Binder"></a>4.Android中的进程间通信有哪些方式？具体说说Binder</h2><p>Android中的IPC方式</p><pre><code>使用Intent使用文件共享使用Messenger使用AIDL使用ContentProvider使用Socket</code></pre><h3 id="1-使用Intent"><a href="#1-使用Intent" class="headerlink" title="1.使用Intent"></a>1.使用Intent</h3><h4 id="1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"><a href="#1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。" class="headerlink" title="1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"></a>1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。</h4><h4 id="2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"><a href="#2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。" class="headerlink" title="2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"></a>2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。</h4><h3 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2.使用文件共享"></a>2.使用文件共享</h3><h4 id="1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem"><a href="#1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem" class="headerlink" title="1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem."></a>1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem.</h4><h4 id="2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"><a href="#2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）" class="headerlink" title="2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"></a>2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）</h4><h4 id="3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"><a href="#3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。" class="headerlink" title="3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"></a>3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。</h4><h3 id="3-使用Messenger"><a href="#3-使用Messenger" class="headerlink" title="3.使用Messenger"></a>3.使用Messenger</h3><p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，可以在不同进程中传递Message对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形</p><ul><li><p>服务端进程：服务端创建一个Service来处理客户端请求，同时通过一个Handler对象来实例化一个Meaaenger对象，然后在Servive的onBind中返回这个Messenger对象底层的Binder即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerSercive</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MessengerSercive.class.getSimpleName();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> msg</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</div><div class="line">                    Log.d(TAG, <span class="string">"receive msg from client: msg = ["</span></div><div class="line">                    + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>);</div><div class="line">                    Toast.makeText(MessengerService.<span class="keyword">this</span>, <span class="string">"receive msg from client: msg = ["</span> + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                    Messenger client = msg.replyTo;</div><div class="line">                    Message replyMsg = Message.obtain(<span class="keyword">null</span>, Constants.MSG_FROM_SERVICE);</div><div class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">                    bundle.putString(Constants.MSG_KEY, <span class="string">"我已经收到你的消息，稍后回复你！"</span>);</div><div class="line">                    replyMsg.setData(bundle);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        client.send(replyMsg);</div><div class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> mMessenger.getBinder();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>客户端进程：首先绑定服务端Service，绑定成功之后用服务端的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，消息类型是Message。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个Messenger（和服务端一样），并通过Message的replyTo参数传递给服务端。服务端通过Message的replyTo参数就可以回应客户端了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity&#123;</div><div class="line">    private static final String TAG = MainActivity.class.getSimpleName();</div><div class="line">    private Messenger mGetReplyMessenger = new Messenger(new MessageHandler());</div><div class="line">    private Messenger mService;</div><div class="line">    private class MessageHandler extends Handler&#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg)&#123;</div><div class="line">            switch(msg.what)&#123;</div><div class="line">                case Constants.MSG_FROM_SERVICE:</div><div class="line">                Log.d(TAG, "received msg form service: msg = </div><div class="line">                [" + msg.getData().getString(Constants.MSG_KEY) + "]");</div><div class="line">                Toast.makeText(MainActivity.this, "received vice: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                super.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInsttanceState)&#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">    public void bindService(View v)&#123;</div><div class="line">        Intent mIntent = new Intent(thia,MessengerService.class);</div><div class="line">        bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">    public void sendMessage(View v)&#123;</div><div class="line">        Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);</div><div class="line">        Bundle data = new Bunle();</div><div class="line">        data.putString(Constants.MSG_KEY, "Hello! This is client.");</div><div class="line">        msg.setData(data);</div><div class="line">        msg.replyTo = mGetReplyMessenger;</div><div class="line">        try&#123;</div><div class="line">            mService.send(mag);</div><div class="line">        &#125;catch(RemoteException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDestroy()&#123;</div><div class="line">        unbindService(mServiceConnection);</div><div class="line">        super.onDestroy();</div><div class="line">    &#125;</div><div class="line">    private ServiceConnection mServiceConnection = new ServiceConnection()&#123;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         * @param service</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder service)&#123;</div><div class="line">            mService = new Messenger(service);</div><div class="line">            Message msg = Message.obtain(null, Constants.MSG_FROM_CLIENT);</div><div class="line">            Bundle data = new Bundle();</div><div class="line">            data.putString(Constants.MSG_KEY,"Hello! This is cient.");</div><div class="line">            msg.setData(data);</div><div class="line">            mag.replyTo = mGetReplyMessenger;</div><div class="line">            try&#123;</div><div class="line">                mService.send(msg);</div><div class="line">            &#125;catch(RemoteException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceDiscommected(ComponentName name)&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>注意： 客户端和服务端是通过通过拿到对方的Messenger来发送Message的。只不过客户端通过bindService onServiceConnected而服务端通过message.replyTo来获得对方的Messenger。Messenger中有一个Hanlder以串行的方式处理队列中的消息。不存在并发执行，因此我们不考虑线程同步的问题。</p><h3 id="4-使用AIDL"><a href="#4-使用AIDL" class="headerlink" title="4.使用AIDL"></a>4.使用AIDL</h3><p>Messenger是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用Messenger，而且Messenger只适合传递消息，不能跨进程调用方法的问题，要知道Messenger本质上也是AIDL，只不过系统做了封装方便上层的调用而已。</p><p><strong>AIDL文件支持的数据类型</strong></p><ul><li>基本数据类型；</li><li>String和CharSequence；</li><li>ArrayList，里面的元素必须能够被AIDL支持；</li><li>HashMap，实现Parcelable接口的对象；注意：如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件。</li><li>AIDL，AIDL接口本身也可以在AIDL文件中使用。<br><strong>服务端</strong><br>服务端创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。<br><strong>客户端</strong><br>绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，然后就可以调用AIDL中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致ANR。客户端的onServiceConnected和onServiceDisconnected方法都在UI线程中。</li></ul><h2 id="5-Android中的AsyncTask的作用？"><a href="#5-Android中的AsyncTask的作用？" class="headerlink" title="5.Android中的AsyncTask的作用？"></a>5.Android中的AsyncTask的作用？</h2><h2 id="6-Android中的消息机制？"><a href="#6-Android中的消息机制？" class="headerlink" title="6.Android中的消息机制？"></a>6.Android中的消息机制？</h2><h2 id="7-Android中的事件分发机制了解多少？如何解决滑动冲突"><a href="#7-Android中的事件分发机制了解多少？如何解决滑动冲突" class="headerlink" title="7.Android中的事件分发机制了解多少？如何解决滑动冲突"></a>7.Android中的事件分发机制了解多少？如何解决滑动冲突</h2><h2 id="8-Java中的抽象类和接口的区别？"><a href="#8-Java中的抽象类和接口的区别？" class="headerlink" title="8.Java中的抽象类和接口的区别？"></a>8.Java中的抽象类和接口的区别？</h2><h3 id="理解抽象"><a href="#理解抽象" class="headerlink" title="理解抽象"></a>理解抽象</h3><p>abstract class 和 interface 是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract calss和interface之间对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。</p><p>其实，两者之间还是有很大区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p><h3 id="语法定义理解"><a href="#语法定义理解" class="headerlink" title="语法定义理解"></a>语法定义理解</h3><h4 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修饰的数据成员（也就是必须是<strong>static final</strong>的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract calss。</p><h3 id="编程角度理解"><a href="#编程角度理解" class="headerlink" title="编程角度理解"></a>编程角度理解</h3><p>首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多继承的支持方面的一种折中考虑吧。</p><p>其次，在abstract class的定义中，我们可以赋予方法的默认行为。</p><p>但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用<strong>default</strong>关键字实现默认方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Java 8 之前，接口与其实现类之间的<strong>耦合度</strong>太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在lambda表达式作为Java8语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。</p><h3 id="一般性理解"><a href="#一般性理解" class="headerlink" title="一般性理解"></a>一般性理解</h3><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是“like-a”关系，抽象类反映的是“is-a”关系。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（if they are class），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它，所以，在高级语言上，一个类只能继承一个类（抽象类）（正如人不可能同时是生物和非生物），但是可以实现多个接口（吃饭接口、走路接口）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。2.抽象类要被子类继承，接口要被类实现。3.接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。4.抽象类里可以没有抽象方法。5.接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。6.接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。7.抽象类不能在Java 8的 lambda 表达式中使用。</code></pre><h2 id="9-Java设计模式了解多少？观察者模式在哪里使用过？"><a href="#9-Java设计模式了解多少？观察者模式在哪里使用过？" class="headerlink" title="9.Java设计模式了解多少？观察者模式在哪里使用过？"></a>9.Java设计模式了解多少？观察者模式在哪里使用过？</h2><h2 id="10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？"><a href="#10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？" class="headerlink" title="10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？"></a>10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大概在数天前投递了字节跳动-抖音方向的实习生岗位&lt;br&gt;昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题）&lt;/p&gt;
&lt;h2 id=&quot;1-Java中的引用类型有没有什么了解？&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>深度学习模型的转换 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://edward7zhang.github.io/2019/01/26/深度学习模型的转换/</id>
    <published>2019-01-26T11:07:14.000Z</published>
    <updated>2019-01-26T14:04:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端部署我们可能会使用feather CNN nihui的NCNN或者小米的mace等框架。facebook ONNX的出现为模型的转换提供了一种思路，但除了pytorch等框架能很好的支持ONNX。其他等框架并未很好的对接ONNX。在<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>出现之前，大家都把caffemodel作为一个中间体来进行转换。</p><p>其实就模型转换而言只是个填参数的过程，把模型结构搭好，把参数填进去就即可，但是实践过的朋友大家一定会知道这其中存在不少坑，但是我们更希望有一种自动化的模型转换方案来进行模型转换。</p><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的出现为模型转换带来了不少的福音，<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>提供了一种IR(中间表示)来来衔接各个模型之间的转换。他囊括并支持了主流的DNN框架。</p><p>下面我就简要讲一下几个的简单模型转换</p><p>在此我推荐一个查看模型结构的工具<a href="https://github.com/lutzroeder/Netron" target="_blank" rel="external">Netron</a> 支持数种主流深度学习框架(Caffe,Tensorflow,ONNX等)的模型结构查看。</p><p>例如下图是MTCNN Pnet的模型结构图</p><p><img src="https://i.loli.net/2019/01/09/5c35f0ad3eaf1.png" alt="det1.png"></p><h3 id="MMdnn的安装"><a href="#MMdnn的安装" class="headerlink" title="MMdnn的安装"></a>MMdnn的安装</h3><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的安装非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mmdnn</div></pre></td></tr></table></figure><h4 id="转换中的一些坑"><a href="#转换中的一些坑" class="headerlink" title="转换中的一些坑"></a>转换中的一些坑</h4><h5 id="1-并不是所有Layer和所有网络都支持转换"><a href="#1-并不是所有Layer和所有网络都支持转换" class="headerlink" title="1.并不是所有Layer和所有网络都支持转换"></a>1.并不是所有Layer和所有网络都支持转换</h5><p>由于各个深度学习框架之间的设计模式不同有的是基于命令式的有的是基于符号形式的。各个框架之间的op的粒度不同，又由于没有一个统一的标准，支持所有框架之间的转换是一件非常难的事情。MMdnn也只是把一些提供的常用的op，如conv,pooling等常规op。</p><h5 id="2-Tensorflow与caffe的padding方式并不相同"><a href="#2-Tensorflow与caffe的padding方式并不相同" class="headerlink" title="2.Tensorflow与caffe的padding方式并不相同"></a>2.Tensorflow与caffe的padding方式并不相同</h5><p>这个问题会出现在MobileNet在转换的过程中，因为Tensorflow的padding方式和其他框架是不同的。Tensorflow标准的卷积操作通常采用非对称的padding，而caffe等其他框架的卷积操作则是采用对称的padding。</p><p>如下图 ，比如当 卷积核的大小为3x3 stride为2的时候。尽管他们的padding方式不同，但卷积之后的尺寸确是一样的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/Microsoft/MMdnn/wiki/image/mobilenet1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h4><p>例如现在我们想把MTCNN的Keras Pnet转化成caffeodel用于部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtoir -f keras -w pnet.h5 -o pnet</div></pre></td></tr></table></figure><p>把keras模型转化成MMdnn IR中间表示，在当然目录下会生成一个.npy 的weights文件和一个.pb文件。接着使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtomodel -f caffe -in pnet -iw pnet.npy -o pnet</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习经典卷积神经网络 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://edward7zhang.github.io/2019/01/16/深度学习经典卷积神经网络/</id>
    <published>2019-01-16T11:07:14.000Z</published>
    <updated>2019-01-26T14:03:30.420Z</updated>
    
    <content type="html"><![CDATA[<p>随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：</p><pre><code>1.LeNet-5, 1998年2.AlexNet, 2012年3.ZF-Net, 2013年4.GoogleNet, 2014年5.VGG, 2014年6.ResNet, 2015年</code></pre><p>经过科研工作者的反复验证及广泛使用，这些模型逐渐成为经典，我们这里收集了一些常用的模型进行介绍。</p><h3 id="1-VGG"><a href="#1-VGG" class="headerlink" title="1. VGG"></a>1. VGG</h3><p><a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="external">论文地址</a></p><p>VGGNet是牛津大学计算机视觉组（Visual Geometry Group）和 Google DeepMind 公司的研究员一起研发的的深度卷积神经网络。VGGNet 探索了卷积神经网络的深度与其性能之间的关系，一共有六种不同的网络结构，但是每种结构都有含有５组卷积，每组卷积都使用３ｘ３的卷积核，每组卷积后进行一个２ｘ２最大池化，接下来是三个全连接层。在训练高级别的网络时，可以先训练低级别的网络，用前者获得的权重初始化高级别的网络，可以加速网络的收敛。VGGNet 相比之前state-of-the-art的网络结构，错误率大幅下降，并取得了ILSVRC 2014比赛分类项目的第2名和定位项目的第1名。同时VGGNet的拓展性很强，迁移到其他图片数据上的泛化性非常好。VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3<em>3）和最大池化尺寸（2</em>2）。<br>到目前为止，VGGNet依然经常被用来提取图像特征。</p><p><a href="https://blog.csdn.net/marsjhao/article/details/72955935" target="_blank" rel="external">经典卷积神经网络之VGGNet</a></p><p><a href="https://blog.csdn.net/qq_40027052/article/details/79015827" target="_blank" rel="external">VGG模型核心拆解</a></p><h3 id="2-GoogLeNet"><a href="#2-GoogLeNet" class="headerlink" title="2. GoogLeNet"></a>2. GoogLeNet</h3><p><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="external">[v1] Going Deeper with Convolutions</a></p><p><a href="http://arxiv.org/abs/1502.03167" target="_blank" rel="external">[v2] Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></p><p><a href="http://arxiv.org/abs/1512.00567" target="_blank" rel="external">[v3] Rethinking the Inception Architecture for Computer Vision</a> </p><p><a href="http://arxiv.org/abs/1602.07261" target="_blank" rel="external">[v4] Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning</a></p><p>GoogLeNet的最早版本，出现在2014年的” Going deeper with convolutions “。之所以名为 “GoogLeNet” 而非 “GoogleNet” ,文章说是为了向早期的LeNet致敬。GoogleNet提出了一个全新的深度 CNN 架构——Inception，无全连接层，可以节省运算的同时，减少了很多参数，参数数量是AlexNet的1/12，数量只有5 million，而且在ImageNet竞赛中取得了很好的成绩。</p><p><a href="https://blog.csdn.net/cdknight_happy/article/details/79247280" target="_blank" rel="external">GoogleNet系列论文学习</a></p><h3 id="3-Resnet"><a href="#3-Resnet" class="headerlink" title="3. Resnet"></a>3. Resnet</h3><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="external">论文地址</a></p><p>ResNet在2015年被提出，在ImageNet比赛classification任务上获得第一名，因为它 “简单与实用” 并存，之后很多方法都建立在ResNet50或者ResNet101的基础上完成的，检测，分割，识别等领域都纷纷使用ResNet，具有很强的适应性。ResNet的作者<a href="http://kaiminghe.com/" target="_blank" rel="external">何凯明</a>也因此摘得CVPR2016最佳论文奖。</p><p><a href="https://blog.csdn.net/lanran2/article/details/79057994" target="_blank" rel="external">ResNet解析</a></p><p><a href="https://blog.csdn.net/xxy0118/article/details/78324256" target="_blank" rel="external">ResNet学习</a></p><h3 id="4-MobileNet-V1-amp-MobileNet-V2"><a href="#4-MobileNet-V1-amp-MobileNet-V2" class="headerlink" title="4. MobileNet-V1 &amp; MobileNet -V2"></a>4. MobileNet-V1 &amp; MobileNet -V2</h3><p><a href="https://arxiv.org/abs/1704.04861" target="_blank" rel="external">V1论文地址</a></p><p><a href="https://arxiv.org/abs/1801.04381" target="_blank" rel="external">V2论文地址</a></p><p>MobileNet是Google团队针对移动端提出的高效图像识别网络，深入的研究了Depthwise Separable Convolutions使用方法后设计出MobileNet，Depthwise Separable Convolutions的本质是冗余信息更少的稀疏化表达。在此基础上给出了高效模型设计的两个选择：宽度因子(Width Multiplier)和分辨率因子(Resolution Multiplier)；通过权衡大小、延迟时间以及精度，来构建规模更小、速度更快的MobileNet。</p><p>MobileNet V2是之前MobileNet V1的改进版。MobileNet V1中主要是引入了Depthwise Separable Convolution代替传统的卷积操作，相当于实现了spatial和channel之间的解耦，达到模型加速的目的，整体网络结构还是延续了VGG网络直上直下的特点。和MobileNet V1相比，MobileNet V2主要的改进有两点：1、Linear Bottlenecks。也就是去掉了小维度输出层后面的非线性激活层，目的是为了保证模型的表达能力。2、Inverted Residual block。该结构和传统residual block中维度先缩减再扩增正好相反，因此shotcut也就变成了连接的是维度缩减后的feature map。</p><p><a href="https://blog.csdn.net/t800ghb/article/details/78879612" target="_blank" rel="external">深度解读谷歌MobileNet</a></p><p><a href="https://blog.csdn.net/u011995719/article/details/79135818" target="_blank" rel="external">轻量化网络：MobileNet-V2</a></p><h3 id="5-U-NET"><a href="#5-U-NET" class="headerlink" title="5. U-NET"></a>5. U-NET</h3><p><a href="http://arxiv.org/abs/1505.04597" target="_blank" rel="external">论文地址</a></p><p><a href="https://lmb.informatik.uni-freiburg.de/people/ronneber/u-net/" target="_blank" rel="external">项目地址</a></p><p>这是Encoder-Decoder网络的一种，在无监督学习中的框架，利用conv与deconv降维升维来进行学习，分别叫做encoder与decoder编码解码，一般基于卷积网络，encoder后相当于学习到了特征，而decoder后相当于还原了图像，既可以用输入图像进行训练，训练好一层加深一层。再可以利用有监督微调，从而达到分类或者图像转换的目的。</p><h3 id="6-GAN"><a href="#6-GAN" class="headerlink" title="6. GAN"></a>6. GAN</h3><p>总结：利用两个网络对抗生成模型，生成器与辨别器，生成器输入图像，生成所需图像，辨别器辨别所需图像与生成图像，使生成器的生成图像骗过辨别器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>常用深度学习框架[学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/09/%E5%B8%B8%E8%A7%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>https://edward7zhang.github.io/2019/01/09/常见深度学习框架/</id>
    <published>2019-01-09T11:07:14.000Z</published>
    <updated>2019-01-09T12:55:52.270Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，针对主流的深度学习框架进行简单对比及介绍。</p><table><thead><tr><th>框架</th><th>机构</th><th>支持语言</th><th>Stars</th><th>Forks</th></tr></thead><tbody><tr><td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">Caffe</a></td><td>BVLC</td><td>C++/Python/Matlab</td><td>25480</td><td>15560</td></tr><tr><td><a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">CNTK</a></td><td>Microsoft</td><td>C++</td><td>15083</td><td>4020</td></tr><tr><td><a href="notebooks/Keras_TF_CNN.ipynb">Keras</a></td><td>Fchollet</td><td>Python</td><td>33332</td><td>12563</td></tr><tr><td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">Tensorflow</a></td><td>Google</td><td>Python/C++/Go…</td><td>109115</td><td>67339</td></tr><tr><td><a href="https://github.com/apache/incubator-mxnet" target="_blank" rel="external">MXNet</a></td><td>DMLC</td><td>Python/C++/R…</td><td>15162</td><td>5484</td></tr><tr><td><a href="https://github.com/pytorch/pytorch" target="_blank" rel="external">PyTorch</a></td><td>Facebook</td><td>Python</td><td>18517</td><td>4426</td></tr></tbody></table><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><h4 id="1-训练时间-Network-DenseNet-121-Multi-GPU"><a href="#1-训练时间-Network-DenseNet-121-Multi-GPU" class="headerlink" title="1. 训练时间: Network DenseNet-121 (Multi-GPU)"></a>1. 训练时间: Network DenseNet-121 (Multi-GPU)</h4><p><strong>运行于 SSD 硬盘</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">27min</td><td style="text-align:center">10min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">38min</td><td style="text-align:center">18min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">33min</td><td style="text-align:center">22min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">29min</td><td style="text-align:center">10min</td></tr></tbody></table><p><strong>运行于RAM内存中</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">25min</td><td style="text-align:center">8min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">36min</td><td style="text-align:center">15min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">25min</td><td style="text-align:center">14min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">28min</td><td style="text-align:center">8min</td></tr></tbody></table><h4 id="2-1000张图片推理时间-s-Network-ResNet-50"><a href="#2-1000张图片推理时间-s-Network-ResNet-50" class="headerlink" title="2. 1000张图片推理时间(s): Network ResNet-50"></a>2. 1000张图片推理时间(s): Network ResNet-50</h4><table><thead><tr><th>框架</th><th style="text-align:center">K80/CUDA 8/CuDNN 6</th><th style="text-align:center">P100/CUDA 8/CuDNN 6</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">8.5</td><td style="text-align:center">1.6</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">10.2</td><td style="text-align:center">2.9</td></tr><tr><td>Tensorflow</td><td style="text-align:center">6.5</td><td style="text-align:center">1.8</td></tr><tr><td>MXNet</td><td style="text-align:center">7.7</td><td style="text-align:center">1.6</td></tr><tr><td>PyTorch</td><td style="text-align:center">7.7</td><td style="text-align:center">1.9</td></tr></tbody></table><h4 id="3-CPU推理时间-s-E5-2630v4-Network-FCN5"><a href="#3-CPU推理时间-s-E5-2630v4-Network-FCN5" class="headerlink" title="3. CPU推理时间(s): E5-2630v4, Network FCN5"></a>3. CPU推理时间(s): E5-2630v4, Network FCN5</h4><table><thead><tr><th>框架</th><th style="text-align:center">1 Thread</th><th style="text-align:center">2 Threads</th><th style="text-align:center">4 Threads</th><th style="text-align:center">8 Threads</th><th style="text-align:center">16 Threads</th><th style="text-align:center">32 Threads</th></tr></thead><tbody><tr><td>Caffe</td><td style="text-align:center">1887.2ms</td><td style="text-align:center">1316.7ms</td><td style="text-align:center">1051.8ms</td><td style="text-align:center">952.1ms</td><td style="text-align:center">952.3ms</td><td style="text-align:center">834.7ms</td></tr><tr><td>CNTK</td><td style="text-align:center">1238.7ms</td><td style="text-align:center">616.3ms</td><td style="text-align:center">352.7ms</td><td style="text-align:center">229.5ms</td><td style="text-align:center">155.9ms</td><td style="text-align:center">192.4ms</td></tr><tr><td>Tensorflow</td><td style="text-align:center">992.2ms</td><td style="text-align:center">773.6ms</td><td style="text-align:center">419.3ms</td><td style="text-align:center">252.3ms</td><td style="text-align:center">149.7ms</td><td style="text-align:center">124.7ms</td></tr><tr><td>MXNet</td><td style="text-align:center">1386.8ms</td><td style="text-align:center">915.5ms</td><td style="text-align:center">559.0ms</td><td style="text-align:center">499.1ms</td><td style="text-align:center">416.3ms</td><td style="text-align:center">413.9ms</td></tr></tbody></table><h3 id="框架评价"><a href="#框架评价" class="headerlink" title="框架评价"></a>框架评价</h3><table><thead><tr><th>框架</th><th style="text-align:center">安装成本</th><th style="text-align:center">代码理解程度</th><th style="text-align:center">API丰富程度</th><th style="text-align:center">模型丰富程度</th><th style="text-align:center">文档完整程度</th><th style="text-align:center">训练与测过程</th><th style="text-align:center">学习资源</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Keras</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td></tr><tr><td>MXNet</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Pytorch</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Tensorflow</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Caffe</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td></tr></tbody></table><h3 id="推荐框架"><a href="#推荐框架" class="headerlink" title="推荐框架"></a>推荐框架</h3><p>目前众多的深度学习框架，使用者只要选择适合自己的框架即可，我们在日常使用中，考虑到训练的快捷程度，部署难度以及对CNN、RNN模型的直接程度，推荐以下几款深度学习框架。</p><h4 id="1-Keras"><a href="#1-Keras" class="headerlink" title="1.Keras"></a>1.Keras</h4><p>Keras 提供了简单易用的 API 接口，入门快，特别适合初学者入门。其后端采用 TensorFlow, CNTK，以及 Theano。另外，Deeplearning4j 的 Python 也是基于 Keras 实现的。Keras 几乎已经成了 Python 神经网络的接口标准。</p><h4 id="2-TensorFlow"><a href="#2-TensorFlow" class="headerlink" title="2.TensorFlow"></a>2.TensorFlow</h4><p>谷歌出品，追随者众多。代码质量高，支持模型丰富，支持语言多样， TensorBoard 可视化工具使用方便。</p><h4 id="3-MXNet"><a href="#3-MXNet" class="headerlink" title="3.MXNet"></a>3.MXNet</h4><p>已被亚马逊选为 AWS 上的深度学习框架，支持动态图计算。MXNet 有许多中国开发者，因而有非常良好的中文文档支持。Gluon 接口使得 MXNet 像 Keras 一样简单易用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://dlbench.comp.hkbu.edu.hk/?v=v8" target="_blank" rel="external">香港浸会大学深度学习框架Benchmark</a></li><li><a href="https://github.com/ilkarman/DeepLearningFrameworks" target="_blank" rel="external">DeepLearningFrameworks</a></li><li><a href="http://app.myzaker.com/news/article.php?pk=5a13b55c1bc8e05d71000016" target="_blank" rel="external">博客</a></li><li><a href="https://www.zhihu.com/question/68114194/answer/465874315" target="_blank" rel="external">开发者如何选择深度学习框架?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>回环，未来可期</title>
    <link href="https://edward7zhang.github.io/2018/08/27/%E5%9B%9E%E7%8E%AF%EF%BC%8C%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/"/>
    <id>https://edward7zhang.github.io/2018/08/27/回环，未来可期/</id>
    <published>2018-08-26T17:42:07.000Z</published>
    <updated>2018-08-26T13:25:57.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天，是我21岁的生日。<br>在一个半月前我辞职了，但准确的说是被动式辞职。<br>现在看来这是一件好事。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8176988f43d.jpg" alt="第一天到公司楼下" title="">                </div>                <div class="image-caption">第一天到公司楼下</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac7c155.jpg" alt="工牌" title="">                </div>                <div class="image-caption">工牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b81769918ccc.jpg" alt="第一天安顿下来" title="">                </div>                <div class="image-caption">第一天安顿下来</div>            </figure><h2 id="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"><a href="#似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历" class="headerlink" title="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"></a>似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历</h2><p>辞职的原因是优秀的project不被认可…所以和我的直接主管就一并选择了离职…</p><p>在外界人看来可能这种做法简直是不解…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173aeb88e9.jpg" alt="嗯，希望这家公司可以保持初心" title="">                </div>                <div class="image-caption">嗯，希望这家公司可以保持初心</div>            </figure><p>可是对于程序猿这类人来说，能做自己感兴趣的事情应该是最高的荣誉…</p><p>况且是在一个优秀project并且在有良好实现的基础上被否掉…这种痛苦莫过于饮鸩</p><p>正如标题所言<strong> 回环 </strong>，刚刚接到消息的时候自己还郁闷了一整天，现在回头看这应该是一种回环，就如同立交桥的转环匝道，虽然又绕回了原点，但是却提升了一个维度。</p><p>幸运如我，在这短暂的实习中遇到了非常nice的主管，涨了很多见识，意识到我之前是多么的短视…从而也看到了自己未来的一些可能，但前提要做一些付出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad848db.jpg" alt="公司对面的腾讯&完美世界" title="">                </div>                <div class="image-caption">公司对面的腾讯&完美世界</div>            </figure><h2 id="在这两个月的实习中，项目进展有如神助"><a href="#在这两个月的实习中，项目进展有如神助" class="headerlink" title="在这两个月的实习中，项目进展有如神助"></a>在这两个月的实习中，项目进展有如神助</h2><p>在实习这段时间，项目进展速度惊人，每天都很充实，每天一组的伙伴们都在一起想对策，现在回头想想也许是之前自己在人工智能方面的一点小小的经验加之主管之前在NLP方面的研究的共交使得项目发展迅速。</p><p>两个月的时间实现了模型的搭建以及demo的实现&amp;项目预演…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a8e14d3.png" alt="工位" title="">                </div>                <div class="image-caption">工位</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac5d381.jpg" alt="在公司最后一天的项目汇报" title="">                </div>                <div class="image-caption">在公司最后一天的项目汇报</div>            </figure><p>至于为什么否掉我们…各种因素…不想明说了…有点官宦风格…各位看客自己想象吧…</p><h2 id="下一步，再进站"><a href="#下一步，再进站" class="headerlink" title="下一步，再进站"></a>下一步，再进站</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad86919.jpg" alt="反射" title="">                </div>                <div class="image-caption">反射</div>            </figure><p>这一趟实习下来，可以说彻底改变了我曾经对自己的看法…</p><p>总的来说，过去我常常视线过度短浅…在对自己人生的规划上也过于保守吧…</p><p>事实上，一个人所看到的往往是狭窄的，通过不断的接触高层次的人和事物才能让自己变得更open。</p><p>决定了考研，也看清了国内的互联网环境的虚实…希望自己能付有所得…</p><p>如果有机会，还是去接触接触技术原始地熏陶熏陶吧…</p><h2 id="未来可期"><a href="#未来可期" class="headerlink" title="未来可期"></a>未来可期</h2><p>在大学里的三年再算上实习的经历…尝试了互联网开发的很多方向…</p><p>最终吸引我的并不是各种框架炫技的开发…而是能赋予应用灵魂的人工智能方向…</p><p>大概未来的发展方向也就定在这样的趋势了…</p><p><strong>继续行走，未来可期。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac9ba83.jpg" alt="离开那天天气很好" title="">                </div>                <div class="image-caption">离开那天天气很好</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a5c08cd.jpg" alt="未来可期" title="">                </div>                <div class="image-caption">未来可期</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天，是我21岁的生日。&lt;br&gt;在一个半月前我辞职了，但准确的说是被动式辞职。&lt;br&gt;现在看来这是一件好事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div 
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>基于TensorFlow的CNN中文文本分类</title>
    <link href="https://edward7zhang.github.io/2018/05/20/%E5%9F%BA%E4%BA%8ETensorFlow%E7%9A%84CNN%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    <id>https://edward7zhang.github.io/2018/05/20/基于TensorFlow的CNN中文文本分类/</id>
    <published>2018-05-20T10:00:07.000Z</published>
    <updated>2018-05-20T10:50:21.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。</p></blockquote><h1 id="CNN实现文本分类的原理"><a href="#CNN实现文本分类的原理" class="headerlink" title="CNN实现文本分类的原理"></a>CNN实现文本分类的原理</h1><p>下图展示了如何使用cnn进行句子分类。输入是一个句子，为了使其可以进行卷积，首先需要将其转化为向量表示，通常使用word2vec实现。d=5表示每个词转化为5维的向量，矩阵的形状是[sentence_length ×× 5]，即[7 ×× 5]。6个filter（卷积核），与图像中使用的卷积核不同的是，nlp使用的卷积核的宽与句子矩阵的宽相同，只是长度不同。这里有（2，3，4）三种size，每种size有两个filter，一共有6个filter。然后开始卷积，从图中可以看出，stride是1，因为对于高是4的filter，最后生成4维的向量，（7-4）/1+1=4。对于高是3的filter，最后生成5维的向量，（7-3）/1+1=5。卷积之后，我们得到句子的特征，使用activation function和1-max-pooling得到最后的值，每个filter最后得到两个特征。将所有特征合并后，使用softmax进行分类。图中没有用到chanel,下文的实验将会使用两个通道，static和non-static，有相关的具体解释。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-12.05.40-PM-1024x937.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h1 id="本文使用的模型"><a href="#本文使用的模型" class="headerlink" title="本文使用的模型"></a>本文使用的模型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-8.03.47-AM-1024x413.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>主要包括五层，第一层是embedding layer,第二层是convolutional layer,第三层是max-pooling layer,第四层是fully connected layer，最后一层是softmax layer.接下来依次介绍相关代码实现。</p><h2 id="Input-placeholder"><a href="#Input-placeholder" class="headerlink" title="Input placeholder"></a>Input placeholder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Placeholders for input, output and dropout</div><div class="line">self.input_x = tf.placeholder(tf.int32, [None, sequence_length], name=&quot;input_x&quot;)</div><div class="line">self.input_y = tf.placeholder(tf.float32, [None, num_classes], name=&quot;input_y&quot;)</div><div class="line">self.dropout_keep_prob = tf.placeholder(tf.float32, name=&quot;dropout_keep_prob&quot;)</div></pre></td></tr></table></figure><p><code>tf.placeholder</code> 创建一个占位符变量，在训练或者测试的时候，需要将占位符输入到网络中进行计算，其中的第二个参数是输入张量的形状。None 意味着它可以是任何维度的长度，在我们的实验中它代表批处理的大小，None使得网络可以处理任意长度的batches。<br>失活率同样也是输入的一部分，在训练的时候使用dropout ，测试的时候不使用dropout 。</p><h2 id="EMBEDDING-LAYER"><a href="#EMBEDDING-LAYER" class="headerlink" title="EMBEDDING LAYER"></a>EMBEDDING LAYER</h2><p>这一层将单词索引映射到低维的向量表示，它本质上是一个查找表，我们从数据中通过学习得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with tf.device(&apos;/cpu:0&apos;), tf.name_scope(&quot;embedding&quot;):</div><div class="line">    W = tf.Variable(tf.random_uniform([vocab_size, embedding_size], -1.0, 1.0), name=&quot;W&quot;)</div><div class="line">    self.embedded_chars = tf.nn.embedding_lookup(W, self.input_x)</div><div class="line">    self.embedded_chars_expanded = tf.expand_dims(self.embedded_chars, -1)</div></pre></td></tr></table></figure><p>其中，<code>W</code> 是 在训练时得到的embedding matrix.，用随机均匀分布进行初始化。<a href="http://blog.csdn.net/u013713117/article/details/55048040" target="_blank" rel="external">tf.nn.embedding_lookup</a>实现embedding操作，得到 一个3-dimensional 的张量，形状是 <code>[None, sequence_length, embedding_size].</code> <code>sequence_length</code> 是数据集中最长句子的长度，其他句子都通过添加“PAD”补充到这个长度。<code>embedding_size</code> 是词向量的大小。</p><p>TensorFlow的卷积函数-<code>conv2d</code> 需要四个参数， 分别是batch, width, height 以及channel。 embedding之后不包括 channel, 所以我们人为地添加上它，并设置为1。现在就是<code>[None, sequence_length, embedding_size, 1]</code></p><h2 id="CONVOLUTION-AND-MAX-POOLING-LAYERS"><a href="#CONVOLUTION-AND-MAX-POOLING-LAYERS" class="headerlink" title="CONVOLUTION AND MAX-POOLING LAYERS"></a>CONVOLUTION AND MAX-POOLING LAYERS</h2><p>由图中可知， 我们有不同size的filters。因为每次卷积都会产生不同形状的张量，所以我们要遍历每个filter，然后将结果合并成一个大的特征向量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pooled_outputs = []</div><div class="line">for i, filter_size in enumerate(filter_sizes):</div><div class="line">    with tf.name_scope(&quot;conv-maxpool-%s&quot; % filter_size):</div><div class="line">        # Convolution Layer</div><div class="line">        filter_shape = [filter_size, embedding_size, 1, num_filters]</div><div class="line">        W = tf.Variable(tf.truncated_normal(filter_shape, stddev=0.1), name=&quot;W&quot;)</div><div class="line">        b = tf.Variable(tf.constant(0.1, shape=[num_filters]), name=&quot;b&quot;)</div><div class="line">        conv = tf.nn.conv2d(</div><div class="line">            self.embedded_chars_expanded,</div><div class="line">            W,</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&quot;VALID&quot;,</div><div class="line">            name=&quot;conv&quot;)</div><div class="line">        # Apply nonlinearity</div><div class="line">        h = tf.nn.relu(tf.nn.bias_add(conv, b), name=&quot;relu&quot;)</div><div class="line">        # Max-pooling over the outputs</div><div class="line">        pooled = tf.nn.max_pool(</div><div class="line">            h,</div><div class="line">            ksize=[1, sequence_length - filter_size + 1, 1, 1],</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&apos;VALID&apos;,</div><div class="line">            name=&quot;pool&quot;)</div><div class="line">        pooled_outputs.append(pooled)</div><div class="line"></div><div class="line"># Combine all the pooled features</div><div class="line">num_filters_total = num_filters * len(filter_sizes)</div><div class="line">self.h_pool = tf.concat(3, pooled_outputs)</div><div class="line">self.h_pool_flat = tf.reshape(self.h_pool, [-1, num_filters_total])</div></pre></td></tr></table></figure><p>这里<code>W</code> 是filter 矩阵，<code>h</code> 是对卷积结果进行非线性转换之后的结果。每个 filter都从整个embedding划过,不同之处在于覆盖多少单词。 “VALID” padding意味着没有对句子的边缘进行padding,也就是用了narrow convolution，输出的形状是 <code>[1, sequence_length - filter_size + 1, 1, 1]</code>。narrow convolution与 wide convolution的区别是是否对边缘进行填充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-9.47.41-AM-1024x261.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br><em>Narrow vs. Wide Convolution. Filter size 5, input size 7. Source: A Convolutional Neural Network for Modelling Sentences (2014)</em><br>当你的filter比输入的size还大时，你可以看到wide convolution是多么的有用，甚至说是必须的。如上所示，narrow convolution产出的尺寸是（7-5）+1=3，而wide convolution产出尺寸是（7+2*4-5）+1=11。通常，输出尺寸的规则表达式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161218225721289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVlbWFpY2hh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br>对输出进行max-pooling后得到形状是 <code>[batch_size, 1, 1, num_filters]</code> 的张量，本质上是一个特征向量，最后一个维度是特征代表数量。把每一个max-pooling之后的张量合并起来之后得到一个长向量 <code>[batch_size, num_filters_total]</code>. in <code>tf.reshape</code> 中的 -1表示T将向量展平。</p><h2 id="DROPOUT-LAYER"><a href="#DROPOUT-LAYER" class="headerlink" title="DROPOUT LAYER"></a>DROPOUT LAYER</h2><p>Dropout也许是cnn中最流行的正则化方法。dropout的想法很简单，dropout layer随机地选择一些神经元，使其失活。这样可以阻止co-adapting,迫使它们每一个都学习到有用的特征。失活的神经单元个数由<code>dropout_keep_prob</code> 决定。在训练的时候设为 0.5 ,测试的时候设为 1 (disable dropout) .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Add dropout</div><div class="line">with tf.name_scope(&quot;dropout&quot;):</div><div class="line">    self.h_drop = tf.nn.dropout(self.h_pool_flat, self.dropout_keep_prob)</div></pre></td></tr></table></figure><h2 id="SCORES-AND-PREDICTIONS"><a href="#SCORES-AND-PREDICTIONS" class="headerlink" title="SCORES AND PREDICTIONS"></a>SCORES AND PREDICTIONS</h2><p>利用特征向量，我们可以用矩阵相乘计算两类的得分，也可以用 softmax函数计算两类的概率值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">with tf.name_scope(&quot;output&quot;):</div><div class="line">    W = tf.Variable(tf.truncated_normal([num_filters_total, num_classes], stddev=0.1), name=&quot;W&quot;)</div><div class="line">    b = tf.Variable(tf.constant(0.1, shape=[num_classes]), name=&quot;b&quot;)</div><div class="line">    self.scores = tf.nn.xw_plus_b(self.h_drop, W, b, name=&quot;scores&quot;)</div><div class="line">    self.predictions = tf.argmax(self.scores, 1, name=&quot;predictions&quot;)</div></pre></td></tr></table></figure><h2 id="LOSS-AND-ACCURACY"><a href="#LOSS-AND-ACCURACY" class="headerlink" title="LOSS AND ACCURACY"></a>LOSS AND ACCURACY</h2><p>可以用得分定义损失值。损失计算的是网络的误差，我们的目标是将其最小化，分类问题标准的损失函数是交叉熵损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate mean cross-entropy loss</div><div class="line">with tf.name_scope(&quot;loss&quot;):</div><div class="line">    losses = tf.nn.softmax_cross_entropy_with_logits(self.scores, self.input_y)</div><div class="line">    self.loss = tf.reduce_mean(losses)</div></pre></td></tr></table></figure><p>计算正确率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate Accuracy</div><div class="line">with tf.name_scope(&quot;accuracy&quot;):</div><div class="line">    correct_predictions = tf.equal(self.predictions, tf.argmax(self.input_y, 1))</div><div class="line">    self.accuracy = tf.reduce_mean(tf.cast(correct_predictions, &quot;float&quot;), name=&quot;accuracy&quot;)</div></pre></td></tr></table></figure><h2 id="MINIMIZING-THE-LOSS"><a href="#MINIMIZING-THE-LOSS" class="headerlink" title="MINIMIZING THE LOSS"></a>MINIMIZING THE LOSS</h2><p>利用TensorFlow 内置的optimizers，例如 Adam optimizer，优化网络损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">global_step = tf.Variable(0, name=&quot;global_step&quot;, trainable=False)</div><div class="line">optimizer = tf.train.AdamOptimizer(1e-4)</div><div class="line">grads_and_vars = optimizer.compute_gradients(cnn.loss)</div><div class="line">train_op = optimizer.apply_gradients(grads_and_vars, global_step=global_step)</div></pre></td></tr></table></figure><p><code>train_op</code> 是一个新建的操作，我们可以在参数上进行梯度更新。每执行一次 <code>train_op</code> 就是一次训练步骤。 TensorFlow 可以自动地计算才那些变量是“可训练的”然后计算他们的梯度。通过<code>global_step</code>这个变量可以计算训练的步数，每训练一次自动加一。</p><h2 id="CHECKPOINTING"><a href="#CHECKPOINTING" class="headerlink" title="CHECKPOINTING"></a>CHECKPOINTING</h2><p>TensorFlow 中可以用checkpointing 保存模型的参数。checkpointing中的参数也可以用来继续训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Checkpointing</div><div class="line">checkpoint_dir = os.path.abspath(os.path.join(out_dir, &quot;checkpoints&quot;))</div><div class="line">checkpoint_prefix = os.path.join(checkpoint_dir, &quot;model&quot;)</div><div class="line"># Tensorflow assumes this directory already exists so we need to create it</div><div class="line">if not os.path.exists(checkpoint_dir):</div><div class="line">    os.makedirs(checkpoint_dir)</div><div class="line">saver = tf.train.Saver(tf.all_variables())</div></pre></td></tr></table></figure><h2 id="DEFINING-A-SINGLE-TRAINING-STEP"><a href="#DEFINING-A-SINGLE-TRAINING-STEP" class="headerlink" title="DEFINING A SINGLE TRAINING STEP"></a>DEFINING A SINGLE TRAINING STEP</h2><p>用一个batch的数据进行一次训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def train_step(x_batch, y_batch):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    A single training step</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: FLAGS.dropout_keep_prob</div><div class="line">    &#125;</div><div class="line">    _, step, summaries, loss, accuracy = sess.run(</div><div class="line">        [train_op, global_step, train_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    train_summary_writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><p><code>train_op</code> 什么也不返回，只是更新网络中的参数。最终，打印出当前训练的损失值与正确率。如果batch的size很小的话，这两者在不同的batch中差别很大。因为使用了dropout，训练的metrics可能要比测试的metrics糟糕。</p><p>同样的函数也可以用在测试时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def dev_step(x_batch, y_batch, writer=None):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Evaluates model on a dev set</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: 1.0</div><div class="line">    &#125;</div><div class="line">    step, summaries, loss, accuracy = sess.run(</div><div class="line">        [global_step, dev_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    if writer:</div><div class="line">        writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><h2 id="TRAINING-LOOP"><a href="#TRAINING-LOOP" class="headerlink" title="TRAINING LOOP"></a>TRAINING LOOP</h2><p>通过迭代数据进行训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Generate batches</div><div class="line">batches = data_helpers.batch_iter(</div><div class="line">    zip(x_train, y_train), FLAGS.batch_size, FLAGS.num_epochs)</div><div class="line"># Training loop. For each batch...</div><div class="line">for batch in batches:</div><div class="line">    x_batch, y_batch = zip(*batch)</div><div class="line">    train_step(x_batch, y_batch)</div><div class="line">    current_step = tf.train.global_step(sess, global_step)</div><div class="line">    if current_step % FLAGS.evaluate_every == 0:</div><div class="line">        print(&quot;\nEvaluation:&quot;)</div><div class="line">        dev_step(x_dev, y_dev, writer=dev_summary_writer)</div><div class="line">        print(&quot;&quot;)</div><div class="line">    if current_step % FLAGS.checkpoint_every == 0:</div><div class="line">        path = saver.save(sess, checkpoint_prefix, global_step=current_step)</div><div class="line">        print(&quot;Saved model checkpoint to &#123;&#125;\n&quot;.format(path))</div></pre></td></tr></table></figure><h2 id="VISUALIZING-RESULTS-IN-TENSORBOARD"><a href="#VISUALIZING-RESULTS-IN-TENSORBOARD" class="headerlink" title="VISUALIZING RESULTS IN TENSORBOARD"></a>VISUALIZING RESULTS IN TENSORBOARD</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.29.14-AM-1024x347.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.27.48-AM-1024x350.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>从上图中我们可以观察到:</p><ul><li>我们的训练 metrics不平滑，因为用的batch sizes很小。如果用大的batches (或者在整个测试集上进行评估)，会得到平滑的线。</li><li>测试集的 accuracy明显比训练集的低，说明网络过拟合了，我们应该用更大的数据集，更强的正则化，更少的模型参数。</li><li>训练集上的 loss 和 accuracy比测试集低的原因是用了dropout.</li></ul><h1 id="参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow"><a href="#参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow" class="headerlink" title="参考：http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/"></a>参考：<a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="external">http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;CNN实现文本分类的原理&quot;&gt;&lt;a href=&quot;#CNN实现文本分类的原理
      
    
    </summary>
    
    
      <category term="TensorFlow" scheme="https://edward7zhang.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>实验室招新题目②</title>
    <link href="https://edward7zhang.github.io/2018/05/08/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE(2)/"/>
    <id>https://edward7zhang.github.io/2018/05/08/实验室招新题目(2)/</id>
    <published>2018-05-08T10:00:07.000Z</published>
    <updated>2018-05-08T16:09:44.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="火车装箱"><a href="#火车装箱" class="headerlink" title="火车装箱"></a>火车装箱</h1><hr><h2 id="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"><a href="#现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车" class="headerlink" title="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"></a>现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车</h2><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul><li>其中每节车厢中包含两种元素 车厢号：<code>TrainNum</code> 以及所装载货物数量：<code>GoodsNum</code>；</li><li>其中每节车厢以<code>前车厢</code> -&gt; <code>后车厢</code> 的形式进行连接；</li><li>按照每节车厢的<code>GoodsNum</code>的降序进行连接；</li><li><p>自定义一个<code>TrainCabin</code>数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span>&#123;</span></div><div class="line"></div><div class="line"><span class="comment">//TODO structure your struct</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>写出一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin* TrainList)</span></span>;</div><div class="line"><span class="comment">//选择你认为时间复杂度最小的算法进行编码</span></div></pre></td></tr></table></figure></li></ul><blockquote><p>返回值为已按照以上要求排好序后的火车链表</p></blockquote><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>第一个值为<code>TrainNum</code></li><li>第二个值为<code>GoodsNum</code></li><li>中间以<code>|</code>分割</li><li>输入<code>-1</code> 以结束输入</li></ul><h3 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h3><pre><code>1 | 32 | 53 | 74 | 25 | 0-1</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>在控制台中打印排好序的火车列</li><li>按照以下示例格式</li></ul><h3 id="Output："><a href="#Output：" class="headerlink" title="Output："></a>Output：</h3><pre><code>| 3 | 7 | -&gt; | 2 | 5 | -&gt; | 1 | 3 | -&gt; | 4 | 2 | -&gt; | 5 | 0 |</code></pre><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>非常基础的一道考察数据抽象、数据结构构造、排序算法、单向链表的简单题…但今天的现场情况不容乐观<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum;</div><div class="line"><span class="keyword">int</span> GoodsNum;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span> *<span class="title">next</span>;</span></div><div class="line">&#125;TrainCabin;</div><div class="line"></div><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line">TrainCabin *i=TrainList;</div><div class="line">TrainCabin *j;</div><div class="line">TrainCabin *temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"><span class="keyword">while</span>(i!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">j=i-&gt;next;</div><div class="line"><span class="keyword">while</span>(j!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>((*i).GoodsNum&gt;(*j).GoodsNum)</div><div class="line">&#123;</div><div class="line">(*temp).TrainNum=(*i).TrainNum;</div><div class="line">(*temp).GoodsNum=(*i).GoodsNum;</div><div class="line">(*i).TrainNum=(*j).TrainNum;</div><div class="line">(*i).GoodsNum=(*j).GoodsNum;</div><div class="line">(*j).TrainNum=(*temp).TrainNum;</div><div class="line">(*j).GoodsNum=(*temp).GoodsNum;</div><div class="line">&#125;</div><div class="line">j=j-&gt;next;</div><div class="line">&#125;</div><div class="line">i=i-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> TrainList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span>(TrainList-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"| -&gt; "</span>;</div><div class="line">TrainList=TrainList-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum=<span class="number">0</span>,GoodsNum=<span class="number">0</span>;</div><div class="line">TrainCabin *frist,*last;</div><div class="line">TrainCabin *temp;</div><div class="line">frist=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">frist-&gt;next=<span class="literal">NULL</span>;</div><div class="line">last=frist;</div><div class="line"><span class="keyword">char</span> input;</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;TrainNum;</div><div class="line"><span class="keyword">if</span>(TrainNum==<span class="number">-1</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;input;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;GoodsNum;</div><div class="line"></div><div class="line">temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;TrainNum=TrainNum;</div><div class="line">temp-&gt;GoodsNum=GoodsNum;</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line">last-&gt;next=temp;</div><div class="line">last=temp;</div><div class="line">&#125;</div><div class="line">TrainCabin *result=AssembleTraninCabin((*frist).next);</div><div class="line">display(result);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;火车装箱&quot;&gt;&lt;a href=&quot;#火车装箱&quot; class=&quot;headerlink&quot; title=&quot;火车装箱&quot;&gt;&lt;/a&gt;火车装箱&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车&quot;&gt;&lt;a href=&quot;#现有一批火车车厢需要按
      
    
    </summary>
    
    
      <category term="Lab_Interview" scheme="https://edward7zhang.github.io/tags/Lab-Interview/"/>
    
  </entry>
  
  <entry>
    <title>后生可畏</title>
    <link href="https://edward7zhang.github.io/2018/05/06/%E5%90%8E%E7%94%9F%E5%8F%AF%E7%95%8F/"/>
    <id>https://edward7zhang.github.io/2018/05/06/后生可畏/</id>
    <published>2018-05-06T15:20:07.000Z</published>
    <updated>2018-05-06T15:44:43.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Take-your-Child-to-work-Day-at-Google-2018"><a href="#Take-your-Child-to-work-Day-at-Google-2018" class="headerlink" title="Take your Child to work Day at Google 2018"></a>Take your Child to work Day at Google 2018</h1><iframe width="600" height="337.3" src="https://www.youtube.com/embed/2nWkYwC2XHI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>When I heared a kid who Firmly said I will be a video game programmer, I realize that it is extraordinary.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Take-your-Child-to-work-Day-at-Google-2018&quot;&gt;&lt;a href=&quot;#Take-your-Child-to-work-Day-at-Google-2018&quot; class=&quot;headerlink&quot; title=&quot;Take you
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
</feed>
