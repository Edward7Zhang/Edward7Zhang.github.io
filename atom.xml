<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EdwardZhang&#39;s Blog</title>
  
  <subtitle>Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://edward7zhang.github.io/"/>
  <updated>2019-01-26T14:04:00.096Z</updated>
  <id>https://edward7zhang.github.io/</id>
  
  <author>
    <name>EdwardZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习模型的转换 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://edward7zhang.github.io/2019/01/26/深度学习模型的转换/</id>
    <published>2019-01-26T11:07:14.000Z</published>
    <updated>2019-01-26T14:04:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端部署我们可能会使用feather CNN nihui的NCNN或者小米的mace等框架。facebook ONNX的出现为模型的转换提供了一种思路，但除了pytorch等框架能很好的支持ONNX。其他等框架并未很好的对接ONNX。在<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>出现之前，大家都把caffemodel作为一个中间体来进行转换。</p><p>其实就模型转换而言只是个填参数的过程，把模型结构搭好，把参数填进去就即可，但是实践过的朋友大家一定会知道这其中存在不少坑，但是我们更希望有一种自动化的模型转换方案来进行模型转换。</p><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的出现为模型转换带来了不少的福音，<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>提供了一种IR(中间表示)来来衔接各个模型之间的转换。他囊括并支持了主流的DNN框架。</p><p>下面我就简要讲一下几个的简单模型转换</p><p>在此我推荐一个查看模型结构的工具<a href="https://github.com/lutzroeder/Netron" target="_blank" rel="external">Netron</a> 支持数种主流深度学习框架(Caffe,Tensorflow,ONNX等)的模型结构查看。</p><p>例如下图是MTCNN Pnet的模型结构图</p><p><img src="https://i.loli.net/2019/01/09/5c35f0ad3eaf1.png" alt="det1.png"></p><h3 id="MMdnn的安装"><a href="#MMdnn的安装" class="headerlink" title="MMdnn的安装"></a>MMdnn的安装</h3><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的安装非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mmdnn</div></pre></td></tr></table></figure><h4 id="转换中的一些坑"><a href="#转换中的一些坑" class="headerlink" title="转换中的一些坑"></a>转换中的一些坑</h4><h5 id="1-并不是所有Layer和所有网络都支持转换"><a href="#1-并不是所有Layer和所有网络都支持转换" class="headerlink" title="1.并不是所有Layer和所有网络都支持转换"></a>1.并不是所有Layer和所有网络都支持转换</h5><p>由于各个深度学习框架之间的设计模式不同有的是基于命令式的有的是基于符号形式的。各个框架之间的op的粒度不同，又由于没有一个统一的标准，支持所有框架之间的转换是一件非常难的事情。MMdnn也只是把一些提供的常用的op，如conv,pooling等常规op。</p><h5 id="2-Tensorflow与caffe的padding方式并不相同"><a href="#2-Tensorflow与caffe的padding方式并不相同" class="headerlink" title="2.Tensorflow与caffe的padding方式并不相同"></a>2.Tensorflow与caffe的padding方式并不相同</h5><p>这个问题会出现在MobileNet在转换的过程中，因为Tensorflow的padding方式和其他框架是不同的。Tensorflow标准的卷积操作通常采用非对称的padding，而caffe等其他框架的卷积操作则是采用对称的padding。</p><p>如下图 ，比如当 卷积核的大小为3x3 stride为2的时候。尽管他们的padding方式不同，但卷积之后的尺寸确是一样的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/Microsoft/MMdnn/wiki/image/mobilenet1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h4><p>例如现在我们想把MTCNN的Keras Pnet转化成caffeodel用于部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtoir -f keras -w pnet.h5 -o pnet</div></pre></td></tr></table></figure><p>把keras模型转化成MMdnn IR中间表示，在当然目录下会生成一个.npy 的weights文件和一个.pb文件。接着使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtomodel -f caffe -in pnet -iw pnet.npy -o pnet</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习经典卷积神经网络 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://edward7zhang.github.io/2019/01/16/深度学习经典卷积神经网络/</id>
    <published>2019-01-16T11:07:14.000Z</published>
    <updated>2019-01-26T14:03:30.420Z</updated>
    
    <content type="html"><![CDATA[<p>随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：</p><pre><code>1.LeNet-5, 1998年2.AlexNet, 2012年3.ZF-Net, 2013年4.GoogleNet, 2014年5.VGG, 2014年6.ResNet, 2015年</code></pre><p>经过科研工作者的反复验证及广泛使用，这些模型逐渐成为经典，我们这里收集了一些常用的模型进行介绍。</p><h3 id="1-VGG"><a href="#1-VGG" class="headerlink" title="1. VGG"></a>1. VGG</h3><p><a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="external">论文地址</a></p><p>VGGNet是牛津大学计算机视觉组（Visual Geometry Group）和 Google DeepMind 公司的研究员一起研发的的深度卷积神经网络。VGGNet 探索了卷积神经网络的深度与其性能之间的关系，一共有六种不同的网络结构，但是每种结构都有含有５组卷积，每组卷积都使用３ｘ３的卷积核，每组卷积后进行一个２ｘ２最大池化，接下来是三个全连接层。在训练高级别的网络时，可以先训练低级别的网络，用前者获得的权重初始化高级别的网络，可以加速网络的收敛。VGGNet 相比之前state-of-the-art的网络结构，错误率大幅下降，并取得了ILSVRC 2014比赛分类项目的第2名和定位项目的第1名。同时VGGNet的拓展性很强，迁移到其他图片数据上的泛化性非常好。VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3<em>3）和最大池化尺寸（2</em>2）。<br>到目前为止，VGGNet依然经常被用来提取图像特征。</p><p><a href="https://blog.csdn.net/marsjhao/article/details/72955935" target="_blank" rel="external">经典卷积神经网络之VGGNet</a></p><p><a href="https://blog.csdn.net/qq_40027052/article/details/79015827" target="_blank" rel="external">VGG模型核心拆解</a></p><h3 id="2-GoogLeNet"><a href="#2-GoogLeNet" class="headerlink" title="2. GoogLeNet"></a>2. GoogLeNet</h3><p><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="external">[v1] Going Deeper with Convolutions</a></p><p><a href="http://arxiv.org/abs/1502.03167" target="_blank" rel="external">[v2] Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></p><p><a href="http://arxiv.org/abs/1512.00567" target="_blank" rel="external">[v3] Rethinking the Inception Architecture for Computer Vision</a> </p><p><a href="http://arxiv.org/abs/1602.07261" target="_blank" rel="external">[v4] Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning</a></p><p>GoogLeNet的最早版本，出现在2014年的” Going deeper with convolutions “。之所以名为 “GoogLeNet” 而非 “GoogleNet” ,文章说是为了向早期的LeNet致敬。GoogleNet提出了一个全新的深度 CNN 架构——Inception，无全连接层，可以节省运算的同时，减少了很多参数，参数数量是AlexNet的1/12，数量只有5 million，而且在ImageNet竞赛中取得了很好的成绩。</p><p><a href="https://blog.csdn.net/cdknight_happy/article/details/79247280" target="_blank" rel="external">GoogleNet系列论文学习</a></p><h3 id="3-Resnet"><a href="#3-Resnet" class="headerlink" title="3. Resnet"></a>3. Resnet</h3><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="external">论文地址</a></p><p>ResNet在2015年被提出，在ImageNet比赛classification任务上获得第一名，因为它 “简单与实用” 并存，之后很多方法都建立在ResNet50或者ResNet101的基础上完成的，检测，分割，识别等领域都纷纷使用ResNet，具有很强的适应性。ResNet的作者<a href="http://kaiminghe.com/" target="_blank" rel="external">何凯明</a>也因此摘得CVPR2016最佳论文奖。</p><p><a href="https://blog.csdn.net/lanran2/article/details/79057994" target="_blank" rel="external">ResNet解析</a></p><p><a href="https://blog.csdn.net/xxy0118/article/details/78324256" target="_blank" rel="external">ResNet学习</a></p><h3 id="4-MobileNet-V1-amp-MobileNet-V2"><a href="#4-MobileNet-V1-amp-MobileNet-V2" class="headerlink" title="4. MobileNet-V1 &amp; MobileNet -V2"></a>4. MobileNet-V1 &amp; MobileNet -V2</h3><p><a href="https://arxiv.org/abs/1704.04861" target="_blank" rel="external">V1论文地址</a></p><p><a href="https://arxiv.org/abs/1801.04381" target="_blank" rel="external">V2论文地址</a></p><p>MobileNet是Google团队针对移动端提出的高效图像识别网络，深入的研究了Depthwise Separable Convolutions使用方法后设计出MobileNet，Depthwise Separable Convolutions的本质是冗余信息更少的稀疏化表达。在此基础上给出了高效模型设计的两个选择：宽度因子(Width Multiplier)和分辨率因子(Resolution Multiplier)；通过权衡大小、延迟时间以及精度，来构建规模更小、速度更快的MobileNet。</p><p>MobileNet V2是之前MobileNet V1的改进版。MobileNet V1中主要是引入了Depthwise Separable Convolution代替传统的卷积操作，相当于实现了spatial和channel之间的解耦，达到模型加速的目的，整体网络结构还是延续了VGG网络直上直下的特点。和MobileNet V1相比，MobileNet V2主要的改进有两点：1、Linear Bottlenecks。也就是去掉了小维度输出层后面的非线性激活层，目的是为了保证模型的表达能力。2、Inverted Residual block。该结构和传统residual block中维度先缩减再扩增正好相反，因此shotcut也就变成了连接的是维度缩减后的feature map。</p><p><a href="https://blog.csdn.net/t800ghb/article/details/78879612" target="_blank" rel="external">深度解读谷歌MobileNet</a></p><p><a href="https://blog.csdn.net/u011995719/article/details/79135818" target="_blank" rel="external">轻量化网络：MobileNet-V2</a></p><h3 id="5-U-NET"><a href="#5-U-NET" class="headerlink" title="5. U-NET"></a>5. U-NET</h3><p><a href="http://arxiv.org/abs/1505.04597" target="_blank" rel="external">论文地址</a></p><p><a href="https://lmb.informatik.uni-freiburg.de/people/ronneber/u-net/" target="_blank" rel="external">项目地址</a></p><p>这是Encoder-Decoder网络的一种，在无监督学习中的框架，利用conv与deconv降维升维来进行学习，分别叫做encoder与decoder编码解码，一般基于卷积网络，encoder后相当于学习到了特征，而decoder后相当于还原了图像，既可以用输入图像进行训练，训练好一层加深一层。再可以利用有监督微调，从而达到分类或者图像转换的目的。</p><h3 id="6-GAN"><a href="#6-GAN" class="headerlink" title="6. GAN"></a>6. GAN</h3><p>总结：利用两个网络对抗生成模型，生成器与辨别器，生成器输入图像，生成所需图像，辨别器辨别所需图像与生成图像，使生成器的生成图像骗过辨别器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>常用深度学习框架[学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/09/%E5%B8%B8%E8%A7%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>https://edward7zhang.github.io/2019/01/09/常见深度学习框架/</id>
    <published>2019-01-09T11:07:14.000Z</published>
    <updated>2019-01-09T12:55:52.270Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，针对主流的深度学习框架进行简单对比及介绍。</p><table><thead><tr><th>框架</th><th>机构</th><th>支持语言</th><th>Stars</th><th>Forks</th></tr></thead><tbody><tr><td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">Caffe</a></td><td>BVLC</td><td>C++/Python/Matlab</td><td>25480</td><td>15560</td></tr><tr><td><a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">CNTK</a></td><td>Microsoft</td><td>C++</td><td>15083</td><td>4020</td></tr><tr><td><a href="notebooks/Keras_TF_CNN.ipynb">Keras</a></td><td>Fchollet</td><td>Python</td><td>33332</td><td>12563</td></tr><tr><td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">Tensorflow</a></td><td>Google</td><td>Python/C++/Go…</td><td>109115</td><td>67339</td></tr><tr><td><a href="https://github.com/apache/incubator-mxnet" target="_blank" rel="external">MXNet</a></td><td>DMLC</td><td>Python/C++/R…</td><td>15162</td><td>5484</td></tr><tr><td><a href="https://github.com/pytorch/pytorch" target="_blank" rel="external">PyTorch</a></td><td>Facebook</td><td>Python</td><td>18517</td><td>4426</td></tr></tbody></table><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><h4 id="1-训练时间-Network-DenseNet-121-Multi-GPU"><a href="#1-训练时间-Network-DenseNet-121-Multi-GPU" class="headerlink" title="1. 训练时间: Network DenseNet-121 (Multi-GPU)"></a>1. 训练时间: Network DenseNet-121 (Multi-GPU)</h4><p><strong>运行于 SSD 硬盘</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">27min</td><td style="text-align:center">10min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">38min</td><td style="text-align:center">18min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">33min</td><td style="text-align:center">22min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">29min</td><td style="text-align:center">10min</td></tr></tbody></table><p><strong>运行于RAM内存中</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">25min</td><td style="text-align:center">8min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">36min</td><td style="text-align:center">15min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">25min</td><td style="text-align:center">14min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">28min</td><td style="text-align:center">8min</td></tr></tbody></table><h4 id="2-1000张图片推理时间-s-Network-ResNet-50"><a href="#2-1000张图片推理时间-s-Network-ResNet-50" class="headerlink" title="2. 1000张图片推理时间(s): Network ResNet-50"></a>2. 1000张图片推理时间(s): Network ResNet-50</h4><table><thead><tr><th>框架</th><th style="text-align:center">K80/CUDA 8/CuDNN 6</th><th style="text-align:center">P100/CUDA 8/CuDNN 6</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">8.5</td><td style="text-align:center">1.6</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">10.2</td><td style="text-align:center">2.9</td></tr><tr><td>Tensorflow</td><td style="text-align:center">6.5</td><td style="text-align:center">1.8</td></tr><tr><td>MXNet</td><td style="text-align:center">7.7</td><td style="text-align:center">1.6</td></tr><tr><td>PyTorch</td><td style="text-align:center">7.7</td><td style="text-align:center">1.9</td></tr></tbody></table><h4 id="3-CPU推理时间-s-E5-2630v4-Network-FCN5"><a href="#3-CPU推理时间-s-E5-2630v4-Network-FCN5" class="headerlink" title="3. CPU推理时间(s): E5-2630v4, Network FCN5"></a>3. CPU推理时间(s): E5-2630v4, Network FCN5</h4><table><thead><tr><th>框架</th><th style="text-align:center">1 Thread</th><th style="text-align:center">2 Threads</th><th style="text-align:center">4 Threads</th><th style="text-align:center">8 Threads</th><th style="text-align:center">16 Threads</th><th style="text-align:center">32 Threads</th></tr></thead><tbody><tr><td>Caffe</td><td style="text-align:center">1887.2ms</td><td style="text-align:center">1316.7ms</td><td style="text-align:center">1051.8ms</td><td style="text-align:center">952.1ms</td><td style="text-align:center">952.3ms</td><td style="text-align:center">834.7ms</td></tr><tr><td>CNTK</td><td style="text-align:center">1238.7ms</td><td style="text-align:center">616.3ms</td><td style="text-align:center">352.7ms</td><td style="text-align:center">229.5ms</td><td style="text-align:center">155.9ms</td><td style="text-align:center">192.4ms</td></tr><tr><td>Tensorflow</td><td style="text-align:center">992.2ms</td><td style="text-align:center">773.6ms</td><td style="text-align:center">419.3ms</td><td style="text-align:center">252.3ms</td><td style="text-align:center">149.7ms</td><td style="text-align:center">124.7ms</td></tr><tr><td>MXNet</td><td style="text-align:center">1386.8ms</td><td style="text-align:center">915.5ms</td><td style="text-align:center">559.0ms</td><td style="text-align:center">499.1ms</td><td style="text-align:center">416.3ms</td><td style="text-align:center">413.9ms</td></tr></tbody></table><h3 id="框架评价"><a href="#框架评价" class="headerlink" title="框架评价"></a>框架评价</h3><table><thead><tr><th>框架</th><th style="text-align:center">安装成本</th><th style="text-align:center">代码理解程度</th><th style="text-align:center">API丰富程度</th><th style="text-align:center">模型丰富程度</th><th style="text-align:center">文档完整程度</th><th style="text-align:center">训练与测过程</th><th style="text-align:center">学习资源</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Keras</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td></tr><tr><td>MXNet</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Pytorch</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Tensorflow</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Caffe</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td></tr></tbody></table><h3 id="推荐框架"><a href="#推荐框架" class="headerlink" title="推荐框架"></a>推荐框架</h3><p>目前众多的深度学习框架，使用者只要选择适合自己的框架即可，我们在日常使用中，考虑到训练的快捷程度，部署难度以及对CNN、RNN模型的直接程度，推荐以下几款深度学习框架。</p><h4 id="1-Keras"><a href="#1-Keras" class="headerlink" title="1.Keras"></a>1.Keras</h4><p>Keras 提供了简单易用的 API 接口，入门快，特别适合初学者入门。其后端采用 TensorFlow, CNTK，以及 Theano。另外，Deeplearning4j 的 Python 也是基于 Keras 实现的。Keras 几乎已经成了 Python 神经网络的接口标准。</p><h4 id="2-TensorFlow"><a href="#2-TensorFlow" class="headerlink" title="2.TensorFlow"></a>2.TensorFlow</h4><p>谷歌出品，追随者众多。代码质量高，支持模型丰富，支持语言多样， TensorBoard 可视化工具使用方便。</p><h4 id="3-MXNet"><a href="#3-MXNet" class="headerlink" title="3.MXNet"></a>3.MXNet</h4><p>已被亚马逊选为 AWS 上的深度学习框架，支持动态图计算。MXNet 有许多中国开发者，因而有非常良好的中文文档支持。Gluon 接口使得 MXNet 像 Keras 一样简单易用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://dlbench.comp.hkbu.edu.hk/?v=v8" target="_blank" rel="external">香港浸会大学深度学习框架Benchmark</a></li><li><a href="https://github.com/ilkarman/DeepLearningFrameworks" target="_blank" rel="external">DeepLearningFrameworks</a></li><li><a href="http://app.myzaker.com/news/article.php?pk=5a13b55c1bc8e05d71000016" target="_blank" rel="external">博客</a></li><li><a href="https://www.zhihu.com/question/68114194/answer/465874315" target="_blank" rel="external">开发者如何选择深度学习框架?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>回环，未来可期</title>
    <link href="https://edward7zhang.github.io/2018/08/27/%E5%9B%9E%E7%8E%AF%EF%BC%8C%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/"/>
    <id>https://edward7zhang.github.io/2018/08/27/回环，未来可期/</id>
    <published>2018-08-26T17:42:07.000Z</published>
    <updated>2018-08-26T13:25:57.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天，是我21岁的生日。<br>在一个半月前我辞职了，但准确的说是被动式辞职。<br>现在看来这是一件好事。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8176988f43d.jpg" alt="第一天到公司楼下" title="">                </div>                <div class="image-caption">第一天到公司楼下</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac7c155.jpg" alt="工牌" title="">                </div>                <div class="image-caption">工牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b81769918ccc.jpg" alt="第一天安顿下来" title="">                </div>                <div class="image-caption">第一天安顿下来</div>            </figure><h2 id="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"><a href="#似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历" class="headerlink" title="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"></a>似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历</h2><p>辞职的原因是优秀的project不被认可…所以和我的直接主管就一并选择了离职…</p><p>在外界人看来可能这种做法简直是不解…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173aeb88e9.jpg" alt="嗯，希望这家公司可以保持初心" title="">                </div>                <div class="image-caption">嗯，希望这家公司可以保持初心</div>            </figure><p>可是对于程序猿这类人来说，能做自己感兴趣的事情应该是最高的荣誉…</p><p>况且是在一个优秀project并且在有良好实现的基础上被否掉…这种痛苦莫过于饮鸩</p><p>正如标题所言<strong> 回环 </strong>，刚刚接到消息的时候自己还郁闷了一整天，现在回头看这应该是一种回环，就如同立交桥的转环匝道，虽然又绕回了原点，但是却提升了一个维度。</p><p>幸运如我，在这短暂的实习中遇到了非常nice的主管，涨了很多见识，意识到我之前是多么的短视…从而也看到了自己未来的一些可能，但前提要做一些付出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad848db.jpg" alt="公司对面的腾讯&完美世界" title="">                </div>                <div class="image-caption">公司对面的腾讯&完美世界</div>            </figure><h2 id="在这两个月的实习中，项目进展有如神助"><a href="#在这两个月的实习中，项目进展有如神助" class="headerlink" title="在这两个月的实习中，项目进展有如神助"></a>在这两个月的实习中，项目进展有如神助</h2><p>在实习这段时间，项目进展速度惊人，每天都很充实，每天一组的伙伴们都在一起想对策，现在回头想想也许是之前自己在人工智能方面的一点小小的经验加之主管之前在NLP方面的研究的共交使得项目发展迅速。</p><p>两个月的时间实现了模型的搭建以及demo的实现&amp;项目预演…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a8e14d3.png" alt="工位" title="">                </div>                <div class="image-caption">工位</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac5d381.jpg" alt="在公司最后一天的项目汇报" title="">                </div>                <div class="image-caption">在公司最后一天的项目汇报</div>            </figure><p>至于为什么否掉我们…各种因素…不想明说了…有点官宦风格…各位看客自己想象吧…</p><h2 id="下一步，再进站"><a href="#下一步，再进站" class="headerlink" title="下一步，再进站"></a>下一步，再进站</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad86919.jpg" alt="反射" title="">                </div>                <div class="image-caption">反射</div>            </figure><p>这一趟实习下来，可以说彻底改变了我曾经对自己的看法…</p><p>总的来说，过去我常常视线过度短浅…在对自己人生的规划上也过于保守吧…</p><p>事实上，一个人所看到的往往是狭窄的，通过不断的接触高层次的人和事物才能让自己变得更open。</p><p>决定了考研，也看清了国内的互联网环境的虚实…希望自己能付有所得…</p><p>如果有机会，还是去接触接触技术原始地熏陶熏陶吧…</p><h2 id="未来可期"><a href="#未来可期" class="headerlink" title="未来可期"></a>未来可期</h2><p>在大学里的三年再算上实习的经历…尝试了互联网开发的很多方向…</p><p>最终吸引我的并不是各种框架炫技的开发…而是能赋予应用灵魂的人工智能方向…</p><p>大概未来的发展方向也就定在这样的趋势了…</p><p><strong>继续行走，未来可期。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac9ba83.jpg" alt="离开那天天气很好" title="">                </div>                <div class="image-caption">离开那天天气很好</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a5c08cd.jpg" alt="未来可期" title="">                </div>                <div class="image-caption">未来可期</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天，是我21岁的生日。&lt;br&gt;在一个半月前我辞职了，但准确的说是被动式辞职。&lt;br&gt;现在看来这是一件好事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div 
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>基于TensorFlow的CNN中文文本分类</title>
    <link href="https://edward7zhang.github.io/2018/05/20/%E5%9F%BA%E4%BA%8ETensorFlow%E7%9A%84CNN%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    <id>https://edward7zhang.github.io/2018/05/20/基于TensorFlow的CNN中文文本分类/</id>
    <published>2018-05-20T10:00:07.000Z</published>
    <updated>2018-05-20T10:50:21.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。</p></blockquote><h1 id="CNN实现文本分类的原理"><a href="#CNN实现文本分类的原理" class="headerlink" title="CNN实现文本分类的原理"></a>CNN实现文本分类的原理</h1><p>下图展示了如何使用cnn进行句子分类。输入是一个句子，为了使其可以进行卷积，首先需要将其转化为向量表示，通常使用word2vec实现。d=5表示每个词转化为5维的向量，矩阵的形状是[sentence_length ×× 5]，即[7 ×× 5]。6个filter（卷积核），与图像中使用的卷积核不同的是，nlp使用的卷积核的宽与句子矩阵的宽相同，只是长度不同。这里有（2，3，4）三种size，每种size有两个filter，一共有6个filter。然后开始卷积，从图中可以看出，stride是1，因为对于高是4的filter，最后生成4维的向量，（7-4）/1+1=4。对于高是3的filter，最后生成5维的向量，（7-3）/1+1=5。卷积之后，我们得到句子的特征，使用activation function和1-max-pooling得到最后的值，每个filter最后得到两个特征。将所有特征合并后，使用softmax进行分类。图中没有用到chanel,下文的实验将会使用两个通道，static和non-static，有相关的具体解释。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-12.05.40-PM-1024x937.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h1 id="本文使用的模型"><a href="#本文使用的模型" class="headerlink" title="本文使用的模型"></a>本文使用的模型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-8.03.47-AM-1024x413.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>主要包括五层，第一层是embedding layer,第二层是convolutional layer,第三层是max-pooling layer,第四层是fully connected layer，最后一层是softmax layer.接下来依次介绍相关代码实现。</p><h2 id="Input-placeholder"><a href="#Input-placeholder" class="headerlink" title="Input placeholder"></a>Input placeholder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Placeholders for input, output and dropout</div><div class="line">self.input_x = tf.placeholder(tf.int32, [None, sequence_length], name=&quot;input_x&quot;)</div><div class="line">self.input_y = tf.placeholder(tf.float32, [None, num_classes], name=&quot;input_y&quot;)</div><div class="line">self.dropout_keep_prob = tf.placeholder(tf.float32, name=&quot;dropout_keep_prob&quot;)</div></pre></td></tr></table></figure><p><code>tf.placeholder</code> 创建一个占位符变量，在训练或者测试的时候，需要将占位符输入到网络中进行计算，其中的第二个参数是输入张量的形状。None 意味着它可以是任何维度的长度，在我们的实验中它代表批处理的大小，None使得网络可以处理任意长度的batches。<br>失活率同样也是输入的一部分，在训练的时候使用dropout ，测试的时候不使用dropout 。</p><h2 id="EMBEDDING-LAYER"><a href="#EMBEDDING-LAYER" class="headerlink" title="EMBEDDING LAYER"></a>EMBEDDING LAYER</h2><p>这一层将单词索引映射到低维的向量表示，它本质上是一个查找表，我们从数据中通过学习得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with tf.device(&apos;/cpu:0&apos;), tf.name_scope(&quot;embedding&quot;):</div><div class="line">    W = tf.Variable(tf.random_uniform([vocab_size, embedding_size], -1.0, 1.0), name=&quot;W&quot;)</div><div class="line">    self.embedded_chars = tf.nn.embedding_lookup(W, self.input_x)</div><div class="line">    self.embedded_chars_expanded = tf.expand_dims(self.embedded_chars, -1)</div></pre></td></tr></table></figure><p>其中，<code>W</code> 是 在训练时得到的embedding matrix.，用随机均匀分布进行初始化。<a href="http://blog.csdn.net/u013713117/article/details/55048040" target="_blank" rel="external">tf.nn.embedding_lookup</a>实现embedding操作，得到 一个3-dimensional 的张量，形状是 <code>[None, sequence_length, embedding_size].</code> <code>sequence_length</code> 是数据集中最长句子的长度，其他句子都通过添加“PAD”补充到这个长度。<code>embedding_size</code> 是词向量的大小。</p><p>TensorFlow的卷积函数-<code>conv2d</code> 需要四个参数， 分别是batch, width, height 以及channel。 embedding之后不包括 channel, 所以我们人为地添加上它，并设置为1。现在就是<code>[None, sequence_length, embedding_size, 1]</code></p><h2 id="CONVOLUTION-AND-MAX-POOLING-LAYERS"><a href="#CONVOLUTION-AND-MAX-POOLING-LAYERS" class="headerlink" title="CONVOLUTION AND MAX-POOLING LAYERS"></a>CONVOLUTION AND MAX-POOLING LAYERS</h2><p>由图中可知， 我们有不同size的filters。因为每次卷积都会产生不同形状的张量，所以我们要遍历每个filter，然后将结果合并成一个大的特征向量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pooled_outputs = []</div><div class="line">for i, filter_size in enumerate(filter_sizes):</div><div class="line">    with tf.name_scope(&quot;conv-maxpool-%s&quot; % filter_size):</div><div class="line">        # Convolution Layer</div><div class="line">        filter_shape = [filter_size, embedding_size, 1, num_filters]</div><div class="line">        W = tf.Variable(tf.truncated_normal(filter_shape, stddev=0.1), name=&quot;W&quot;)</div><div class="line">        b = tf.Variable(tf.constant(0.1, shape=[num_filters]), name=&quot;b&quot;)</div><div class="line">        conv = tf.nn.conv2d(</div><div class="line">            self.embedded_chars_expanded,</div><div class="line">            W,</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&quot;VALID&quot;,</div><div class="line">            name=&quot;conv&quot;)</div><div class="line">        # Apply nonlinearity</div><div class="line">        h = tf.nn.relu(tf.nn.bias_add(conv, b), name=&quot;relu&quot;)</div><div class="line">        # Max-pooling over the outputs</div><div class="line">        pooled = tf.nn.max_pool(</div><div class="line">            h,</div><div class="line">            ksize=[1, sequence_length - filter_size + 1, 1, 1],</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&apos;VALID&apos;,</div><div class="line">            name=&quot;pool&quot;)</div><div class="line">        pooled_outputs.append(pooled)</div><div class="line"></div><div class="line"># Combine all the pooled features</div><div class="line">num_filters_total = num_filters * len(filter_sizes)</div><div class="line">self.h_pool = tf.concat(3, pooled_outputs)</div><div class="line">self.h_pool_flat = tf.reshape(self.h_pool, [-1, num_filters_total])</div></pre></td></tr></table></figure><p>这里<code>W</code> 是filter 矩阵，<code>h</code> 是对卷积结果进行非线性转换之后的结果。每个 filter都从整个embedding划过,不同之处在于覆盖多少单词。 “VALID” padding意味着没有对句子的边缘进行padding,也就是用了narrow convolution，输出的形状是 <code>[1, sequence_length - filter_size + 1, 1, 1]</code>。narrow convolution与 wide convolution的区别是是否对边缘进行填充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-9.47.41-AM-1024x261.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br><em>Narrow vs. Wide Convolution. Filter size 5, input size 7. Source: A Convolutional Neural Network for Modelling Sentences (2014)</em><br>当你的filter比输入的size还大时，你可以看到wide convolution是多么的有用，甚至说是必须的。如上所示，narrow convolution产出的尺寸是（7-5）+1=3，而wide convolution产出尺寸是（7+2*4-5）+1=11。通常，输出尺寸的规则表达式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161218225721289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVlbWFpY2hh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br>对输出进行max-pooling后得到形状是 <code>[batch_size, 1, 1, num_filters]</code> 的张量，本质上是一个特征向量，最后一个维度是特征代表数量。把每一个max-pooling之后的张量合并起来之后得到一个长向量 <code>[batch_size, num_filters_total]</code>. in <code>tf.reshape</code> 中的 -1表示T将向量展平。</p><h2 id="DROPOUT-LAYER"><a href="#DROPOUT-LAYER" class="headerlink" title="DROPOUT LAYER"></a>DROPOUT LAYER</h2><p>Dropout也许是cnn中最流行的正则化方法。dropout的想法很简单，dropout layer随机地选择一些神经元，使其失活。这样可以阻止co-adapting,迫使它们每一个都学习到有用的特征。失活的神经单元个数由<code>dropout_keep_prob</code> 决定。在训练的时候设为 0.5 ,测试的时候设为 1 (disable dropout) .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Add dropout</div><div class="line">with tf.name_scope(&quot;dropout&quot;):</div><div class="line">    self.h_drop = tf.nn.dropout(self.h_pool_flat, self.dropout_keep_prob)</div></pre></td></tr></table></figure><h2 id="SCORES-AND-PREDICTIONS"><a href="#SCORES-AND-PREDICTIONS" class="headerlink" title="SCORES AND PREDICTIONS"></a>SCORES AND PREDICTIONS</h2><p>利用特征向量，我们可以用矩阵相乘计算两类的得分，也可以用 softmax函数计算两类的概率值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">with tf.name_scope(&quot;output&quot;):</div><div class="line">    W = tf.Variable(tf.truncated_normal([num_filters_total, num_classes], stddev=0.1), name=&quot;W&quot;)</div><div class="line">    b = tf.Variable(tf.constant(0.1, shape=[num_classes]), name=&quot;b&quot;)</div><div class="line">    self.scores = tf.nn.xw_plus_b(self.h_drop, W, b, name=&quot;scores&quot;)</div><div class="line">    self.predictions = tf.argmax(self.scores, 1, name=&quot;predictions&quot;)</div></pre></td></tr></table></figure><h2 id="LOSS-AND-ACCURACY"><a href="#LOSS-AND-ACCURACY" class="headerlink" title="LOSS AND ACCURACY"></a>LOSS AND ACCURACY</h2><p>可以用得分定义损失值。损失计算的是网络的误差，我们的目标是将其最小化，分类问题标准的损失函数是交叉熵损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate mean cross-entropy loss</div><div class="line">with tf.name_scope(&quot;loss&quot;):</div><div class="line">    losses = tf.nn.softmax_cross_entropy_with_logits(self.scores, self.input_y)</div><div class="line">    self.loss = tf.reduce_mean(losses)</div></pre></td></tr></table></figure><p>计算正确率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate Accuracy</div><div class="line">with tf.name_scope(&quot;accuracy&quot;):</div><div class="line">    correct_predictions = tf.equal(self.predictions, tf.argmax(self.input_y, 1))</div><div class="line">    self.accuracy = tf.reduce_mean(tf.cast(correct_predictions, &quot;float&quot;), name=&quot;accuracy&quot;)</div></pre></td></tr></table></figure><h2 id="MINIMIZING-THE-LOSS"><a href="#MINIMIZING-THE-LOSS" class="headerlink" title="MINIMIZING THE LOSS"></a>MINIMIZING THE LOSS</h2><p>利用TensorFlow 内置的optimizers，例如 Adam optimizer，优化网络损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">global_step = tf.Variable(0, name=&quot;global_step&quot;, trainable=False)</div><div class="line">optimizer = tf.train.AdamOptimizer(1e-4)</div><div class="line">grads_and_vars = optimizer.compute_gradients(cnn.loss)</div><div class="line">train_op = optimizer.apply_gradients(grads_and_vars, global_step=global_step)</div></pre></td></tr></table></figure><p><code>train_op</code> 是一个新建的操作，我们可以在参数上进行梯度更新。每执行一次 <code>train_op</code> 就是一次训练步骤。 TensorFlow 可以自动地计算才那些变量是“可训练的”然后计算他们的梯度。通过<code>global_step</code>这个变量可以计算训练的步数，每训练一次自动加一。</p><h2 id="CHECKPOINTING"><a href="#CHECKPOINTING" class="headerlink" title="CHECKPOINTING"></a>CHECKPOINTING</h2><p>TensorFlow 中可以用checkpointing 保存模型的参数。checkpointing中的参数也可以用来继续训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Checkpointing</div><div class="line">checkpoint_dir = os.path.abspath(os.path.join(out_dir, &quot;checkpoints&quot;))</div><div class="line">checkpoint_prefix = os.path.join(checkpoint_dir, &quot;model&quot;)</div><div class="line"># Tensorflow assumes this directory already exists so we need to create it</div><div class="line">if not os.path.exists(checkpoint_dir):</div><div class="line">    os.makedirs(checkpoint_dir)</div><div class="line">saver = tf.train.Saver(tf.all_variables())</div></pre></td></tr></table></figure><h2 id="DEFINING-A-SINGLE-TRAINING-STEP"><a href="#DEFINING-A-SINGLE-TRAINING-STEP" class="headerlink" title="DEFINING A SINGLE TRAINING STEP"></a>DEFINING A SINGLE TRAINING STEP</h2><p>用一个batch的数据进行一次训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def train_step(x_batch, y_batch):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    A single training step</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: FLAGS.dropout_keep_prob</div><div class="line">    &#125;</div><div class="line">    _, step, summaries, loss, accuracy = sess.run(</div><div class="line">        [train_op, global_step, train_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    train_summary_writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><p><code>train_op</code> 什么也不返回，只是更新网络中的参数。最终，打印出当前训练的损失值与正确率。如果batch的size很小的话，这两者在不同的batch中差别很大。因为使用了dropout，训练的metrics可能要比测试的metrics糟糕。</p><p>同样的函数也可以用在测试时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def dev_step(x_batch, y_batch, writer=None):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Evaluates model on a dev set</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: 1.0</div><div class="line">    &#125;</div><div class="line">    step, summaries, loss, accuracy = sess.run(</div><div class="line">        [global_step, dev_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    if writer:</div><div class="line">        writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><h2 id="TRAINING-LOOP"><a href="#TRAINING-LOOP" class="headerlink" title="TRAINING LOOP"></a>TRAINING LOOP</h2><p>通过迭代数据进行训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Generate batches</div><div class="line">batches = data_helpers.batch_iter(</div><div class="line">    zip(x_train, y_train), FLAGS.batch_size, FLAGS.num_epochs)</div><div class="line"># Training loop. For each batch...</div><div class="line">for batch in batches:</div><div class="line">    x_batch, y_batch = zip(*batch)</div><div class="line">    train_step(x_batch, y_batch)</div><div class="line">    current_step = tf.train.global_step(sess, global_step)</div><div class="line">    if current_step % FLAGS.evaluate_every == 0:</div><div class="line">        print(&quot;\nEvaluation:&quot;)</div><div class="line">        dev_step(x_dev, y_dev, writer=dev_summary_writer)</div><div class="line">        print(&quot;&quot;)</div><div class="line">    if current_step % FLAGS.checkpoint_every == 0:</div><div class="line">        path = saver.save(sess, checkpoint_prefix, global_step=current_step)</div><div class="line">        print(&quot;Saved model checkpoint to &#123;&#125;\n&quot;.format(path))</div></pre></td></tr></table></figure><h2 id="VISUALIZING-RESULTS-IN-TENSORBOARD"><a href="#VISUALIZING-RESULTS-IN-TENSORBOARD" class="headerlink" title="VISUALIZING RESULTS IN TENSORBOARD"></a>VISUALIZING RESULTS IN TENSORBOARD</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.29.14-AM-1024x347.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.27.48-AM-1024x350.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>从上图中我们可以观察到:</p><ul><li>我们的训练 metrics不平滑，因为用的batch sizes很小。如果用大的batches (或者在整个测试集上进行评估)，会得到平滑的线。</li><li>测试集的 accuracy明显比训练集的低，说明网络过拟合了，我们应该用更大的数据集，更强的正则化，更少的模型参数。</li><li>训练集上的 loss 和 accuracy比测试集低的原因是用了dropout.</li></ul><h1 id="参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow"><a href="#参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow" class="headerlink" title="参考：http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/"></a>参考：<a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="external">http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;CNN实现文本分类的原理&quot;&gt;&lt;a href=&quot;#CNN实现文本分类的原理
      
    
    </summary>
    
    
      <category term="TensorFlow" scheme="https://edward7zhang.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>实验室招新题目②</title>
    <link href="https://edward7zhang.github.io/2018/05/08/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE(2)/"/>
    <id>https://edward7zhang.github.io/2018/05/08/实验室招新题目(2)/</id>
    <published>2018-05-08T10:00:07.000Z</published>
    <updated>2018-05-08T16:09:44.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="火车装箱"><a href="#火车装箱" class="headerlink" title="火车装箱"></a>火车装箱</h1><hr><h2 id="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"><a href="#现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车" class="headerlink" title="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"></a>现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车</h2><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul><li>其中每节车厢中包含两种元素 车厢号：<code>TrainNum</code> 以及所装载货物数量：<code>GoodsNum</code>；</li><li>其中每节车厢以<code>前车厢</code> -&gt; <code>后车厢</code> 的形式进行连接；</li><li>按照每节车厢的<code>GoodsNum</code>的降序进行连接；</li><li><p>自定义一个<code>TrainCabin</code>数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span>&#123;</span></div><div class="line"></div><div class="line"><span class="comment">//TODO structure your struct</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>写出一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin* TrainList)</span></span>;</div><div class="line"><span class="comment">//选择你认为时间复杂度最小的算法进行编码</span></div></pre></td></tr></table></figure></li></ul><blockquote><p>返回值为已按照以上要求排好序后的火车链表</p></blockquote><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>第一个值为<code>TrainNum</code></li><li>第二个值为<code>GoodsNum</code></li><li>中间以<code>|</code>分割</li><li>输入<code>-1</code> 以结束输入</li></ul><h3 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h3><pre><code>1 | 32 | 53 | 74 | 25 | 0-1</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>在控制台中打印排好序的火车列</li><li>按照以下示例格式</li></ul><h3 id="Output："><a href="#Output：" class="headerlink" title="Output："></a>Output：</h3><pre><code>| 3 | 7 | -&gt; | 2 | 5 | -&gt; | 1 | 3 | -&gt; | 4 | 2 | -&gt; | 5 | 0 |</code></pre><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>非常基础的一道考察数据抽象、数据结构构造、排序算法、单向链表的简单题…但今天的现场情况不容乐观<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum;</div><div class="line"><span class="keyword">int</span> GoodsNum;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span> *<span class="title">next</span>;</span></div><div class="line">&#125;TrainCabin;</div><div class="line"></div><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line">TrainCabin *i=TrainList;</div><div class="line">TrainCabin *j;</div><div class="line">TrainCabin *temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"><span class="keyword">while</span>(i!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">j=i-&gt;next;</div><div class="line"><span class="keyword">while</span>(j!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>((*i).GoodsNum&gt;(*j).GoodsNum)</div><div class="line">&#123;</div><div class="line">(*temp).TrainNum=(*i).TrainNum;</div><div class="line">(*temp).GoodsNum=(*i).GoodsNum;</div><div class="line">(*i).TrainNum=(*j).TrainNum;</div><div class="line">(*i).GoodsNum=(*j).GoodsNum;</div><div class="line">(*j).TrainNum=(*temp).TrainNum;</div><div class="line">(*j).GoodsNum=(*temp).GoodsNum;</div><div class="line">&#125;</div><div class="line">j=j-&gt;next;</div><div class="line">&#125;</div><div class="line">i=i-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> TrainList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span>(TrainList-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"| -&gt; "</span>;</div><div class="line">TrainList=TrainList-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum=<span class="number">0</span>,GoodsNum=<span class="number">0</span>;</div><div class="line">TrainCabin *frist,*last;</div><div class="line">TrainCabin *temp;</div><div class="line">frist=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">frist-&gt;next=<span class="literal">NULL</span>;</div><div class="line">last=frist;</div><div class="line"><span class="keyword">char</span> input;</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;TrainNum;</div><div class="line"><span class="keyword">if</span>(TrainNum==<span class="number">-1</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;input;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;GoodsNum;</div><div class="line"></div><div class="line">temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;TrainNum=TrainNum;</div><div class="line">temp-&gt;GoodsNum=GoodsNum;</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line">last-&gt;next=temp;</div><div class="line">last=temp;</div><div class="line">&#125;</div><div class="line">TrainCabin *result=AssembleTraninCabin((*frist).next);</div><div class="line">display(result);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;火车装箱&quot;&gt;&lt;a href=&quot;#火车装箱&quot; class=&quot;headerlink&quot; title=&quot;火车装箱&quot;&gt;&lt;/a&gt;火车装箱&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车&quot;&gt;&lt;a href=&quot;#现有一批火车车厢需要按
      
    
    </summary>
    
    
      <category term="Lab_Interview" scheme="https://edward7zhang.github.io/tags/Lab-Interview/"/>
    
  </entry>
  
  <entry>
    <title>后生可畏</title>
    <link href="https://edward7zhang.github.io/2018/05/06/%E5%90%8E%E7%94%9F%E5%8F%AF%E7%95%8F/"/>
    <id>https://edward7zhang.github.io/2018/05/06/后生可畏/</id>
    <published>2018-05-06T15:20:07.000Z</published>
    <updated>2018-05-06T15:44:43.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Take-your-Child-to-work-Day-at-Google-2018"><a href="#Take-your-Child-to-work-Day-at-Google-2018" class="headerlink" title="Take your Child to work Day at Google 2018"></a>Take your Child to work Day at Google 2018</h1><iframe width="600" height="337.3" src="https://www.youtube.com/embed/2nWkYwC2XHI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>When I heared a kid who Firmly said I will be a video game programmer, I realize that it is extraordinary.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Take-your-Child-to-work-Day-at-Google-2018&quot;&gt;&lt;a href=&quot;#Take-your-Child-to-work-Day-at-Google-2018&quot; class=&quot;headerlink&quot; title=&quot;Take you
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Fragment Navigation Drawer</title>
    <link href="https://edward7zhang.github.io/2018/05/05/Fragment%20Navigation%20Drawer/"/>
    <id>https://edward7zhang.github.io/2018/05/05/Fragment Navigation Drawer/</id>
    <published>2018-05-05T14:20:07.000Z</published>
    <updated>2018-05-05T15:28:55.945Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://camo.githubusercontent.com/6d366e1a5c41a4fc25432102224848023987a8f8/68747470733a2f2f692e6c6f6c692e6e65742f323031382f30352f30352f356165643265643962393236632e706e67" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>..最近这段时间在着手做一个<a href="https://github.com/Edward7Zhang/Sorry-AndroidClient" target="_blank" rel="external">开源项目</a>..使用新鲜的Kotlin以及Google最经典的MaterialDesign..由于刚开始使用自然会碰到很多坑..上面是我的项目Logo🤣<br>本篇文章重点讲解最经典的MaterialDesign中的抽屉式布局 <a href="http://developer.android.com/training/implementing-navigation/nav-drawer.html" target="_blank" rel="external">Navigation Drawer</a>虽然AndroidStudio已经集成了Sample但跟手复现一遍还是很受益的。</p></blockquote><p>在2015年I/O大会上..Google发布了NavigationView，与之前的官方文档相比，本文档更容易创建完整的抽屉式布局<br>随着Android 5.0 Lollipop的发布，新的材料设计风格的抽屉横跨屏幕的整个高度，并显示在<code>ActionBar</code>半透明的上方并重叠<code>StatusBar</code>。<br>Like this：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/hPOFJUf.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>本指南将介绍如何建立一个基于MaterialDesign的可以切换不同Fragment到内容区域的抽屉式导航。In this way,you can define multiple fragments, and then define the list of options which will display in the drawers items list. Each item when clicked will switch the relevant fragment into the activity’s container view.</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>Make sure to setup the Google Design Support Library before using Google’s new NavigationView,announced as part of the Android M release. The NavigationView should be backwards compatible with all versions down to Android 2.1.</p><p>Make sure you have this Gradle dependency added to your <code>app/build.gradle</code> file:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.android.support:design:27.1.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Setup Drawer Resources</p><p>Create a <code>menu/drawer_view.xml</code> file:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_first_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_one"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"First"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_second_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_two"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"Second"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_third_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_three"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"Third"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Note that you can set one of these elements to be default selected by using <code>android:checked=&quot;true&quot;</code> .</p><p>You can also create subheaders too and group elements together:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:title</span>=<span class="string">"Sub items"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">                    <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_dashboard"</span></div><div class="line">                    <span class="attr">android:title</span>=<span class="string">"Sub item 1"</span> /&gt;</div><div class="line">                <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">                    <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_forum"</span></div><div class="line">                    <span class="attr">android:title</span>=<span class="string">"Sub item 2"</span> /&gt;</div><div class="line">            <span class="tag">&lt;/<span class="name">group</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/zoDqDKM.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Define-Fragments"><a href="#Define-Fragments" class="headerlink" title="Define Fragments"></a>Define Fragments</h3><p>接下来，你需要来定义你的Fragments，这些Fragments将会显示在你的Activity中。<br>These can be any support fragments you define within your application. Make sure that all the fragments extend from <strong>android.support.v4.app.Fragment</strong>.</p><h3 id="Setup-Toolbar"><a href="#Setup-Toolbar" class="headerlink" title="Setup Toolbar"></a>Setup Toolbar</h3><p>In order to slide our navigation drawer over the ActionBar, we need to use the new Toolbar widget as defined in the AppCompat v21 library.The <code>Toolbar</code> can be embedded into your view hierarchy which makes sure that the drawer slides over the <code>ActionBar</code>.</p><p>Create a new layout file <code>res/layout/toolbar.xml</code> with the following code:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">    <span class="attr">android:minHeight</span>=<span class="string">"?attr/actionBarSize"</span></div><div class="line">    <span class="attr">app:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimaryDark"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Note that when the <code>android:fitsSystemWindows</code> attribute is set to true for a view, the view would be laid out as if the <code>StatusBar</code> and the <code>ActionBar</code> were present i.e. the UI on top gets padding enough to not be obscured by the navigation bar. Without this attribute, there is not enough padding factored into consideration for the <code>ToolBar</code>:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/HaOAmoh.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>We want our main content view to have the navigation bar and hence <code>android:fitsSystemWindows</code> is set to true for the <code>Toolbar</code>.</p><p>To use the <code>Toolbar</code> as an <code>ActionBar</code>, you need to disable the default <code>ActionBar</code>. This can be done by setting the app theme in <code>styles.xml</code> file.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="xml"></span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#673AB7<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>#512DA8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>Also note that normally you should decide on your color scheme by going to <a href="http://www.materialpalette.com/" target="_blank" rel="external">Material Palette</a> and choosing a primary and dark primary color. For this example, we will pick purple-based colors as shown in the screenshot.</p><p><em>Note</em>: If you forget to disable the ActionBar in <code>styles.xml</code>, you are likely to see a <code>java.lang.IllegalStateException</code> with an error message that reads <code>This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead.</code>If you see this message, you need to make sure to follow the previous steps.</p><h3 id="Setup-Drawer-in-Activity"><a href="#Setup-Drawer-in-Activity" class="headerlink" title="Setup Drawer in Activity"></a>Setup Drawer in Activity</h3><p>Next, let’s setup a basic navigation drawer based on the following layout file which has the entire drawer setup in <code>res/layout/activity_main.xml</code>. Note that the <code>Toolbar</code> is added as the first child of the main content view by adding the include tag. <em>Note: if you are using a CoordinatorLayout, it must not lie outside of the DrawerLayout. See <a href="https://stackoverflow.com/questions/32523188/coordinatorlayout-appbarlayout-navigationdrawer" target="_blank" rel="external">https://stackoverflow.com/questions/32523188/coordinatorlayout-appbarlayout-navigationdrawer</a></em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- This DrawerLayout has two children at the root  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- This LinearLayout represents the contents of the screen  --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The ActionBar displayed at the top --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span></span></div><div class="line">            <span class="attr">layout</span>=<span class="string">"@layout/toolbar"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The main content view where fragments are loaded --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/flContent"</span></div><div class="line">            <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- The navigation drawer that comes from the left --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Note that `android:layout_gravity` needs to be set to 'start' --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/nvView"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span></div><div class="line">        <span class="attr">app:menu</span>=<span class="string">"@menu/drawer_view"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>Now, let’s setup the drawer in our activity. We can also setup the menu icon too.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> DrawerLayout mDrawer;</div><div class="line">  <span class="keyword">private</span> Toolbar toolbar;</div><div class="line"> <span class="keyword">private</span> NavigationView nvDrawer;</div><div class="line"></div><div class="line">  <span class="comment">// Make sure to be using android.support.v7.app.ActionBarDrawerToggle version.</span></div><div class="line"></div><div class="line"> <span class="comment">// The android.support.v4.app.ActionBarDrawerToggle has been deprecated.</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> ActionBarDrawerToggle drawerToggle;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="comment">// Set a Toolbar to replace the ActionBar.</span></div><div class="line"></div><div class="line">        toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">        setSupportActionBar(toolbar);</div><div class="line"></div><div class="line">        <span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">        mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">        <span class="comment">// The action bar home/up action should open or close the drawer.</span></div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (item.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> android.R.id.home:</div><div class="line">                mDrawer.openDrawer(GravityCompat.START);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Navigating-between-Menu-Items"><a href="#Navigating-between-Menu-Items" class="headerlink" title="Navigating between Menu Items"></a>Navigating between Menu Items</h3><p>Setup a handler to respond to click events on the navigation elements and swap out the fragment. This can be put into the activity directly:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...From section above...</span></div><div class="line"></div><div class="line">        <span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">        nvDrawer = (NavigationView) findViewById(R.id.nvView);</div><div class="line">        <span class="comment">// Setup drawer view</span></div><div class="line"></div><div class="line">        setupDrawerContent(nvDrawer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupDrawerContent</span><span class="params">(NavigationView navigationView)</span> </span>&#123;</div><div class="line">        navigationView.setNavigationItemSelectedListener(</div><div class="line">                <span class="keyword">new</span> NavigationView.OnNavigationItemSelectedListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</div><div class="line">                        selectDrawerItem(menuItem);</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectDrawerItem</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</div><div class="line">        <span class="comment">// Create a new fragment and specify the fragment to show based on nav item clicked</span></div><div class="line"></div><div class="line">        Fragment fragment = <span class="keyword">null</span>;</div><div class="line">        Class fragmentClass;</div><div class="line">        <span class="keyword">switch</span>(menuItem.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.nav_first_fragment:</div><div class="line">                fragmentClass = FirstFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.nav_second_fragment:</div><div class="line">                fragmentClass = SecondFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.nav_third_fragment:</div><div class="line">                fragmentClass = ThirdFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                fragmentClass = FirstFragment.class;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fragment = (Fragment) fragmentClass.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Insert the fragment by replacing any existing fragment</span></div><div class="line"></div><div class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</div><div class="line">        fragmentManager.beginTransaction().replace(R.id.flContent, fragment).commit();</div><div class="line"></div><div class="line">        <span class="comment">// Highlight the selected item has been done by NavigationView</span></div><div class="line"></div><div class="line">        menuItem.setChecked(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// Set action bar title</span></div><div class="line"></div><div class="line">        setTitle(menuItem.getTitle());</div><div class="line">        <span class="comment">// Close the navigation drawer</span></div><div class="line"></div><div class="line">        mDrawer.closeDrawers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Add-Navigation-Header"><a href="#Add-Navigation-Header" class="headerlink" title="Add Navigation Header"></a>Add Navigation Header</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/Ri3c6Xz.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>The NavigationView also accepts a custom attribute that can reference a layout that provides a header of our layout. For instance, you can create a <code>layout/nav_header.xml</code> similar to the following:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"192dp"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimaryDark"</span></div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"16dp"</span></div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">    <span class="attr">android:gravity</span>=<span class="string">"bottom"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Header"</span></div><div class="line">        <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span></div><div class="line">        <span class="attr">android:textAppearance</span>=<span class="string">"@style/TextAppearance.AppCompat.Body1"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>You would then reference this in the layout <code>res/layout/activity_main.xml</code> in the <code>NavigationView</code> with the <code>app:headerLayout</code> custom attribute:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- res/layout/activity_main.xml --&gt;</span></div><div class="line"></div><div class="line"> <span class="comment">&lt;!-- The navigation drawer --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></div><div class="line">        <span class="attr">...</span></div><div class="line">        <span class="attr">app:headerLayout</span>=<span class="string">"@layout/nav_header"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.NavigationView</span>&gt;</span></div></pre></td></tr></table></figure><p>This <code>app:headerLayout</code> inflates the specified layout into the header automatically. This can alternatively be done at runtime with:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Lookup navigation view</span></div><div class="line"></div><div class="line">NavigationView navigationView = (NavigationView) findViewById(R.id.nav_draw);</div><div class="line"><span class="comment">// Inflate the header view at runtime</span></div><div class="line"></div><div class="line">View headerLayout = navigationView.inflateHeaderView(R.layout.nav_header);</div><div class="line"><span class="comment">// We can now look up items within the header if needed</span></div><div class="line"></div><div class="line">ImageView ivHeaderPhoto = headerLayout.findViewById(R.id.imageView);</div></pre></td></tr></table></figure><h3 id="Getting-references-to-the-header"><a href="#Getting-references-to-the-header" class="headerlink" title="Getting references to the header"></a>Getting references to the header</h3><p><strong>Note:</strong> Version <code>23.1.0</code> of the design support library switches <code>NavigationView</code> to using a <code>RecyclerView</code> and causes NPE (null exceptions) on header lookups unless the header is added at runtime. If you need to get a reference to the header, you need to use the new <code>getHeaderView()</code>method introduced in the latest <code>v23.1.1</code> update:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// There is usually only 1 header view.  </span></div><div class="line"></div><div class="line"><span class="comment">// Multiple header views can technically be added at runtime.</span></div><div class="line"></div><div class="line"><span class="comment">// We can use navigationView.getHeaderCount() to determine the total number.</span></div><div class="line"></div><div class="line">View headerLayout = navigationView.getHeaderView(<span class="number">0</span>);</div></pre></td></tr></table></figure><h2 id="动画汉堡图标"><a href="#动画汉堡图标" class="headerlink" title="动画汉堡图标"></a>动画汉堡图标</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/ekmWl7q.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了让汉堡包图标动画显示抽屉正在打开和关闭，我们需要使用<a href="https://developer.android.com/reference/android/support/v7/app/ActionBarDrawerToggle.html" target="_blank" rel="external">ActionBarDrawerToggle</a>类。</p><p>在你的<code>res/values/strings.xml</code>添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"drawer_open"</span>&gt;</span>Open navigation drawer<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"drawer_close"</span>&gt;</span>Close navigation drawer<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>我们需要将DrawerLayout和工具栏结合在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; </div><div class="line"><span class="comment">// Set a Toolbar to replace the ActionBar.</span></div><div class="line"></div><div class="line">toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">setSupportActionBar(toolbar);</div><div class="line"></div><div class="line"><span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);</div><div class="line">drawerToggle = setupDrawerToggle();</div><div class="line"></div><div class="line"><span class="comment">// Tie DrawerLayout events to the ActionBarToggle</span></div><div class="line"></div><div class="line">mDrawer.addDrawerListener(drawerToggle);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> ActionBarDrawerToggle <span class="title">setupDrawerToggle</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// <span class="doctag">NOTE:</span> Make sure you pass in a valid toolbar reference.  ActionBarDrawToggle() does not require it</span></div><div class="line"></div><div class="line">      <span class="comment">// and will not render the hamburger icon without it.  </span></div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, mDrawer, toolbar, R.string.drawer_open,  R.string.drawer_close);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>接下来，我们需要确保在恢复屏幕或配置发生变化（即屏幕旋转）时同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `onPostCreate` called when activity start-up is complete after `onStart()`</span></div><div class="line"></div><div class="line"><span class="comment">// NOTE 1: Make sure to override the method with only a single `Bundle` argument</span></div><div class="line"></div><div class="line"><span class="comment">// Note 2: Make sure you implement the correct `onPostCreate(Bundle savedInstanceState)` method. </span></div><div class="line"></div><div class="line"><span class="comment">// There are 2 signatures and only `onPostCreate(Bundle state)` shows the hamburger icon.</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onPostCreate(savedInstanceState);</div><div class="line">    <span class="comment">// Sync the toggle state after onRestoreInstanceState has occurred.</span></div><div class="line"></div><div class="line">    drawerToggle.syncState();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</div><div class="line">    <span class="comment">// Pass any configuration change to the drawer toggles</span></div><div class="line"></div><div class="line">    drawerToggle.onConfigurationChanged(newConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们还需要更改<code>onOptionsItemSelected()</code>方法并允许ActionBarToggle处理事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (drawerToggle.onOptionsItemSelected(item)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ActionBarToggle将执行与先前完成的功能相同的功能，但会添加更多检查，并允许鼠标​​单击图标以打开和关闭抽屉。有关更多上下文，请参阅<a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/src/android/support/v7/app/ActionBarDrawerToggle.java#L285-291" target="_blank" rel="external">源代码</a>。</p><p>有一点需要注意的是，ActionBarDrawerToggle会为您呈现汉堡图标的自定义<a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/src/android/support/v7/graphics/drawable/DrawerArrowDrawable.java" target="_blank" rel="external">DrawerArrowDrawable</a>。</p><p>另外，请确保使用的<code>android.support.v7.app.ActionBarDrawerToggle</code>版本。在<code>android.support.v4.app.ActionBarDrawerToggle</code>已被弃用。</p><h2 id="使状态栏半透明"><a href="#使状态栏半透明" class="headerlink" title="使状态栏半透明"></a>使状态栏半透明</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/o4WvT3k.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要使状态栏变成半透明状态并让我们的抽屉滑过它，我们需要将其设置<code>android:windowTranslucentStatus</code>为true。由于此样式不适用于之前的Kitkat设备，因此我们将为<code>res/values-v19/styles.xml</code>API版本19及之后的版本添加 文件。 <strong>注意</strong>：如果<code>res/values/styles.xml</code>直接用此<code>android:windowTranslucentStatus</code>行修改，则可能需要构建仅适用于19或更高版本的SDK，这显然会限制您支持许多较旧的设备。</p><p>在<code>res/values-v19/styles.xml</code>我们可以添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- Base application theme. --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="xml"></span></div><div class="line">    <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>现在，如果你运行你的应用程序，你应该看到导航抽屉，并能够在你的片段之间进行选择。</p><h2 id="将自定义视图添加到导航抽屉"><a href="#将自定义视图添加到导航抽屉" class="headerlink" title="将自定义视图添加到导航抽屉"></a>将自定义视图添加到导航抽屉</h2><p>对设计支持库23.1.0所做的一项改进是增加了对导航抽屉项目的自定义视图的支持。例如，我们可以为其中一行创建自定义开关，如Google Play电影的导航抽屉：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/gCgB5PQ.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>该方法与将<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-actionview-items" target="_blank" rel="external">ActionView项目</a>添加到ActionBar相同。我们只需要定义一个单独的布局，如下面的代码片段。我们将调用这个文件<code>action_view_switch.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.SwitchCompat</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Switch"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>然后，我们使用该<code>app:actionLayout</code>属性引用此布局。标题必须提供，但也可以设置为空白：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_switch"</span></span></div><div class="line">        <span class="attr">app:actionLayout</span>=<span class="string">"@layout/action_view_switch"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"Downloaded only"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure><p>只要您的活动将实施该方法，您就可以直接使用XML附加事件。要通过Java以编程方式将事件处理添加到切换开关，您需要先获取菜单实例并访问相应的ActionView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Menu menu = navigationView.getMenu();</div><div class="line">MenuItem menuItem = menu.findItem(R.id.nav_switch);</div><div class="line">View actionView = MenuItemCompat.getActionView(menuItem);</div><div class="line">actionView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>自定义小部件的使用<code>app:actionViewClass</code>也可以用于菜单项目。有关Action Views的更多详细信息，请参阅将<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-searchview-to-actionbar" target="_blank" rel="external">SearchView</a>添加<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-searchview-to-actionbar" target="_blank" rel="external">到ActionBar</a>指南。</p><h2 id="持久导航抽屉"><a href="#持久导航抽屉" class="headerlink" title="持久导航抽屉"></a>持久导航抽屉</h2><p>在某些情况下，特别是在平板电脑上，导航抽屉应该是充当侧栏的活动的永久固定装置(Like my Blog Design)：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/9f7nyrA.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要达到此效果，请查看以下描述一种方法的链接：</p><ul><li><a href="http://derekrwoods.com/2013/09/creating-a-static-navigation-drawer-in-android/" target="_blank" rel="external">静态导航抽屉</a></li><li><a href="http://stackoverflow.com/a/18095111" target="_blank" rel="external">相关的Stackoverflow问题</a></li><li><a href="https://github.com/samerzmd/Navigation-Drawer-set-as-always-opened-on-tablets" target="_blank" rel="external">示例代码</a></li></ul><p>第三方库也可能使这更容易实现。</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>有一些第三方库仍然可以作为<code>DrawerLayout</code>直接使用自动提供某些材料设计元素的替代方案：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/6WHIEX5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="external">MaterialDrawer</a></li><li><a href="https://github.com/rudsonlive/NavigationDrawer-MaterialDesign" target="_blank" rel="external">NavigationDrawerMaterial</a></li></ul><p>通常这些都是不必要的，但请检查它们以查看它们提供的功能。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>设计支持库的当前版本的确有其局限性。主要问题在于突出显示导航菜单中的当前项目的系统。NavigationView的itemBackground属性不能正确处理项目的选中状态：不管怎样，所有项目都突出显示或者没有任何项目。这使得这个属性基本上不适用于大多数应用程序。</p><h2 id="Fragment的替代品"><a href="#Fragment的替代品" class="headerlink" title="Fragment的替代品"></a>Fragment的替代品</h2><p>虽然许多导航抽屉示例显示了如何将Fragment用于导航抽屉，但如果您希望将抽屉用作当前显示的活动的叠加层，也可以使用<code>RelativeLayout</code>/ <code>LinearLayout</code>。</p><p>而不是<code>&lt;FrameLayout&gt;</code>你可以用一个<code>&lt;LinearLayout&gt;</code>替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">                <span class="attr">android:id</span>=<span class="string">"@+id/content_frame"</span></div><div class="line">                <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The navigation drawer --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">android:id</span>=<span class="string">"@+id/left_drawer"</span></span></div><div class="line">                  <span class="attr">android:layout_width</span>=<span class="string">"240dp"</span></div><div class="line">                  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">                  <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></div><div class="line">                  <span class="attr">android:choiceMode</span>=<span class="string">"singleChoice"</span></div><div class="line">                  <span class="attr">android:divider</span>=<span class="string">"@android:color/transparent"</span></div><div class="line">                  <span class="attr">android:dividerHeight</span>=<span class="string">"0dp"</span></div><div class="line">                  <span class="attr">android:background</span>=<span class="string">"#111"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>取而代之的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Insert the fragment by replacing any existing fragment</span></div><div class="line"></div><div class="line">getFragmentManager().beginTransaction()</div><div class="line">       .replace(R.id.content_frame, fragment)</div><div class="line">       .commit();</div></pre></td></tr></table></figure><p>您可以改为使用<code>LinearLayout</code>容器直接为活动充气：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LayoutInflater inflater = getLayoutInflater();</div><div class="line">LinearLayout container = (LinearLayout) findViewById(R.id.content_frame);</div><div class="line">inflater.inflate(R.layout.activity_main, container);</div></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html" target="_blank" rel="external">http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html</a></li><li><a href="http://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st" target="_blank" rel="external">http://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st</a></li><li><a href="http://antonioleiva.com/navigation-view/" target="_blank" rel="external">http://antonioleiva.com/navigation-view/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Material Design" scheme="https://edward7zhang.github.io/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>实验室招新题目①</title>
    <link href="https://edward7zhang.github.io/2018/04/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE/"/>
    <id>https://edward7zhang.github.io/2018/04/27/实验室招新题目/</id>
    <published>2018-04-27T10:00:07.000Z</published>
    <updated>2018-05-07T16:02:13.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摇篮排序"><a href="#摇篮排序" class="headerlink" title="摇篮排序"></a>摇篮排序</h1><h2 id="输入摇篮数组以摇篮中的序号为基准进行排序"><a href="#输入摇篮数组以摇篮中的序号为基准进行排序" class="headerlink" title="输入摇篮数组以摇篮中的序号为基准进行排序"></a>输入摇篮数组以摇篮中的序号为基准进行排序</h2><h2 id="请自定义Bucket的数据结构包括"><a href="#请自定义Bucket的数据结构包括" class="headerlink" title="请自定义Bucket的数据结构包括"></a>请自定义Bucket的数据结构包括</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;序号&#125;,&#123;学科&#125;&#125;</div></pre></td></tr></table></figure><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul><li><p>写出一个方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bucket[] sortBucket(Bucket[] J,boolean Flag)</div></pre></td></tr></table></figure></li><li><p>返回为排好序后的Bucket数组并在控制台中答应</p></li><li>Flag == true返回正序排序</li><li>Flag == false返回倒序排序</li></ul><h1 id="面向大一同学要求："><a href="#面向大一同学要求：" class="headerlink" title="面向大一同学要求："></a>面向大一同学要求：</h1><h2 id="在控制台中输入Bucket数组"><a href="#在控制台中输入Bucket数组" class="headerlink" title="在控制台中输入Bucket数组"></a>在控制台中输入Bucket数组</h2><h2 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h2><h2 id="input"><a href="#input" class="headerlink" title="input:"></a>input:</h2><ul><li>1 数学</li><li>3 语文</li><li>2 英语</li><li>true<h2 id="output"><a href="#output" class="headerlink" title="output:"></a>output:</h2></li><li>1 数学</li><li>2 英语</li><li>3 语文</li></ul><h1 id="面向大二同学要求："><a href="#面向大二同学要求：" class="headerlink" title="面向大二同学要求："></a>面向大二同学要求：</h1><h2 id="构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮"><a href="#构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮" class="headerlink" title="构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮"></a>构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮</h2><h2 id="在其中输入Bucket数组"><a href="#在其中输入Bucket数组" class="headerlink" title="在其中输入Bucket数组"></a>在其中输入Bucket数组</h2><h2 id="example：-1"><a href="#example：-1" class="headerlink" title="example："></a>example：</h2><h2 id="input-1"><a href="#input-1" class="headerlink" title="input:"></a>input:</h2><ul><li>1 数学</li><li>3 语文</li><li>2 英语<h2 id="output-1"><a href="#output-1" class="headerlink" title="output:"></a>output:</h2></li><li>1 数学</li><li>2 英语</li><li>3 语文</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摇篮排序&quot;&gt;&lt;a href=&quot;#摇篮排序&quot; class=&quot;headerlink&quot; title=&quot;摇篮排序&quot;&gt;&lt;/a&gt;摇篮排序&lt;/h1&gt;&lt;h2 id=&quot;输入摇篮数组以摇篮中的序号为基准进行排序&quot;&gt;&lt;a href=&quot;#输入摇篮数组以摇篮中的序号为基准进行排序&quot; cla
      
    
    </summary>
    
    
      <category term="Lab_Interview" scheme="https://edward7zhang.github.io/tags/Lab-Interview/"/>
    
  </entry>
  
  <entry>
    <title>三年三月三天三小时</title>
    <link href="https://edward7zhang.github.io/2018/04/27/%E4%B8%89%E5%B9%B4%E4%B8%89%E6%9C%88%E4%B8%89%E5%A4%A9%E4%B8%89%E5%B0%8F%E6%97%B6/"/>
    <id>https://edward7zhang.github.io/2018/04/27/三年三月三天三小时/</id>
    <published>2018-04-26T17:42:07.000Z</published>
    <updated>2018-04-27T07:52:55.006Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" marginwidth="0" marginheight="0" width="300" height="50" src="https://music.163.com/outchain/player?type=2&id=1218773&auto=0&height=32"></iframe></p><h1 id="2018-04-26-14-27-👨‍💻"><a href="#2018-04-26-14-27-👨‍💻" class="headerlink" title="2018.04.26/14:27 👨‍💻"></a>2018.04.26/14:27 👨‍💻</h1><h3 id="我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。"><a href="#我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。" class="headerlink" title="我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。"></a>我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。</h3><h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p>我的价值终于得到了认可…<strong>前20年的知识积奠..后3年的专业浅触..以及3个月来的准备..还有近3天以来的焦虑..最终是拿到Offer前3小时的不镇定</strong>…也许这种过程正是我踏入社会的开始以及最重要的是可以在我梦寐的大平台上开拓自己的视野强化自己的专业知识…这一切也来源于我3年以来的不懈…但更值得感谢的是我的伯乐–我的专业引路人刘老师和班导严老师在这三年来的照料与解惑…反观我三年前刚入校的木讷与轻浮..到现在可以负责实验室..以及得到社会的认可这一路来没有他们的指引我也许还在自己的混沌中不能自拔…<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c7ffc33f5.png" alt="My favorite mural Creazione di Adamo by Michelangelo" title="">                </div>                <div class="image-caption">My favorite mural Creazione di Adamo by Michelangelo</div>            </figure></p><ul><li><p>我也曾愣头青…在还未准备充分就冲去面试阿里…连续挂掉两次的腾讯面试…以及没有音讯的美团…到现在我心心念的还在等结果的大疆…以及我已拿到实习Offer的爱奇艺…</p></li><li><p>拿到Offer的我一点也没有激动…只是让我千疮百孔的心得到了一点满足…</p></li><li><p>在这一路的面试经历中我发现，我最终收益的还是我对专业的坚持…始终没有放弃我热爱的Android移动端开发..当出现新的技术..我总是首先想到应用于移动端…至少这种原力式的驱动来自于我的世界观..我认为在这个时代互联网的最大作用应该是带动人类发展进步..即使如今是个百家合唱的互联网环境..更多的企业选择了推动经济的捞钱式行为…大量的研发资源用于对娱乐或是低俗文化的传播…使得如今都是面向上市敲钟式创业…</p></li><li><p>异曲同工的是最近在年级群中看到有已面50家公司拿到3个Offer的人却大言不惭的写着面经..教唆想去参加工作的同学若是没有项目去某宝花钱购买…纯粹的面向面试的编程令人感到恶俗…地球科技的进步如果存在很多这样的人简直不堪想象吧…</p></li><li><p>如今这个时代有点伪文艺复兴的感觉…好像世间很纷乱…不是那么安定…但大家好像还过得自得其乐…这种自杀式的习惯在一点点的吞噬人类心灵最后的进取…</p></li></ul><h1 id="三年-👹"><a href="#三年-👹" class="headerlink" title="三年 👹"></a>三年 👹</h1><p>大学这三年来其实是憋了一口气的去追赶我高中三年所遗失的种种<br>三年后再看我倒是追回来了一些..这是值得肯定的<br>至少我没有被世俗赶上..至少我暂时赢得了自己的认可</p><h1 id="伯乐-🐎"><a href="#伯乐-🐎" class="headerlink" title="伯乐 🐎"></a>伯乐 🐎</h1><blockquote><p>世有伯乐，然后有千里马。千里马常有，而伯乐不常有。<br>我是一个傲慢的自谦的，不易被他人压制的，向往自由的人。</p></blockquote><p>这三年来我真心的感谢我的班导严灵毓老师、我的计算机语言入门人刘伟老师。<br>是他们的慧眼给了我进升的平台。<br>这两位老师的性格迥异对我来说是非常受益的…</p><ul><li>其一、那种对学生的关怀与学术上、人生上大义至简的指导与沟通是让我摆脱各种木讷与混沌的唯一绳索。</li><li>另一位、那种随性的不羁的帅气的男性风格成为了我对男性理解的标榜…作为我项目指导老师对我的信任，直接影响了我之后对软件产品的看法与理解…将项目大意解释与学生，其他的可以自我发挥的做法，至少目前我没有在其他老师身上发现过…这种对学生的信任同样也是让我辗转各种实验室后最终又回到Lab603的唯一理由…</li></ul><p>现在再回头看看这三年…充实又充满回忆…</p><h1 id="开发者同伴-😎"><a href="#开发者同伴-😎" class="headerlink" title="开发者同伴 😎"></a>开发者同伴 😎</h1><blockquote><p>如果拿伯牙与钟子期的故事来说我们可能过头..其实我们也没有到那种境界…只是想用这种感觉来表达我这三年来对他的感谢，他与我共同开发了我这三年来的大部分项目…</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c382bbaeb.jpg" alt="2016年10月12日 星期三 23:22 张睿在我的宿舍里一起重构项目看到结果后的喜悦" title="">                </div>                <div class="image-caption">2016年10月12日 星期三 23:22 张睿在我的宿舍里一起重构项目看到结果后的喜悦</div>            </figure><p>这三年来不下10个大大小小的项目其中2/3都是我和他共同开发的…无数个通宵..无数个需求的争执无数个问题的解决…在这一系列的过程中如果没有这样一个人的存在又会变得有多大的挑战呢？<br>我现在只能说张睿这三年来感谢你的互助，没有你我也走不到这一步…我会在这条路继续走下去的…只为了我们那无数个日夜的单纯的梦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2d43e09aaf.jpg" alt="2016年10月16日 星期日 3:11 我们合作的第一个项目OneKey2Alarm肝通宵" title="">                </div>                <div class="image-caption">2016年10月16日 星期日 3:11 我们合作的第一个项目OneKey2Alarm肝通宵</div>            </figure><h1 id="Project-⌨️"><a href="#Project-⌨️" class="headerlink" title="Project ⌨️"></a>Project ⌨️</h1><blockquote><p>项目之于开发者如同父与子的关系</p></blockquote><p>相信每一个开发者在完成他的Project后都会加倍心力的去维护他的Project…在这过程中也同时是开发者经验能力提升的关键…所以在面试过程中每个开发者在他过去完成的项目质量与数量就显得格外宝贵..通过项目的侧面观察可以看得出一个人的代码风格..他的个性..他的为人…所以如上文所述的那种面向面试的编程方式是我个人非常厌恶的…我认为只要是一个有追求的开发者..一个合格的程序员都十分摒弃这种做法…通过获取他人的劳动成果来打肿脸充胖子..总有一天会败露的。<br>真诚是一个人最美好也是最底线的品质…如果你想让这个世界达到公平那么久应该人人有责…通过不择手段的方式来通过面试这样对更多优秀的项目开发者无异于是一种侮辱…我周围的同学在最近找工作的过程中没有一个人是轻松的…一家家公司一次次的拒绝到让人怀疑自己…但说实话只有内心强大的人才能冲出这片混沌…因为从此之后你就会脱离象牙塔…不会再有人去庇护你…你要面对的是狰狞而残酷的社会..要为自己的言行负责了…人人不易…唯有坚持才能冲破重围…</p><blockquote><p>在这里同时想感谢我未来的部门领导..是他对我的认可..我才直接的得到了这一提升自己视野的机会…我会向自己证明他并没有看错</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c508827c3.jpg" alt="2018.04 武汉春季Hackthon" title="">                </div>                <div class="image-caption">2018.04 武汉春季Hackthon</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c50d2c899.jpg" alt="2018.04 凌晨4:00 武汉春季Hackthon" title="">                </div>                <div class="image-caption">2018.04 凌晨4:00 武汉春季Hackthon</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c50919947.jpg" alt="2018.04 武汉春季Hackthon 产品展示" title="">                </div>                <div class="image-caption">2018.04 武汉春季Hackthon 产品展示</div>            </figure><h1 id="家庭-👪"><a href="#家庭-👪" class="headerlink" title="家庭 👪"></a>家庭 👪</h1><ul><li>我拥有这样的家庭应该是我人生走过20年所幸至极之事</li><li>父母对我的关心与爱护适合且得当</li><li>父母对我的放养式管理我称为“不管之恩”这种做法间接的使我自由发展寻我所乐</li><li>父母对我的无条件支持我的选择使我受益</li><li>生于张先生与陈女士是我这一生无可比拟的幸运</li></ul><p>感谢我的父母让我度过了无忧的童年、少年..未来世界的狰狞我已经可以独自去面对了，也请你们放心<br>我永远爱你们❤️</p><h1 id="Last-but-not-least-💪"><a href="#Last-but-not-least-💪" class="headerlink" title="Last but not least 💪"></a>Last but not least 💪</h1><p>通过我一次次的失败..经验的积累..也拿到了如愿的Offer…<br>我明白这并不是标榜着什么..而是又一次新的开始..我这长久以来只是在为自己争取去更好的平台学习..发展…<br>在此想给未来的自己说：不要让你之前的努力白费..保持自己的梦想..不要被世俗侵染..保持学习..保持竞争力..切勿自满…</p><blockquote><p>记一个即将步入社会的男生回首过去20年的狰狞与对自己未来的勉励</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c515a6cd2.jpg" alt="Lab603 我的工位 ;-)" title="">                </div>                <div class="image-caption">Lab603 我的工位 ;-)</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;300&quot; height=&quot;50&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=12
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Java与Kotlin下的6种单例模式</title>
    <link href="https://edward7zhang.github.io/2018/04/25/Java%E4%B8%8EKotlin%E4%B8%8B%E7%9A%846%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://edward7zhang.github.io/2018/04/25/Java与Kotlin下的6种单例模式/</id>
    <published>2018-04-25T05:44:14.000Z</published>
    <updated>2018-04-26T11:15:00.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b9b7aa8c2779e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在学习Kotlin，由于Google粑粑把这一语言提携为官方指定，并且对于移动端等开发得天独厚的优势，作为一名AndroidDeveloper学习Kotlin是必要的。<br>当初在学习Java时对单例模式的六种书写与应用记忆深刻<br>所以这次对不同单例模式的Java与Kotlin实现进行了分别探讨。</p></blockquote><p>六种模式如下：</p><ul><li>饿汉模式</li><li>懒汉模式</li><li>线程安全的懒汉模式</li><li>双重校验锁式</li><li>静态内部类式</li><li>枚举式</li></ul><hr><h1 id="饿汉模式：static-final-field"><a href="#饿汉模式：static-final-field" class="headerlink" title="饿汉模式：static final field"></a>饿汉模式：static final field</h1><p>饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。<br>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="comment">//类加载时就初始化</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Kotlin引入了 <code>object</code>类型，可以很容易声明单例模式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="keyword">object</span> Singleton</div></pre></td></tr></table></figure></p><p>这种方式和 Java 单例模式的饿汉式一样，不过比 Java 中的实现代码量少很多，其实是个语法糖（Kotlin漫山遍野都是语法糖）。反编译生成的 class 文件后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        INSTANCE = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从反编译的代码可以看出 object 对象实际上还是利用了 INSTANCE 静态变量，但是在Java和Kotlin混编时，Java代码中调用则需要注意，使用如下<code>Singleton.INSTANCE.test()</code>,Kolint中调用时只需要使用<code>Singleton.test()</code>。<br>这种实现方式在类加载时就创建了单例对象，所以肯定是线程安全的，但是还是有饿汉式实现方式的问题：</p><ul><li>如果构造方法中有耗时操作的话，会导致这个类的加载比较慢。</li><li>饿汉式一开始就创建实例，但是并没有调用，会造成资源浪费。</li><li>还有一个 Java 饿汉式单例模式没有的问题：无法自定义构造函数，object 中不允许 constructor 函数。</li></ul><h1 id="懒汉模式：线程不安全"><a href="#懒汉模式：线程不安全" class="headerlink" title="懒汉模式：线程不安全"></a>懒汉模式：线程不安全</h1><p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance : Singleton? = <span class="literal">null</span></div><div class="line">        <span class="keyword">get</span>()&#123;</div><div class="line">            <span class="keyword">if</span>(field == <span class="literal">null</span>)&#123;</div><div class="line">                field = Singleton()</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> field</div><div class="line">        &#125; </div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>:Singleton&#123;</div><div class="line">            <span class="keyword">return</span> instance!!</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述代码中，我们可以发现在Kotlin实现中，我们让其<strong>主构造函数私有化</strong>并自定义了其<strong>属性访问器</strong>，其余内容大同小异。</p><ul><li>如果不清楚Kotlin构造函数的使用方式。请点击 - - - <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fclasses.html" target="_blank" rel="external">构造函数</a></li><li>不清楚Kotlin的属性与访问器，请点击 - - -<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fproperties.html" target="_blank" rel="external">属性和字段</a></li></ul><h1 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h1><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></div><div class="line">            <span class="keyword">get</span>() &#123;</div><div class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</div><div class="line">                    field = Singleton()</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> field</div><div class="line">            &#125;</div><div class="line">        <span class="meta">@Synchronized</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: Singleton&#123;</div><div class="line">            <span class="keyword">return</span> instance!!</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>大家都知道在使用懒汉式会出现线程安全的问题，需要使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加 <strong>@Synchronized</strong> 注解</p><h1 id="双重校验锁式"><a href="#双重校验锁式" class="headerlink" title="双重校验锁式"></a>双重校验锁式</h1><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * volatile保证了：</div><div class="line"> * 1.instance再多线程下的并发可见性</div><div class="line"> * 2.禁止instance在操作时的指令重排序</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getIntance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="comment">//第一次判空，保证不必要的同步</span></div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line"><span class="comment">//synchronized对Singleton加全局锁，保证每次只要一个线程创建实例</span></div><div class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line"><span class="comment">//第二次判空时为了在null的情况下创建实例</span></div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。<strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><ul><li>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</li></ul><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</div><div class="line">        <span class="keyword">val</span> instance: Singleton <span class="keyword">by</span> lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123;</div><div class="line">            SingletonDemo()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的<strong>延迟属性 Lazy</strong>。</p><p><strong>Lazy</strong>是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</p><p>这里还有有两个额外的知识点。</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Flambdas.html" target="_blank" rel="external">高阶函数</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fdelegated-properties.html" target="_blank" rel="external">委托属性</a></li></ul><p>如果你了解以上知识点，我们直接来看Lazy的内部实现。</p><ul><li>Lazy内部实现</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: ()</span></span> -&gt; T): Lazy&lt;T&gt; =</div><div class="line">        <span class="keyword">when</span> (mode) &#123;</div><div class="line">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</div><div class="line">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</div><div class="line">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>观察上述代码，因为我们传入的<strong>mode = LazyThreadSafetyMode.SYNCHRONIZED</strong>， 那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。</p><ul><li>Lazy接口</li></ul><p>SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lazy</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</div><div class="line">     <span class="comment">//当前实例化对象，一旦实例化后，该对象不会再改变</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</div><div class="line">    <span class="comment">//返回true表示，已经延迟实例化过了，false 表示，没有被实例化，</span></div><div class="line">    <span class="comment">//一旦方法返回true，该方法会一直返回true,且不会再继续实例化</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>继续查看SynchronizedLazyImpl，具体实现如下：</p><ul><li>SynchronizedLazyImpl内部实现</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;</span>(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</div><div class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</div><div class="line">    <span class="comment">// final field is required to enable safe publication of constructed instance</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</div><div class="line">        <span class="keyword">get</span>() &#123;</div><div class="line">            <span class="keyword">val</span> _v1 = _value</div><div class="line">            <span class="comment">//判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑</span></div><div class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></div><div class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</div><div class="line">                <span class="keyword">val</span> _v2 = _value</div><div class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                    <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span> (_v2 <span class="keyword">as</span> T)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">val</span> typedValue = initializer!!()<span class="comment">//调用高级函数获取其返回值</span></div><div class="line">                    _value = typedValue   <span class="comment">//将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值</span></div><div class="line">                    initializer = <span class="literal">null</span></div><div class="line">                    typedValue  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。</p><p>到里这里其实大家还是肯定有疑问，我这里<strong>只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢？</strong>。这里又涉及到了<strong>委托属性</strong>。</p><p>委托属性语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。</p><p>而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@kotlin.internal.InlineOnly</div><div class="line">//返回初始化的值。</div><div class="line">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value</div></pre></td></tr></table></figure><h1 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h1><p>这种方法也是《Effective Java》上所推荐的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种写法仍然使用JVM本身机制保证了线程安全的问题。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，<strong>第一次调用getInstance()时将内部类SingletonHodler</strong>，在该内部类中定义了一个static类型的变量INSTANCE，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于SingletonHodler是私有的，除了getInstance()之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">val</span> instance = SingletonHolder.holder</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">object</span> SingletonHolder &#123;</div><div class="line">        <span class="keyword">val</span> holder= Singleton()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="枚举式：Enum"><a href="#枚举式：Enum" class="headerlink" title="枚举式：Enum"></a>枚举式：Enum</h1><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">EasySingleton</span></span>&#123;</div><div class="line">INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b9b7aa8c2779e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
      <category term="Kotlin" scheme="https://edward7zhang.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>记一次呆若木鸡的面试</title>
    <link href="https://edward7zhang.github.io/2018/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%91%86%E8%8B%A5%E6%9C%A8%E9%B8%A1%E7%9A%84%E9%9D%A2%E8%AF%95/"/>
    <id>https://edward7zhang.github.io/2018/04/24/记一次呆若木鸡的面试/</id>
    <published>2018-04-24T14:24:14.000Z</published>
    <updated>2018-04-24T14:52:45.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一道很简单很简单的入门题…核心就是一个我高中就学过的数学知识…叉积…可惜年久不用…在面试的紧要关头就显得呆若木鸡…很遗憾没有表现出自己的真实水平…</p></blockquote><pre><code>/* ** 在一个平面中.任意一个直线线段可以由2个点表示,任意一个点可以由X,Y坐标值表示.*例如线段 J 由 点A(x1, y1), B(x2, y2)表示. 其中坐标值 x,y 都为int. *求写出一个方法, boolean checkIntersect(Line J, Line K); *检查在平面中给出的2个线段是否相交, return true 代表线段相交, false 为不想交. *请自行定义线段Line的数据结构, 并可以假设传入参数Line J 和 Line K 为有效输入. */</code></pre><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aiqyInterview;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckIntersect</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> EdwardZhang</div><div class="line"> * 判断线段相交：</div><div class="line"> * 两个线段的交点个数可能有0个 1个或者无数个</div><div class="line"> * 判断两个线段相交，可以按照如下步骤：</div><div class="line"> * 判断A点B点是否在线段CD的两侧，即计算叉积时异号</div><div class="line"> * 判断C点和D点是否在线段AB的两侧，即计算叉积时异号</div><div class="line"> * 然后在处理特殊情况，即ABCD四个点有至少三个点共线的情况，</div><div class="line"> * 即出现叉积为零的情况，如果A点与线段CD共线，</div><div class="line"> * 则要查看A点是否在线段CD上，其它情况依次类推。</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.x = x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</div><div class="line">Point A = <span class="keyword">new</span> Point();</div><div class="line">Point B = <span class="keyword">new</span> Point();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">getA</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> A;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">A.x = i;</div><div class="line">A.y = j;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">getB</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">B.x = i;</div><div class="line">B.y = j;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">direct</span><span class="params">(Point i, Point j, Point k)</span> </span>&#123; <span class="comment">// 计算叉积</span></div><div class="line"><span class="keyword">return</span> (k.x - i.x) * (j.y - i.y) - (j.x - i.x) * (k.y - i.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onSegment</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="comment">// 共线时，判断点是否落在线段</span></div><div class="line"><span class="keyword">float</span> minx = Math.min(a.x, b.x);</div><div class="line"><span class="keyword">float</span> maxx = Math.max(a.x, b.x);</div><div class="line"><span class="keyword">float</span> miny = Math.min(a.y, b.y);</div><div class="line"><span class="keyword">float</span> maxy = Math.max(a.y, b.y);</div><div class="line"><span class="keyword">if</span> (c.x &gt;= minx &amp;&amp; c.x &lt;= maxx &amp;&amp; c.y &gt;= miny &amp;&amp; c.y &lt;= maxy) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkIntersect</span><span class="params">(Line X, Line Y)</span> </span>&#123;</div><div class="line"><span class="keyword">float</span> d1 = direct(Y.A, Y.B, X.A);</div><div class="line"><span class="keyword">float</span> d2 = direct(Y.A, Y.B, X.B);</div><div class="line"><span class="keyword">float</span> d3 = direct(X.A, X.B, Y.A);</div><div class="line"><span class="keyword">float</span> d4 = direct(X.A, X.B, Y.B);</div><div class="line"><span class="keyword">if</span> (d1 * d2 &lt; <span class="number">0</span> &amp;&amp; d3 * d4 &lt; <span class="number">0</span>)</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d1 == <span class="number">0</span> &amp;&amp; onSegment(Y.A, Y.B, X.A))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; onSegment(Y.A, Y.B, X.B))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d3 == <span class="number">0</span> &amp;&amp; onSegment(X.A, X.B, Y.A))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d4 == <span class="number">0</span> &amp;&amp; onSegment(X.A, X.B, Y.B))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">CheckIntersect checkIntersect = <span class="keyword">new</span> CheckIntersect();</div><div class="line">Line a = checkIntersect.new Line();</div><div class="line">Line b = checkIntersect.new Line();</div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//相交 true</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//相离 false</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">4</span>, <span class="number">2</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//平行 false</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">b.setB(<span class="number">3</span>, <span class="number">3</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//在一条直线上 true</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一道很简单很简单的入门题…核心就是一个我高中就学过的数学知识…叉积…可惜年久不用…在面试的紧要关头就显得呆若木鸡…很遗憾没有表现出自己的真实水平…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;/* *

* 在一个平面中.任意一个
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>计算机系应届生求职指北</title>
    <link href="https://edward7zhang.github.io/2018/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%BA%94%E5%B1%8A%E7%94%9F%E6%B1%82%E8%81%8C%E6%8C%87%E5%8C%97/"/>
    <id>https://edward7zhang.github.io/2018/04/19/计算机系应届生求职指北/</id>
    <published>2018-04-19T01:07:14.000Z</published>
    <updated>2018-04-19T05:18:21.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天早晨看到了Easy大大的这篇文章，在文章中读到了自己的影子，并且也明白了这段时间自己在实习招聘中的不足，受益匪浅。希望我的好友可以看到从中受益<br>特此转载 From：<a href="https://github.com/easychen/career-guide-for-cs-graduate" target="_blank" rel="external">https://github.com/easychen/career-guide-for-cs-graduate</a></p></blockquote><h1 id="计算机系应届生求职指北"><a href="#计算机系应届生求职指北" class="headerlink" title="计算机系应届生求职指北"></a>计算机系应届生求职指北</h1><p>最近帮了一个朋友的朋友做了下职业规划，结合之前在微博上的一些问答，觉得不少应届生同学对求职有蛮多误解的，所以这里分享下我的一点经验吧。虽然本文题为指北，但只是一个面向对行业、对业界技术不熟悉的同学的操作手册。各位技术大牛可能觉得粗浅，请见谅。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh5iysqx1j20qy0f50xb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p>本文略长，会谈及以下问题。</p><ul><li>职业规划越早越好</li><li>一定要珍惜校招的机会窗口</li><li>应届生的求职策略</li><li>技术职位的选择</li><li>语言和技术栈的选择</li><li>技术栈的优化</li><li>简历的书写</li></ul><p>下边我们一点一点来讲。</p><blockquote><p>本文作者 @Easy （ <a href="http://weibo.com/easy" target="_blank" rel="external">weibo.com/easy</a> ），方糖全栈课（ <a href="http://quanzhanke.com" target="_blank" rel="external">quanzhanke.com</a> ）主讲人，有多年大规模网站、云平台开发经验、曾运营过用户数十万的程序员拍卖平台，为上千名程序员找过工作。转载请保留以上作者信息和链接，谢谢。</p></blockquote><p>内容更新通知</p><p>可微信扫码（未关注直接关注）订阅本指北更新。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh6g6fiauj20by0byq3p.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <h2 id="职业规划越早越好"><a href="#职业规划越早越好" class="headerlink" title="职业规划越早越好"></a>职业规划越早越好</h2><p>职业是一个非常特殊的东西，它有两点很特别，一个是「不可重来」，另一个是「验证耗时」。之前和一个老友聊天，他感叹说，回过头看看，自己的整个职业过得乱七八糟。等到现在明白这点的时候，已经来不及了。因为一般一段职业经历短则一到两年，长则三到五年。换两家公司，十年一晃就过去了。如果你在这十年中没有很好的成长，又不幸身在某些公司，那三十多岁可能就面临被清退的处境了。</p><p>我一般不屑于去和别人分享什么人生经验，毕竟有些坑不自己跳下去是不会牢记在心的。但职业的坑不一样，等你发现在坑里时，可能已经晚了。所以我花了蛮多时间来研究这个。有兴趣的同学可以去读读我的《程序员跳槽全攻略》，专门讲职业规划的。( 在我的个人网站上可以免费读 <a href="http://t.cn/RYh1xhS" target="_blank" rel="external">方糖气球🎈|程序员跳槽全攻略</a> ) </p><h2 id="一定要珍惜校招的机会窗口"><a href="#一定要珍惜校招的机会窗口" class="headerlink" title="一定要珍惜校招的机会窗口"></a>一定要珍惜校招的机会窗口</h2><p>我大学的语文老师曾告诫我们说，人生就像四季一样，春天该播种，你去播种，秋天该收获，你去收获，这样是最省力的。你非要倒过来呢，也不是不行，但就是会很累，会付出更多的精力和代价。</p><p>校招也类似，它是社会和企业为从未步入职场的同学特意准备的一个绿色通道。在这个通道里，我们将候选人当做一张白纸，可以没有经验、没有行业常识，只要对工作充满热情、有还算聪明的头脑，基本都算是合格的。企业会为这些同学准备培训，并留足适应期，有的甚至还会安排一对一的老员工来带。</p><p>但是，一旦你错过了它，那一切都不一样了，因为你进入了名为「社招」的红海。在这里，所有已经毕业的人变成了你的竞争对手，不但要面对和你一样工作年限的人竞争，还要面对其他工作时间更长、经验更丰富的同行跳槽带来的竞争。甚至经常发生因为招到了一个中级岗位的候选人，取消掉两个初级岗位的情况。</p><p>所以校招非常重要，一定不要错过。</p><h2 id="应届生的求职策略"><a href="#应届生的求职策略" class="headerlink" title="应届生的求职策略"></a>应届生的求职策略</h2><p>既然校招这么重要，那么我们怎么才能在其中占据优势呢？记住两个词「择优录取」和「跑赢同学」。</p><h3 id="择优录取"><a href="#择优录取" class="headerlink" title="择优录取"></a>择优录取</h3><p>在微博上经常可以看到这样的问题：「我这个也会、那个也合格，凭什么他们就不招我呢？」这是典型的没有明白招聘本质的表现。要明白，求职不是「会考」而是「高考」，不是什么产品的出厂合格校验，而是一场中国这个资源紧缺型国家里的又一场优质资源争夺战。</p><p>那些薪水高、发展空间好的知名企业（后文简称大厂），每年招聘的人数是一定的。极端点说，如果现在所有候选人的水平都下调20%，他们依然要招人的，不然没法发展（严格讲会有一些调整空间，但也扛不了多久）。</p><p>所以，尤其是在校招里边，「绝对值」并不重要，「相对值」才是最重要的。</p><h3 id="跑赢同学"><a href="#跑赢同学" class="headerlink" title="跑赢同学"></a>跑赢同学</h3><p>我来讲一个很老的童话，听过的同学请装作没听过。两个人在森林里边遇到了熊🐻，kuma 看见他们就嗷嗷的追了过来。一个同学转身就跑，另一个问他说，我们怎么跑也跑不过熊的，那跑有什么用呢？这个同学回答说，我只要跑赢你就好了呀。</p><p>那其实校招也是一样的。它不是说你的能力要有多少，其实再牛的应届生的水平放到行业里边，都是不入流的，因为很多水平是靠海量的用户压出来的，你没有遇到过这些场景，怎么可能知道怎么去应对。</p><p>所以应届生和那些社招的候选人比，通常都是没啥胜算的，但幸运的是，我们和他们是不同的赛道。要跑赢一个在大厂核心岗位工作了一两年的人不容易，但要跑赢那些和你一样在大学只学了一堆理论基础，甚至理论课都没好好学天天在寝室吃鸡的同学，就容易很多了。</p><p>要承认，即使这样，要跑赢某些天资聪颖、能力拔群的学霸还是有难度的。但这场比赛是不公平的，因为它没规定每个人必须同时开始跑。鲁迅说得好，笨鸟先飞。（鲁迅：我没有说过）如果我们能更早的认识到这点，花更多时间去准备，那么赢的概率就会成倍提升。</p><p>我本身就是一个非常好的例子。严格的讲，我的能力算是平庸偏上一点点的，虽然在当时无论如何我都不会承认。当我在大一下半期认识到这一点时，就开始自学 PHP，大二的时候写了一堆没人用的开源项目，大三上半期找了家公司做兼职，已经能把学费挣回来了。当大三下半期开始找实习时，我的简历已经可以秒杀同校同学，小小PK 一流高校的同学了。</p><p>所以你以为校招比的是能力，其实对于执行力中等、同样天赋的同学来讲，校招比的其实是认知。越早认识到本质的人，就越容易在这场游戏里边胜出。从这个角度讲，坚持读到这里的你，甚至可能已经赢了一半了。所以记得要把这篇文章分享给你的好朋友，然后千万别让你不喜欢的同学知道。</p><h2 id="技术岗位的选择"><a href="#技术岗位的选择" class="headerlink" title="技术岗位的选择"></a>技术岗位的选择</h2><p>技术岗位的大体分布如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nht0kdj20vn0hhmz8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在几乎所有的软件都已经互联网化了，就算没有互联网化的，它以后也会互联网化，所以我们就不单纯地去说软件开发这个行业了。</p><h4 id="开发岗"><a href="#开发岗" class="headerlink" title="开发岗"></a>开发岗</h4><p>首先就是开发岗，这个就包括了前端开发、后端开发和移动开发。</p><p>前端开发和后端开发，主要是 B/S 结构里的。B/S 结构就是 Browser-Server 结构。而前端指的就是浏览器这个端；后端指的就是服务器这个端。</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>前端主要做的事情，就是把从服务器端读取到的数据展现给用户，然后通过各种 UI 控件和用户互动，再将新的数据送回服务器端。具体的技术包括 HTML、CSS、JavaScript，还可能有一些嵌入浏览器运行的组件，比如 Flash 、 WebGL 。</p><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>后端则主要送数据给前端，一般有两种方式，以前用的比较多的是，将数据在服务器端先渲染完，然后将输出的结果发送给前端；现在用的比较多的方式是将纯数据通过 Json 或者 xml 等格式发送给前端，在浏览器中通过 JS 来进行渲染。</p><p>所以以前很多后端的工程师往往也懂一些前端的知识，比如我认识的很多 PHP 程序员，他们不但懂 MySQL 和 Apache，还懂 HTML 、 CSS 、 JS 和 PS。这种前后端都懂的工程师，也叫全栈工程师。</p><p>后端可以用各种语言开发，国内用的比较多的包括 Java、PHP ，还有相对小众一些的 Python 、 Ruby 、 Go。其实 C 也是可以写后端的，不过现在已经很少有公司直接用它写了。</p><p>后来有了 NodeJS ，JavaScript 也能跑到后端了，所以很多前端工程师也有了后端开发的能力，他们也占了全栈工程师的很大一部分。</p><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>相对于 B/S 结构，还有 C/S 结构，就是 Client-Server 。C/S 结构下不用浏览器来展现数据和交互，而是用客户端，一般是 Mac/Win/Linux 三大平台。</p><h5 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h5><p>手机大潮起来以后，不管是 B/S 结构还是 C/S 结构，全部移动化了。B/S 结构对应的就是适配手机浏览器的移动网页、以及嵌入在微信、微博里边的 H5 页面; C/S 结构就是 APP ，一般覆盖 iOS 和 Android 两个主流平台。</p><p>除了这些标准开发岗，而还有一些新兴或者相对小众的开发方向，比如人工智能/算法工程师、做智能硬件的硬件开发工程师、给企业做解决方案的企业软件工程师。</p><h4 id="其他岗位"><a href="#其他岗位" class="headerlink" title="其他岗位"></a>其他岗位</h4><p>软件并不是开发出来就完了的，在上线或者发布之前，我们还需要「测试工程师」来进行测试；而上线以后，还需要「运维工程师」来管理和优化服务器集群。现在服务器都虚拟化和容器化了，运维工程师中也出现了懂开发的分支，叫做 DevOps。</p><h4 id="中高级岗位"><a href="#中高级岗位" class="headerlink" title="中高级岗位"></a>中高级岗位</h4><p>不管是开发岗还是测试、运维岗，都有其对应的中高级岗位。开发一般是技术经理；运维一般是架构师；测试一般是测试总监。技术总监、CTO 就是更高一级的职位了。</p><p>以上的职位分类我们参考了招聘网站的分类，不一定准确，可能会有很多岗位没覆盖到，不少公司也会有自己独特的岗位设置。</p><h3 id="职位的选择"><a href="#职位的选择" class="headerlink" title="职位的选择"></a>职位的选择</h3><p>如果能选择的话，不建议一开始就选运维或者测试。原因有两个：第一，因为它们虽然很重要，但不是软件开发的核心岗位。第二，从开发岗往这两个职位转非常容易，反之却非常难。</p><p>之前在给掘金写《程序员职业小白书》的时候，我做过一个邮件访谈，以问题的形式采访了多位在不同阶段、不同岗位、不同城市的程序员的日常。大家可以读一读，了解下。<a href="https://juejin.im/book/59e17a7ff265da430629cc4e/section/59faea95f265da430d575a22" target="_blank" rel="external">程序员们的日常是怎样的</a> （虽然这个小册是收费的，但访谈这一章却是可以免费读的，不需要购买哈）</p><h2 id="语言和技术栈的选择"><a href="#语言和技术栈的选择" class="headerlink" title="语言和技术栈的选择"></a>语言和技术栈的选择</h2><h3 id="语言概况"><a href="#语言概况" class="headerlink" title="语言概况"></a>语言概况</h3><p>虽然出于某种政治正确，我们一般都会说，语言不重要。但语言真的不重要么？并不是这样的，每种语言都有自己的优缺点和适用范围。</p><p>像日语和英语一样，一个是看动画玩游戏用的，一个是看资料写代码用的。（误）<br>下边简单介绍下我眼中的各个语言。</p><h4 id="C-C-："><a href="#C-C-：" class="headerlink" title="C/C++ ："></a>C/C++ ：</h4><p>系统语言，用来写底层操作系统、高性能中间件和嵌入式开发。</p><h4 id="Python：人工智能的好选择"><a href="#Python：人工智能的好选择" class="headerlink" title="Python：人工智能的好选择"></a>Python：人工智能的好选择</h4><p>举例来说，如果你想做人工智能方向的话，Python语言就是非常不错的选择。因为它在各个大学和研究机构用的非常多，有成熟好用的数学库，适合于科学计算。在深度学习等热门方向上，有大量用 Python 开发的框架，新出的 Paper 也能很快在 GitHub 上找到 Python 的代码实现，可以说是不二选择了。</p><h4 id="JavaScript：前端和全端"><a href="#JavaScript：前端和全端" class="headerlink" title="JavaScript：前端和全端"></a>JavaScript：前端和全端</h4><p>如果你想做前端，那么目前来看，除了 JavaScript 还真没有别的选择，因为现在能在浏览器里边跑起来，也就是它了。过两年等 wasm 成熟可能会有其他选择，但现在，是真没有。</p><p>而相应的，如果你学会了 JavaScript ，想在这个基础上再把后端给做了，那么 Node.JS 就是非常好的选择。因为它使用的就是 JavaScript 的解释器，按 JavaScript 写就好了。从学习成本上来讲，它是非常低的，可以通过很低的投入，就进入了服务器端的领域。</p><h4 id="PHP：依然是网站首选"><a href="#PHP：依然是网站首选" class="headerlink" title="PHP：依然是网站首选"></a>PHP：依然是网站首选</h4><p>如果你要做网站，那么 PHP 就是首选了。一方面是有大量的可用代码，世界上超过80%的网站都用的 PHP，基本上你能想到的网站功能，都有能找到的实现，悬念只是有没有免费的；另一方面，PHP7 的性能提升了很多，用来写 API 也非常好。</p><p>另外一点，就是目前使用 PHP 的团队非常多，即使在二三线城市也比较容易找到工作，当然，组建团队也同样相对容易。</p><h4 id="Java：大数据分析"><a href="#Java：大数据分析" class="headerlink" title="Java：大数据分析"></a>Java：大数据分析</h4><p>如果你要做大数据分析，那么可能就离不开 Java 了。<br>从 Hadoop 开始一系列的 Google Big Table 的开源实现都是 Java 的，用于海量数据搜索的 Elastic Stack 也是 Java 的。</p><h4 id="Go：云计算和容器管理"><a href="#Go：云计算和容器管理" class="headerlink" title="Go：云计算和容器管理"></a>Go：云计算和容器管理</h4><p>如果你现在要想去做云计算，那 Go 就是一个非常好的选择。</p><p>因为它就是为了大规模计算设计的，并发管理和性能都非常不错。而且有很多云计算的软件，它就是 Go 写的，如果你要去修改它，调整里边的实现逻辑的话，不会 Go 可能很麻烦。当然，理论上讲，你也可以通过容器和微服务的方式来搞定，但肯定比直接改代码麻烦。</p><p>另外区块链的大热平台以太坊的官方（最具潜力）实现，也是Go做的。钱途大大的。</p><h3 id="语言的选择"><a href="#语言的选择" class="headerlink" title="语言的选择"></a>语言的选择</h3><h4 id="兴趣优先"><a href="#兴趣优先" class="headerlink" title="兴趣优先"></a>兴趣优先</h4><p>在语言的选择上，尤其是第一门语言的选择上，我一直推荐兴趣优先的原则。因为对初学者而言，当你遇到困难坚持不下去时，兴趣会帮你一把。中学时为了改仙剑，我连汇编都试着学了个入门 🤣</p><h4 id="市场其次"><a href="#市场其次" class="headerlink" title="市场其次"></a>市场其次</h4><p>但其实对绝大部分应届生而言，对各种语言并没有特别的偏好。而且「找到工作」这件事是非常重要的。所以与其盲目的选择语言学习不如来看看各个语言在招聘市场的表现。</p><p>我之前写过一个脚本，可以抓取几个互联网招聘大站的招聘启事，并按职位对薪资进行统计。下边是最近一周的统计结果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nzwnz0j20qo5ubkjn.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>先来说说这些数据怎么看。</p><p>职位热度类似于招聘职位数，和其他语言对比就能看出差距。平均薪资之所有有两个值，是因为我们一般招聘时会给出薪资的上限和下限。严格的讲，这并不是当前某个语言的程序员们的薪资，而是他们下一次跳槽时的可能薪资。另外，部分企业喜欢在上限值上边虚高，所以把上限乘80%可能更合理。而下限一般比较真实，更具备对比价值。</p><p>然后我们来看看能发现什么。</p><h5 id="Java-的数据非常牛"><a href="#Java-的数据非常牛" class="headerlink" title="Java 的数据非常牛"></a>Java 的数据非常牛</h5><p>首先我们会发现，Java 的职位热度非常高，几乎在所有城市里边都是排名第一的。这里有一个特殊原因，就是 Android 职位基本也是使用 Java 语言进行开发的，所以这两个职位有一些重叠。也就是说，学好 Java 其实可以同时应聘 Java工程师 和 Android 工程师（可能需要额外在学一点点应用开发的知识），这非常划算。而从薪资方面看，Java 也是数一数二的。</p><h5 id="前端紧跟其后"><a href="#前端紧跟其后" class="headerlink" title="前端紧跟其后"></a>前端紧跟其后</h5><p>紧随其后的是前端职位。前端是个非常有意思的特点，那就是——几乎所有的公司都会招前端。对比 Java 而言，可能有很多大厂的后端用的不是 Java ，那他们就不需要招聘 Java 工程师。如果你非常想去这家公司，但你会的语言是 Java ，那么就可能和机会擦肩而过。而前端岗位的话，机会就可能大得多。这有点像血型里边的O型血，怎么地方都能用。就算是自以为站在食物链顶端鄙视「古典互联网」的区块链公司也不得不招前端呢，也是一个非常好的选择。</p><p>除了看热度，我们也要考虑到竞争，比如 Java 是一个「传统」岗，很多软件行业的工程师也是会 Java 的。而「前端」是一个新兴的互联网岗，专业前端还不算太多（和 Java 比啦），所以入职难度说不定反而低一些。</p><h5 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h5><p>其他语言在各个城市的数据各不相同，大家可以挑自己感兴趣的看。比如 Go 语言在北京比其他城市热几倍；区块链虽然看起来很火，但其实职位数也就比 PHP 的一半多点；Ruby 虽然薪资不错，但岗位非常少…</p><p>总之语言的选择因人而异因时而异，请综合各种视角去选择一个适合自己的。</p><h3 id="学习路线图"><a href="#学习路线图" class="headerlink" title="学习路线图"></a>学习路线图</h3><p>在选择好职位和语言后，就要寻找对应的学习路线图进行学习了。这里推荐这个 Star 数量超过4万的路线图（的中文版）：<a href="https://github.com/goodjack/developer-roadmap-chinese" target="_blank" rel="external">GitHub - goodjack/developer-roadmap-chinese: 2018 年成為 Web 開發人員的路線圖</a></p><p>虽然不是很全，但细节不错。</p><ul><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nk3d0ej214d2xc4qp.jpg" target="_blank" rel="external">前端路线图</a> </li><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nlxc7hj210u2sc4qp.jpg" target="_blank" rel="external">后端路线图</a></li><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nj63kgj215i1bpduw.jpg" target="_blank" rel="external">DevOPs路线图</a></li></ul><h2 id="技术栈的优化"><a href="#技术栈的优化" class="headerlink" title="技术栈的优化"></a>技术栈的优化</h2><p>之前我们在分析 Java 数据的时候，发现一个有意思的问题，那就是 Java 的技术栈可以同时覆盖两个热门职位 —— Java 和 Android，这让我们的求职竞争力一下翻了一倍。那么在其他的语言和岗位上还存不存在类似的情况呢？</p><p>其实是有的，比如前端岗位就是一个非常有潜力的例子，它的后端解决方案 NodeJS 正在日益流行 。在我写这篇文章的时候，互联网招聘大站 拉勾网 上北京的 NodeJS 职位数是 181，上海是 114，深圳是 65 。所以学完前端知识再补一下 NodeJS 的收益是不错的。</p><p>但这个技术栈其实还可以进一步优化，因为一个偶然的原因，我统计了一下 PHP 岗位和前端岗位招聘启事里边出现的技术关键词，发现其重合度竟然高于60%。具体的技术关键词和热度见这里 <a href="https://quanzhanke.github.io/ref/MAP.html" target="_blank" rel="external">《PHP&amp;前端岗（1~3年）核心技术点分析报告》</a></p><p>回头一想其实也很好理解，毕竟招 PHP 是来做网站的，HTML CSS JS 总得会一些才行。这意味着PHP的同学只需要补上部分前端知识，比如主流框架 React / Vue / Angular 和 SPA 开发就可以同时应聘 PHP 和 前端 职位。</p><p>这会有多大的竞争力呢？前端招聘启事里边，有超过十分之一的企业提及了PHP。这还没完，React 有一个混合应用解决方案，叫做 React Native，可以直接用 React 栈来开发手机APP。这个技术的需求如何呢？现在拉勾网上北京的 React Native 相关职位数有 84 。</p><p>于是呢，我们可以选择 PHP + React + React Native 的技术栈，仅仅多学习一点知识，可以投递的岗位就从原来的 364 变成了 364 + 373 + 84 。 </p><p>这就是技术栈优化的策略。关于这个技术栈的优化结构，可以看这里 <a href="https://quanzhanke.github.io/0-0.html" target="_blank" rel="external">《方糖全栈学习路线图》</a>，这个栈还顺便把区块链应用开发也覆盖了。大家可以举一反三，去优化自己选中的技术栈。</p><h2 id="简历的写作"><a href="#简历的写作" class="headerlink" title="简历的写作"></a>简历的写作</h2><p>不要最后找工作的时候再来写简历。现在就开始写，即使你什么都不会。这样你才会真切的感受到，自己的缺点和劣势。然后通过不断的学习，往简历上追加新的内容，直到你自己看起来觉得有竞争力了，简历才算阶段性完成了。</p><p>关于简历的写作技巧和工具，我之前写过一篇文章详细说明，可以点这里阅读 <a href="https://juejin.im/book/59e17a7ff265da430629cc4e/section/59faec225188252abc5db42c" target="_blank" rel="external">《如何写出一份专业的技术简历》</a> （这篇文章本身依然是免费的，不用购买小册就能读）</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>( 由于V站上某些同学的疑惑，这里我也补充一下吧。学好基础知识是必须的，这是最基本的，如果这些地方你都丢分了，这些技巧就都白费了 )</p><p>( 刷题库是面试必须的，但只刷题库就舍本逐末了，实践驱动的学习会让你对基础的理解更深入，虽然辛苦点。顺便po一个题库网站 [nowcoder]<a href="https://www.nowcoder.com/" target="_blank" rel="external">https://www.nowcoder.com/</a>  )</p><p>不知不觉已经写了这么多了，其实还有一些内容想说，但暂时就不写到这里了。</p><p>等以后有空我再整理一个小册子吧。我把文章也同时发布到了 GitHub，以后的更新会通过 GitHub 进行，欢迎 watch 和 star 。<a href="https://github.com/easychen/career-guide-for-cs-graduate" target="_blank" rel="external">https://github.com/easychen/career-guide-for-cs-graduate</a></p><p>PS：如果你还不知道怎么用 GitHub，那么赶紧学学吧，这可是程序员的必备（<del>交友</del>）工具哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天早晨看到了Easy大大的这篇文章，在文章中读到了自己的影子，并且也明白了这段时间自己在实习招聘中的不足，受益匪浅。希望我的好友可以看到从中受益&lt;br&gt;特此转载 From：&lt;a href=&quot;https://github.com/easychen/
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/17/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/17/Android网络编程面试题集/</id>
    <published>2018-04-17T01:07:14.000Z</published>
    <updated>2018-04-17T01:39:28.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP与UDP有什么区别？"><a href="#TCP与UDP有什么区别？" class="headerlink" title="TCP与UDP有什么区别？"></a>TCP与UDP有什么区别？</h3><ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol><h3 id="简单介绍一下TCP三次握手与四次分手过程？"><a href="#简单介绍一下TCP三次握手与四次分手过程？" class="headerlink" title="简单介绍一下TCP三次握手与四次分手过程？"></a>简单介绍一下TCP三次握手与四次分手过程？</h3><p>TCP用<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#建立通路" target="_blank" rel="external">三次握手</a>（three-way handshake）过程创建一个连接，使用四次分手<br>关闭一个连接。</p><p>三次握手与四次分手的流程如下所示：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/practice/network/three_way_handshake.jpeg" width="500"></p><p>三次握手</p><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li></ul><p>四次分手</p><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><p>三次握手与四次分手也是个老生常谈的概念，举个简单的例子说明一下。</p><p>三次握手</p><blockquote><p>例如你小时候出去玩，经常玩忘了回家吃饭。你妈妈也经常过来喊你。如果你没有走远，在门口的小土堆上玩泥巴，你妈妈会喊：”小新，回家吃饭了”。你听到后会回应：”知道了，一会就回去”。妈妈听<br>到你的回应后又说：”快点回来，饭要凉了”。这样你妈妈和你就完成了三次握手的过程。😁说到这里你也可以理解三次握手的必要性，少了其中一个环节，另一方就会陷入等待之中。</p></blockquote><p>三次握手的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误.</p><p>四次分手</p><blockquote><p>例如偶像言情剧干净利落的分手，女主对男主说：我们分手吧🙄，男主说：分就分吧😰。女主说：你果然是不爱我了，你只知道让我多喝热水🙄。男主说：事到如今也没什么好说的了，祝你幸福🙃。四次分手完成。说到这里你可以理解<br>了四次分手的必要性，第一次是女方（客户端）提出分手，第二次是男主（服务端）同意女主分手，第三次是女主确定男主不再爱她，也同意男主分手。第四次两人彻底拜拜（断开连接）。</p></blockquote><p>因为TCP是全双工模式，所以四次分手的目的就是为了可靠地关闭连接。</p><h3 id="TCP如何保证数据传输的可靠性？"><a href="#TCP如何保证数据传输的可靠性？" class="headerlink" title="TCP如何保证数据传输的可靠性？"></a>TCP如何保证数据传输的可靠性？</h3><ol><li>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。</li><li>数据校验。</li><li>数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。</li><li>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。</li><li>拥塞控制：当网络发生拥塞时，减少数据的发送。</li></ol><h3 id="HTTP与HTTPS有什么区别？"><a href="#HTTP与HTTPS有什么区别？" class="headerlink" title="HTTP与HTTPS有什么区别？"></a>HTTP与HTTPS有什么区别？</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">HTTPS</a>是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份<br>认证，保护交换数据的隐私与完整性。</p></blockquote><p>如下图所示，可以很明显的看出两个的区别：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/practice/network/http_https.png" width="500"></p><p>注：TLS是SSL的升级替代版，具体发展历史可以参考<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="external">传输层安全性协议</a>。</p><p>HTTP与HTTPS在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来：</p><ul><li>如果URL的协议是HTTP，则客户端会打开一条到服务端端口80（默认）的连接，并向其发送老的HTTP请求。</li><li>如果URL的协议是HTTPS，则客户端会打开一条到服务端端口443（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的<br>HTTP请求。</li></ul><p>所以你可以看到，HTTPS比HTTP多了一层与SSL的连接，这也就是客户端与服务端SSL握手的过程，整个过程主要完成以下工作：</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证</li><li>生成临时的会话密钥，以便加密信道。</li></ul><p>SSL握手是一个相对比较复杂的过程，更多关于SSL握手的过程细节可以参考<a href="https://www.wosign.com/faq/faq2016-0309-04.htm" target="_blank" rel="external">TLS/SSL握手过程</a></p><p>SSL/TSL的常见开源实现是OpenSSL，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。<br>更多源于OpenSSL的技术细节可以参考<a href="https://www.openssl.org/" target="_blank" rel="external">OpenSSL</a>。</p><h3 id="谈一谈对HTTP缓存的理解？"><a href="#谈一谈对HTTP缓存的理解？" class="headerlink" title="谈一谈对HTTP缓存的理解？"></a>谈一谈对HTTP缓存的理解？</h3><p>HTTP的缓存机制也是依赖于请求和响应header里的参数类实现的，最终响应式从缓存中去，还是从服务端重新拉取，HTTP的缓存机制的流程如下所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/android-open-framwork-analysis/raw/master/art/okhttp/http_cache_structure.png" width="600"></p><p>HTTP的缓存可以分为两种：</p><ul><li>强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。</li><li>对比缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存<br>标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。</li></ul><p>强制缓存优先于对比缓存。</p><p>上面提到强制缓存使用的的两个标识：</p><ul><li>Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。</li><li>Cache-Control：Expires有个时间校验的问题，所有HTTP1.1采用Cache-Control替代Expires。</li></ul><p>Cache-Control的取值有以下几种：</p><ul><li>private:             客户端可以缓存。</li><li>public:              客户端和代理服务器都可缓存。</li><li>max-age=xxx:   缓存的内容将在 xxx 秒后失效</li><li>no-cache:          需要使用对比缓存来验证缓存数据。</li><li>no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发。</li></ul><p>我们再来看看对比缓存的两个标识：</p><p><strong>Last-Modified/If-Modified-Since</strong></p><p>Last-Modified 表示资源上次修改的时间。</p><p>当客户端发送第一次请求时，服务端返回资源上次修改的时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Last-Modified: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div></pre></td></tr></table></figure><p>客户端再次发送，会在header里携带If-Modified-Since。将上次服务端返回的资源时间上传给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-Modified-Since: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div></pre></td></tr></table></figure><p>服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改，<br>则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存。</p><p>上面是一种时间戳标记资源是否修改的方法，还有一种资源标识码ETag的方式来标记是否修改，如果标识码发生改变，则说明资源已经被修改，ETag优先级高于Last-Modified。</p><p><strong>Etag/If-None-Match</strong></p><p>ETag是资源文件的一种标识码，当客户端发送第一次请求时，服务端会返回当前资源的标识码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ETag: <span class="string">"5694c7ef-24dc"</span></div></pre></td></tr></table></figure><p>客户端再次发送，会在header里携带上次服务端返回的资源标识码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-None-Match:<span class="string">"5694c7ef-24dc"</span></div></pre></td></tr></table></figure><p>服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较，如果不同，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回<br>304，客户端可以继续使用缓存。</p><h3 id="HTTPS是如何保证安全的，证书如何校验？"><a href="#HTTPS是如何保证安全的，证书如何校验？" class="headerlink" title="HTTPS是如何保证安全的，证书如何校验？"></a>HTTPS是如何保证安全的，证书如何校验？</h3><h3 id="HTTP如何实现长连接？"><a href="#HTTP如何实现长连接？" class="headerlink" title="HTTP如何实现长连接？"></a>HTTP如何实现长连接？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议复习</title>
    <link href="https://edward7zhang.github.io/2018/04/16/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://edward7zhang.github.io/2018/04/16/HTTP协议/</id>
    <published>2018-04-16T02:43:13.000Z</published>
    <updated>2018-04-16T13:58:56.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>奇迹般的腾讯笔试通过了，昨天下午经过了一面…发现之前着眼于Android与Java的知识而没有对计算机网络系统的复习…导致了这次面试的滑铁卢…所以想进这样的一线大厂做一名合格的程序员还是要全面发展…不能顾此失彼</p></blockquote><h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h1><hr><ul><li>默认端口：80</li></ul><h2 id="Http协议的主要特点"><a href="#Http协议的主要特点" class="headerlink" title="Http协议的主要特点"></a>Http协议的主要特点</h2><hr><ol><li>支持客户／服务器模式</li><li>简单快速：客户向服务端请求服务时，只需传送请求方式和路径。</li><li>灵活：允许传输任意类型的数据对象。由Content-Type加以标记。</li><li>无连接：每次响应一个请求，响应完成以后就断开连接。</li><li>无状态：服务器不保存浏览器的任何信息。每次提交的请求之间没有关联。</li></ol><h3 id="非持续性和持续性"><a href="#非持续性和持续性" class="headerlink" title="非持续性和持续性"></a>非持续性和持续性</h3><hr><ul><li>HTTP1.0默认非持续性；HTTP1.1默认持续性</li></ul><h4 id="持续性"><a href="#持续性" class="headerlink" title="持续性"></a>持续性</h4><p>浏览器和服务器建立TCP连接后，可以请求多个对象</p><h4 id="非持续性"><a href="#非持续性" class="headerlink" title="非持续性"></a>非持续性</h4><p>浏览器和服务器建立TCP连接后，只能请求一个对象</p><h3 id="非流水线和流水线"><a href="#非流水线和流水线" class="headerlink" title="非流水线和流水线"></a>非流水线和流水线</h3><hr><p>类似于组成里面的流水操作</p><ul><li>流水线：不必等到收到服务器的回应就发送下一个报文。</li><li>非流水线：发出一个报文，等到响应，再发下一个报文。类似TCP。</li></ul><h4 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h4><table><thead><tr><th>Post一般用于更新或者添加资源信息</th><th style="text-align:center">Get一般用于查询操作，而且应该是安全和幂等的</th></tr></thead><tbody><tr><td>Post更加安全</td><td style="text-align:center">Get会把请求的信息放到URL的后面</td></tr><tr><td>Post传输量一般无大小限制</td><td style="text-align:center">Get不能大于2KB</td></tr><tr><td>Post执行效率低</td><td style="text-align:center">Get执行效率略高</td></tr></tbody></table><h4 id="为什么POST效率低，Get效率高"><a href="#为什么POST效率低，Get效率高" class="headerlink" title="为什么POST效率低，Get效率高"></a>为什么POST效率低，Get效率高</h4><hr><ul><li>Get将参数拼成URL,放到header消息头里传递</li><li>Post直接以键值对的形式放到消息体中传递。</li><li>但两者的效率差距很小很小</li></ul><h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><hr><ul><li>端口号是443</li><li>是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议。</li></ul><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><hr><h3 id="使用TCP"><a href="#使用TCP" class="headerlink" title="使用TCP"></a>使用TCP</h3><hr><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Socket socket = new Socket(&quot;ip&quot;, 端口);</div><div class="line"></div><div class="line">InputStream is = socket.getInputStream();</div><div class="line">DataInputStream dis = new DataInputStream(is);</div><div class="line"></div><div class="line">OutputStream os = socket.getOutputStream();</div><div class="line">DataInputStream dos = new DataOutputStream(os);</div></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServerSocket serverSocket = new ServerSocket(端口);</div><div class="line">Socket socket = serverSocket.accept();</div><div class="line">//获取流的方式与客户端一样</div></pre></td></tr></table></figure><p>读取输入流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">byte[] buffer = new byte[1024]; </div><div class="line">do&#123; </div><div class="line">int count = is.read(buffer); </div><div class="line">if(count &lt;= 0)&#123; break; &#125;</div><div class="line">else&#123; </div><div class="line">// 对buffer保存或者做些其他操作 </div><div class="line">&#125; </div><div class="line">&#125;</div><div class="line">while(true);</div></pre></td></tr></table></figure><h2 id="使用UDP"><a href="#使用UDP" class="headerlink" title="使用UDP"></a>使用UDP</h2><p>客户端和服务器端一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket = new DatagramSocket(端口);</div><div class="line">InetAddress serverAddress = InetAddress.getbyName(&quot;ip&quot;);</div><div class="line">//发送</div><div class="line">DatagramPackage packet = new DatagramPacket(buffer, length, host, port);</div><div class="line">socket.send(packet);</div><div class="line">//接收</div><div class="line">byte[] buf = new byte[1024];</div><div class="line">DatagramPacket packet = new DatagramPacket(buf, 1024);</div><div class="line">Socket.receive(packet);</div></pre></td></tr></table></figure><h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><hr><p><strong>面向报文的传输方式</strong>是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。<br><strong>面向字节流</strong>的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><hr><hr><ul><li>Transmission Control Protocol，传输控制协议</li><li>面向连接的协议</li><li>需要三次握手建立连接</li><li>需要四次挥手断开连接</li><li>TCP报头最小长度：20字节<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_131271823564Rx.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h3 id="三次握手的过程："><a href="#三次握手的过程：" class="headerlink" title="三次握手的过程："></a>三次握手的过程：</h3><hr><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20170104214009596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2h1c2xlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>客户端发送：SYN = 1, SEQ = X, 端口号</li><li>服务器回复：SYN = 1, ack = X + 1, SEQ = Y，ACK = 1</li><li>客户端发送：ack = Y + 1, SEQ = X + 1,ACK = 1</li></ol><ul><li>SYN – 建立连接位</li><li>ACK – 响应位</li><li>SEQ – 顺序号码</li><li><p>ack – 确认号</p><blockquote><p>确认应答信号ACK = 收到的SEQ + 1。<br>连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。</p></blockquote></li><li><p>第一次握手：主机A发送位码为SYN = 1，随机产生SEQ = 1234567的数据包到服务器，主机B由SYN = 1知道，A要建立联机</p></li><li>第二次握手：主机B收到请求后要确认联机信息，向A发送ACK = （主机A的SEQ+1），SYN = 1，ack = 1，随机产生SEQ = 3452671的包；</li><li>第三次握手：主机A收到后检查ack是否正确，即第一次发送的（SEQ+1），以及位码ACK是否为1，若正确，主机A会再发送ack = （主机B的SEQ+1），ACK = 1，主机B收到后确认SEQ值与ACK = 1则连接建立成功。</li></ul><h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><hr><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>A向B提出停止连接请求，FIN = 1</li><li>B收到，ACK = 1</li><li>B向A提出停止连接请求，FIN = 1</li><li>A收到，ACK = 1</li></ol><ul><li>FIN – 关闭连接</li><li>SYN – 建立连接位</li><li>ACK – 响应位</li><li>SEQ – 顺序号码</li><li>ack – 确认号<br><strong>优点：</strong> </li></ul><hr><ul><li>可靠，稳定<pre><code>1、传递数据前，会有三次握手建立连接2、传递数据时，有确认、窗口、重传、拥塞控制3、传递数据后，会断开连接节省系统资源</code></pre></li></ul><p><strong>缺点：</strong></p><hr><ul><li><p>传输慢，效率低，占用系统资源高<br>1、传递数据前，建立连接需要耗时<br>2、传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源</p></li><li><p>易被攻击<br>1、因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击</p></li></ul><p><strong>如何保证接收的顺序性：</strong></p><hr><p>TCP协议使用SEQ和ACK机制保证了顺序性<br>TCP的每个报文都是有序号的。确认应答信号ACK=收到的SEQ+1</p><p><strong>【注意】中断连接端可以是Client端，也可以是Server端。</strong></p><p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p>整个过程Client端所经历的状态如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_1312719804oSkK.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p>而Server端所经历的过程如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_1312719833030b.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p><strong>【注意】</strong> 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><hr><hr><ul><li>User Data Protocol，用户数据包协议</li><li>面向无连接的协议</li><li>UDP报头只有8字节</li></ul><p><strong>简介：</strong></p><hr><ul><li>传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上</li><li>在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制</li><li>在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段</li><li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息</li><li>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小</li><li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制</li><li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。</li><li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</li></ul><blockquote><p>使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p></blockquote><p><strong>优点：</strong></p><hr><ul><li><p>传输速率快<br>1、传输数据前，不需要像TCP一样建立连接<br>2、传输数据时，没有确认、窗口、重传、拥塞控制等机制</p></li><li><p>较安全<br>1、由于没有了TCP的一些机制，被攻击者利用的漏洞就少了</p></li></ul><p><strong>缺点：</strong></p><hr><ul><li>不可靠，不稳定<br>1、由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包</li></ul><p><strong>用UDP协议通讯时怎样得知目标机是否获得了数据包</strong></p><hr><p>仿造TCP的做法，每发一个UDP包，都在里面加一个SEQ序号，接收方收到包后，将SEQ序号回复给发送方。如果发送方在指定时间以内没有收到回应，说明丢包了。</p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><hr><table class="table table-bordered table-striped table-condensed"><br>    <tr><br>        <td>TCP面向<strong>有链接</strong>的通信服务</td><br>        <td>UDP面向<strong>无连接</strong>的通信服务</td><br>    </tr><br>    <tr><br>        <td>TCP提供可靠的通信传输</td><br>        <td>UDP不可靠,会丢包</td><br>    </tr><br>    <tr><br>        <td>TCP保证数据顺序</td><br>        <td>UDP不保证</td><br>    </tr><br>    <tr><br>        <td>TCP数据无边界</td><br>        <td>UDP有边界</td><br>    </tr><br>    <tr><br>        <td>TCP速度快</td><br>        <td>UDP速度慢</td><br>    </tr><br>    <tr><br>        <td>TCP面向字节流</td><br>        <td>UDP面向报文</td><br>    </tr><br>    <tr><br>        <td>TCP一对一</td><br>        <td>UDP可以一对一，一对多</td><br>    </tr><br>    <tr><br>        <td>TCP报头至少20字节</td><br>        <td>UDP报头8字节</td><br>    </tr><br>    <tr><br>        <td>TCP有流量控制，拥塞控制</td><br>        <td>UDP没有</td><br>    </tr><br></table><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>为什么UDP比TCP快</strong></p><hr><ol><li>TCP需要三次握手</li><li>TCP有拥塞控制，控制流量等机制</li></ol><p><strong>为什么TCP比UDP可靠</strong></p><hr><ol><li>TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。</li><li>TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有。因此可能丢包。</li></ol><p><strong>什么时候使用TCP</strong></p><hr><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>在日常生活中，常见使用TCP协议的应用如下：<br>浏览器，用的HTTP<br>FlashFXP，用的FTP<br>Outlook，用的POP、SMTP<br>Putty，用的Telnet、SSH<br>QQ文件传输</p><p><strong>什么时候应该使用UDP：</strong></p><hr><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。<br>比如，日常生活中，常见使用UDP协议的应用如下：<br>QQ语音<br>QQ视频<br>TFTP</p><p><strong>TCP无边界，UDP有边界</strong></p><hr><p><strong>TCP无边界</strong></p><p>客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的；</p><p><strong>UDP有边界</strong></p><p>客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。</p><p><strong>为什么连接的时候是三次握手，关闭的时候是四次握手？</strong></p><hr><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手</p><p><strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p><hr><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态是用来重发可能丢失的ACK报文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;奇迹般的腾讯笔试通过了，昨天下午经过了一面…发现之前着眼于Android与Java的知识而没有对计算机网络系统的复习…导致了这次面试的滑铁卢…所以想进这样的一线大厂做一名合格的程序员还是要全面发展…不能顾此失彼&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="Network" scheme="https://edward7zhang.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Android开源库面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/15/Android%E5%BC%80%E6%BA%90%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/15/Android开源库面试题集/</id>
    <published>2018-04-15T01:07:14.000Z</published>
    <updated>2018-04-17T01:45:26.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><h3 id="谈谈对Okhttp的理解？"><a href="#谈谈对Okhttp的理解？" class="headerlink" title="谈谈对Okhttp的理解？"></a>谈谈对Okhttp的理解？</h3><p>Volley与OkHttp的对比：</p><ul><li>Volley：支持HTTPS。缓存、异步请求，不支持同步请求。协议类型是Http/1.0, Http/1.1，网络传输使用的是    HttpUrlConnection/HttpClient，数据读写使用的IO。</li><li>OkHttp：支持HTTPS。缓存、异步请求、同步请求。协议类型是Http/1.0, Http/1.1, SPDY, Http/2.0, WebSocket，网络传输使用的是封装的Socket，数据读写使用的NIO（Okio）。</li></ul><blockquote><p>SPDY协议类似于HTTP，但旨在缩短网页的加载时间和提高安全性。SPDY协议通过压缩、多路复用和优先级来缩短加载时间。</p></blockquote><p>Okhttp的子系统层级结构图如下所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/android-open-framwork-analysis/raw/master/art/okhttp/okhttp_structure.png" width="600"></p><ul><li>网络配置层：利用Builder模式配置各种参数，例如：超时时间、拦截器等，这些参数都会由Okhttp分发给各个需要的子系统。</li><li>重定向层：负责重定向。</li><li>Header拼接层：负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应。</li><li>HTTP缓存层：负责读取缓存以及更新缓存。</li><li>连接层：连接层是一个比较复杂的层级，它实现了网络协议、内部的拦截器、安全性认证，连接与连接池等功能，但这一层还没有发起真正的连接，它只是做了连接器一些参数的处理。</li><li>数据响应层：负责从服务器读取响应的数据。</li></ul><p>在整个Okhttp的系统中，我们还要理解以下几个关键角色：</p><ul><li>OkHttpClient：通信的客户端，用来统一管理发起请求与解析响应。</li><li>Call：Call是一个接口，它是HTTP请求的抽象描述，具体实现类是RealCall，它由CallFactory创建。</li><li>Request：请求，封装请求的具体信息，例如：url、header等。</li><li>RequestBody：请求体，用来提交流、表单等请求信息。</li><li>Response：HTTP请求的响应，获取响应信息，例如：响应header等。</li><li>ResponseBody：HTTP请求的响应体，被读取一次以后就会关闭，所以我们重复调用responseBody.string()获取请求结果是会报错的。</li><li>Interceptor：Interceptor是请求拦截器，负责拦截并处理请求，它将网络请求、缓存、透明压缩等功能都统一起来，每个功能都是一个Interceptor，所有的Interceptor最<br>终连接成一个Interceptor.Chain。典型的责任链模式实现。</li><li>StreamAllocation：用来控制Connections与Streas的资源分配与释放。</li><li>RouteSelector：选择路线与自动重连。</li><li>RouteDatabase：记录连接失败的Route黑名单。</li></ul><h3 id="谈谈对Fresco理解？"><a href="#谈谈对Fresco理解？" class="headerlink" title="谈谈对Fresco理解？"></a>谈谈对Fresco理解？</h3><p>Fresco与Glide的对比：</p><ul><li>Glide：相对轻量级，用法简单优雅，支持Gif动态图，适合用在那些对图片依赖不大的App中。</li><li>Fresco：采用匿名共享内存来保存图片，也就是Native堆，有效的的避免了OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大的App中。</li></ul><p>Fresco的整体架构如下图所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/android-open-framwork-analysis/raw/master/art/fresco/fresco_structure.png" width="600"></p><ul><li>DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由负责。</li><li>DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。</li><li>DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。</li><li>DraweeHolder：统筹管理Hierarchy与DraweeHolder。</li><li>ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。</li><li>Producer/Consumer：Producer也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。</li><li>IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。</li></ul><p>纵观整个Fresco的架构，DraweeView是门面，和用户进行交互，DraweeHierarchy是视图层级，管理图层，DraweeController是控制器，管理数据。它们构成了整个Fresco框架的三驾马车。当然还有我们<br>幕后英雄Producer，所有的脏活累活都是它干的，最佳劳模👍</p><p>理解了Fresco整体的架构，我们还有了解在这套矿建里发挥重要作用的几个关键角色，如下所示：</p><ul><li>Supplier：提供一种特定类型的对象，Fresco里有很多以Supplier结尾的类都实现了这个接口。</li><li>SimpleDraweeView：这个我们就很熟悉了，它接收一个URL，然后调用Controller去加载图片。该类继承于GenericDraweeView，GenericDraweeView又继承于DraweeView，DraweeView是Fresco的顶层View类。</li><li>PipelineDraweeController：负责图片数据的获取与加载，它继承于AbstractDraweeController，由PipelineDraweeControllerBuilder构建而来。AbstractDraweeController实现了DraweeController接口，DraweeController<br>是Fresco的数据大管家，所以的图片数据的处理都是由它来完成的。</li><li>GenericDraweeHierarchy：负责SimpleDraweeView上的图层管理，由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角），该类由GenericDraweeHierarchyBuilder进行构建，该构建器<br>将placeholderImage、retryImage、failureImage、progressBarImage、background、overlays与pressedStateOverlay等<br>xml文件或者Java代码里设置的属性信息都传入GenericDraweeHierarchy中，由GenericDraweeHierarchy进行处理。</li><li>DraweeHolder：该类是一个Holder类，和SimpleDraweeView关联在一起，DraweeView是通过DraweeHolder来统一管理的。而DraweeHolder又是用来统一管理相关的Hierarchy与Controller</li><li>DataSource：类似于Java里的Futures，代表数据的来源，和Futures不同，它可以有多个result。</li><li>DataSubscriber：接收DataSource返回的结果。</li><li>ImagePipeline：用来调取获取图片的接口。</li><li>Producer：加载与处理图片，它有多种实现，例如：NetworkFetcherProducer，LocalAssetFetcherProducer，LocalFileFetchProducer。从这些类的名字我们就可以知道它们是干什么的。<br>Producer由ProducerFactory这个工厂类构建的，而且所有的Producer都是像Java的IO流那样，可以一层嵌套一层，最终只得到一个结果，这是一个很精巧的设计👍</li><li>Consumer：用来接收Producer产生的结果，它与Producer组成了生产者与消费者模式。</li></ul><p>注：Fresco源码里的类的名字都比较长，但是都是按照一定的命令规律来的，例如：以Supplier结尾的类都实现了Supplier接口，它可以提供某一个类型的对象（factory, generator, builder, closure等）。<br>以Builder结尾的当然就是以构造者模式创建对象的类。</p><h3 id="EventBus是如何做到发送粘性消息的？"><a href="#EventBus是如何做到发送粘性消息的？" class="headerlink" title="EventBus是如何做到发送粘性消息的？"></a>EventBus是如何做到发送粘性消息的？</h3><p>EventBus里有一个HashMap用来存储粘性事件队列，当注册事件时，如果该事件是粘性事件，则从该队列中取出最后一个该类型的事件并发送给订阅者。</p><h3 id="天猫七巧板布局、vLayout的实现原理？"><a href="#天猫七巧板布局、vLayout的实现原理？" class="headerlink" title="天猫七巧板布局、vLayout的实现原理？"></a>天猫七巧板布局、vLayout的实现原理？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/13/数据结构与算法面试题集/</id>
    <published>2018-04-13T01:07:14.000Z</published>
    <updated>2018-04-17T01:43:55.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><p>数据结构与算法通常也与Java的集合牵扯在一起考察，这里我们将两者放在一起来讲。</p><p>什么是算法？</p><blockquote><p>算法是指令的集合，是为了解决特定问题而规定的一些列操作。</p></blockquote><p>时间复杂度</p><blockquote><p>算法的执行时间随着问题规模的增长而变化的规律。</p></blockquote><p>算法的执行时间受到以下四个因素的影响：</p><ul><li>硬件层面：计算机执行每条指令的速度</li><li>软件层面：编译产生的代码质量</li><li>算法策略：算法的好坏</li><li>问题规模</li></ul><p>空间复杂度</p><blockquote><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。</p></blockquote><p>例如：插入排序的算法复杂度是O(1)。而一般递归算法的时间复杂度就是O(n)，因为每次递归都要存储结果。</p><p>常熟阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)，平方阶O(n^2)、立方阶O(n^3)、k次方阶O(n^k)、指数阶O(2^n);</p><h3 id="描述一下Java的集合体系，List、Set与Map有什么区别？"><a href="#描述一下Java的集合体系，List、Set与Map有什么区别？" class="headerlink" title="描述一下Java的集合体系，List、Set与Map有什么区别？"></a>描述一下Java的集合体系，List、Set与Map有什么区别？</h3><p>Java集合里使用接口来定义功能，是一套完善的继承体系。Iterator是所有集合的总接口，其他所有接口都继承于它，该接口定义了集合的<br>遍历操作，Collection接口继承于Iterator，是集合的次级接口（Map独立存在，除外），定义了集合的一些通用操作。</p><p>Java集合的类结构图如下所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/java_collection_structure.png"></p><ul><li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li><li>Set：无序，不可重复；</li><li>Map：键值对，键唯一，值多个；</li></ul><h3 id="并发集合了解哪些？"><a href="#并发集合了解哪些？" class="headerlink" title="并发集合了解哪些？"></a>并发集合了解哪些？</h3><blockquote><p>ConcurrentHashMap：线程不安全的HashMap、效率低下的HashTable、线程安全且高效的ConcurrentHashMap。</p></blockquote><p>ConcurrentHashMap存储元素的结构如下所示：</p><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashMap_structure.png" width="500"></p><p>ConcurrentHashMap与HashMap一样适用数组加链表存储元素，适用链表定址法来解决哈希冲突，不同之处在于当链表长度大于8的时候会将链表转换为一棵红黑树，查找时间复杂度由O(N)变成O(lgN)。</p><p>ConcurrentHashMap并发控制的关键在于一个变量，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div></pre></td></tr></table></figure><p>sizeCtl被volatile关键字修饰是一个多线程共享的变量，当它的值为负数的时候说明某个线程正在操作这个Map，想要去操作这个Map的线程就要一直去竞争这个sizeCtl，没有得到这个变量的值就要一直自旋等待这个变量，当占用<br>这个变量的线程操作完成后，要将这个变量的值设置回来，以便让其他线程走出自旋，竞争到该变量。</p><p>这种同步进制事实上是一种CAS的做法。</p><blockquote><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p></blockquote><h3 id="Vector，ArrayList与LinkedList有什么区别，应用场景是什么？"><a href="#Vector，ArrayList与LinkedList有什么区别，应用场景是什么？" class="headerlink" title="Vector，ArrayList与LinkedList有什么区别，应用场景是什么？"></a>Vector，ArrayList与LinkedList有什么区别，应用场景是什么？</h3><ul><li>Vector实现了基于动态Object数组的数据结构，线程安全，可以设置增长因子，效率比较低，不建议使用。</li><li>ArrayList实现了基于动态Object数组的数据结构，非线程安全，地址连续，查询效率比较高，插入和删除效率比较低。适合查询操作频繁的场景。</li><li>LinkedList实现了基于链表的数据结构，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。</li></ul><h3 id="HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？"><a href="#HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？" class="headerlink" title="HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？"></a>HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？</h3><ul><li>HashMap：基于HashMap.Node数组加单向链表实现，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。</li><li>LinkedHashMap：基于</li><li>ConcurrentHashMap：基于hash表实现，线程安全且高效，分段锁的实现相对于HashTable的实现提高了很大的效率。</li><li>TreeMap：基于红黑树实现，非线程安全，可以按照自然顺序或者自定义顺序自动排序，不允许插入null值，查找效率比较高，适合需要排序的场景。</li></ul><p>ConcurrentHashMap存储元素的结构如下所示：</p><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashMap_structure.png" width="500"></p><p>ConcurrentHashMap与HashMap一样适用数组加链表存储元素，适用链表定址法来解决哈希冲突，不同之处在于当链表长度大于8的时候会将链表转换为一棵红黑树，查找时间复杂度由O(N)变成O(lgN)。</p><p>ConcurrentHashMap并发控制的关键在于一个变量，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div></pre></td></tr></table></figure><p>sizeCtl被volatile关键字修饰是一个多线程共享的变量，当它的值为负数的时候说明某个线程正在操作这个Map，想要去操作这个Map的线程就要一直去竞争这个sizeCtl，没有得到这个变量的值就要一直自旋等待这个变量，当占用<br>这个变量的线程操作完成后，要将这个变量的值设置回来，以便让其他线程走出自旋，竞争到该变量。</p><p>这种同步进制事实上是一种CAS的做法。</p><blockquote><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较</p></blockquote><h3 id="HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？"><a href="#HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？" class="headerlink" title="HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？"></a>HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？</h3><ul><li>HashSet：基于HashMap实现，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。</li><li>LinkedHashSet：</li></ul><ul><li>TreeSet基于红黑树实现，非线程安全，可以按照自然顺序或者自定义顺序自动排序，不允许插入null值。适合需要排序的场景。</li><li>HashSet基于hash表实现，非线程安全，允许插入null，查找效率高。适合查找操作频繁的场景。</li></ul><h3 id="HashMap是如何解决hash碰撞的？"><a href="#HashMap是如何解决hash碰撞的？" class="headerlink" title="HashMap是如何解决hash碰撞的？"></a>HashMap是如何解决hash碰撞的？</h3><ul><li>开发定址法</li><li>链表法</li></ul><blockquote><p>HashMap基于数组实现，数组里的元素是一个单向链表。</p></blockquote><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashMap_class.png" width="500"></p><p>HashMap具有以下特点：</p><ul><li>基于数组实现，数组里的元素是一个单向链表。</li><li>键不可以重复，值可以重复，键、值都可以为null</li><li>非线程安全</li></ul><p>HashMap实现了以下接口：</p><ul><li>Map：以键值对的形式存取元素</li><li>Cloneable：可以被克隆</li><li>Serializable：可以序列化</li></ul><p>查找流程</p><ol><li>计算哈希值，根据哈希值与数组容量计算它所在的索引，根据索引查找它所在的链表。</li><li>在单向链表中查找该元素</li></ol><p>删除流程</p><ol><li>计算哈希值，根据哈希值与数组容量计算它所在的索引，根据索引查找它所在的链表。</li><li>从起始节点开始遍历，查找要删除的元素，删除该节点，将节点的后继添加为它前驱的后继</li></ol><p>插入流程</p><ol><li>根据key计算hash值，并根据hash值和数组容量，找到索引值，该位置即为存储该元素的链表所在处。</li><li>遍历table[i]位置的链表，查找相同的key，若找到则则用新的value替换掉oldValue.</li><li>若没有查找到相同的key，则添加key到table[i]位置，新添加的元素总是添加在单向链表的表头位置，后面的元素称为它的后继。</li></ol><blockquote><p>HashSet基于HashMap实现，也就是说它本质上也是一个数组，它以HashMap的key来存储元素，因为HashMap里的key是不会重复的，所以HashSet的元素时不重复且无序的。</p></blockquote><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashSet_class.png" width="500"></p><h3 id="SpareArray做了哪些优化？"><a href="#SpareArray做了哪些优化？" class="headerlink" title="SpareArray做了哪些优化？"></a>SpareArray做了哪些优化？</h3><p>优点</p><ul><li>key保存在int mKeys[]数组中，相对于HashMap不再对key进行自动装箱，避免资源消耗。但是vaule是保存在Object[] mValues数组中还是需要自动装箱的。</li><li>相对于HashMap，不再使用额外的Entry对象来存储数据，减少了内存开销。</li><li>数据量小的情况下，随机访问效率更高。</li></ul><p>缺点</p><ul><li>插入操作需要复制数组，增删效率低。</li><li>数据量巨大时，复制数组成本巨大，gc()成本也巨大。</li><li>数据量巨大时，查询效率也会明显下降。</li></ul><h3 id="简单说一说SpareArray的插入流程？"><a href="#简单说一说SpareArray的插入流程？" class="headerlink" title="简单说一说SpareArray的插入流程？"></a>简单说一说SpareArray的插入流程？</h3><p>SpareArray的key是一个int有序数组，查找过程使用的二分查找。</p><ol><li>用二分查找法查找元素的key。</li><li>如果插入的数据冲突了，则直接覆盖原则。</li><li>如果当前插入的key上的数据为DELETE，则直接覆盖。</li><li>如果前面几步都失败了，则检查是否需要gc()并且在索引上插入数据。</li></ol><h3 id="N个无序树中查找最大的10个数？"><a href="#N个无序树中查找最大的10个数？" class="headerlink" title="N个无序树中查找最大的10个数？"></a>N个无序树中查找最大的10个数？</h3><h3 id="手写代码遍历文件目录？"><a href="#手写代码遍历文件目录？" class="headerlink" title="手写代码遍历文件目录？"></a>手写代码遍历文件目录？</h3><h3 id="电梯运行的算法分析？"><a href="#电梯运行的算法分析？" class="headerlink" title="电梯运行的算法分析？"></a>电梯运行的算法分析？</h3><h3 id="手写一下单链表的查询操作？"><a href="#手写一下单链表的查询操作？" class="headerlink" title="手写一下单链表的查询操作？"></a>手写一下单链表的查询操作？</h3><h3 id="手写二分查找？"><a href="#手写二分查找？" class="headerlink" title="手写二分查找？"></a>手写二分查找？</h3><h3 id="手写一个字符串翻转？"><a href="#手写一个字符串翻转？" class="headerlink" title="手写一个字符串翻转？"></a>手写一个字符串翻转？</h3><h3 id="从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？"><a href="#从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？" class="headerlink" title="从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？"></a>从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">string:  Hello</div><div class="line">  length:  5</div><div class="line">  </div><div class="line">          0 1 2 3 4 </div><div class="line">  before: H e l l o</div><div class="line">  after:  o l l e H</div><div class="line">  </div><div class="line">  index             sum</div><div class="line">  0: H---&gt;o  0--&gt;4  4</div><div class="line">  1: e---&gt;l  1--&gt;3  4</div><div class="line">  2: l---&gt;l  2--&gt;2  4</div></pre></td></tr></table></figure><p>解法一：使用数组</p><ol><li>将字符串转换为char数组</li><li>遍历循环给char数组赋值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray2</span><span class="params">(String string)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</div><div class="line">    <span class="keyword">int</span> length = string.length();</div><div class="line">    <span class="keyword">char</span> [] array = string.toCharArray();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</div><div class="line">        array[i] = string.charAt(length-<span class="number">1</span>-i);</div><div class="line">        array[length-<span class="number">1</span>-i] = string.charAt(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解法二：使用栈</p><ol><li>将字符串转换为char数组</li><li>将char数组中的字符依次压入栈中</li><li>将栈中的字符依次弹出赋值给char数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithStack</span><span class="params">(String string)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</div><div class="line">    Stack&lt;Character&gt; stringStack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">char</span> [] array = string.toCharArray();</div><div class="line">    <span class="keyword">for</span>(Character c:array)&#123;</div><div class="line">        stringStack.push(c);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> length = string.length();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">        array[i] = stringStack.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解法三：逆序遍历</p><ol><li>逆序遍历字符串中的字符，并将它依次添加到StringBuilder中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithReverseLoop</span><span class="params">(String string)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = string.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">            sb.append(string.charAt(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="单链表反转，合并多个单链表"><a href="#单链表反转，合并多个单链表" class="headerlink" title="单链表反转，合并多个单链表"></a>单链表反转，合并多个单链表</h3><p>单链表的结构就像一个火车的结构，火车头拉着许多车厢，实现链表翻转，可以利用递归翻转法，在反转当前节点之前先反转后续节点。这样从头结点开始，层层深入直到尾结点才开始反转指针域的指向。简单的<br>说就是从尾结点开始，逆向反转各个结点的指针域指向，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListReverse</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);  </div><div class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);  </div><div class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);  </div><div class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);  </div><div class="line">        head.setNext(node1);  </div><div class="line">        node1.setNext(node2);  </div><div class="line">        node2.setNext(node3);  </div><div class="line">  </div><div class="line">        <span class="comment">// 打印反转前的链表  </span></div><div class="line">        Node h = head;  </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != h) &#123;  </div><div class="line">            System.out.print(h.getData() + <span class="string">" "</span>);  </div><div class="line">            h = h.getNext();  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 调用反转方法  </span></div><div class="line">        head = Reverse1(head);  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"\n**************************"</span>);  </div><div class="line">        <span class="comment">// 打印反转后的结果  </span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head) &#123;  </div><div class="line">            System.out.print(head.getData() + <span class="string">" "</span>);  </div><div class="line">            head = head.getNext();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 递归，在反转当前节点之前先反转后续节点 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">Reverse1</span><span class="params">(Node head)</span> </span>&#123;  </div><div class="line">        <span class="comment">// head看作是前一结点，head.getNext()是当前结点，reHead是反转后新链表的头结点  </span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> head;<span class="comment">// 若为空链或者当前结点在尾结点，则直接还回  </span></div><div class="line">        &#125;  </div><div class="line">        Node reHead = Reverse1(head.getNext());<span class="comment">// 先反转后续节点head.getNext()  </span></div><div class="line">        head.getNext().setNext(head);<span class="comment">// 将当前结点的指针域指向前一结点  </span></div><div class="line">        head.setNext(<span class="keyword">null</span>);<span class="comment">// 前一结点的指针域令为null;  </span></div><div class="line">        <span class="keyword">return</span> reHead;<span class="comment">// 反转后新链表的头结点  </span></div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> Data;<span class="comment">// 数据域  </span></div><div class="line">        <span class="keyword">private</span> Node Next;<span class="comment">// 指针域  </span></div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> Data)</span> </span>&#123;  </div><div class="line">            <span class="comment">// super();  </span></div><div class="line">            <span class="keyword">this</span>.Data = Data;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> Data;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> Data)</span> </span>&#123;  </div><div class="line">            <span class="keyword">this</span>.Data = Data;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> Next;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node Next)</span> </span>&#123;  </div><div class="line">            <span class="keyword">this</span>.Next = Next;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>以下排序算法内容来自：<a href="https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">面试中的 10 大排序算法总结.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Algorithm" scheme="https://edward7zhang.github.io/tags/Algorithm/"/>
    
      <category term="DataStructure" scheme="https://edward7zhang.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/10/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/10/Java面试题集/</id>
    <published>2018-04-10T01:07:14.000Z</published>
    <updated>2018-04-18T16:33:16.250Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="谈谈对Java多态的理解？"><a href="#谈谈对Java多态的理解？" class="headerlink" title="谈谈对Java多态的理解？"></a>谈谈对Java多态的理解？</h3><blockquote><p>多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。</p></blockquote><p>多态的三个必要条件：</p><ol><li>继承父类。</li><li>重写父类的方法。</li><li>父类的引用指向子类对象。</li></ol><h3 id="静态方法与静态成员变量可以被继承吗，为什么？"><a href="#静态方法与静态成员变量可以被继承吗，为什么？" class="headerlink" title="静态方法与静态成员变量可以被继承吗，为什么？"></a>静态方法与静态成员变量可以被继承吗，为什么？</h3><p>静态方法与静态成员变量可以被继承，但是不能被重写。它对子类隐藏，因此静态方法也不能实现多态。</p><h3 id="为什么Java里的匿名内部类只能访问final修饰的外部变量？"><a href="#为什么Java里的匿名内部类只能访问final修饰的外部变量？" class="headerlink" title="为什么Java里的匿名内部类只能访问final修饰的外部变量？"></a>为什么Java里的匿名内部类只能访问final修饰的外部变量？</h3><p>匿名内部类用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryUsingAnonymousClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useMyInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Integer number = <span class="number">123</span>;</div><div class="line">        System.out.println(number);</div><div class="line"></div><div class="line">        MyInterface myInterface = <span class="keyword">new</span> MyInterface() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(number);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        myInterface.doSomething();</div><div class="line"></div><div class="line">        System.out.println(number);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TryUsingAnonymousClass</span>$1</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">MyInterface</span> &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TryUsingAnonymousClass <span class="keyword">this</span>$<span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer paramInteger;</div><div class="line"></div><div class="line">    TryUsingAnonymousClass$<span class="number">1</span>(TryUsingAnonymousClass <span class="keyword">this</span>$<span class="number">0</span>, Integer paramInteger) &#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.paramInteger = paramInteger;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.paramInteger);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为匿名内部类最终用会编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类，例如：Integer paramInteger，如果变量<br>不定义成final的，paramInteger在匿名内部类被可以被修改，进而造成和外部的paramInteger不一致的问题，为了避免这种不一致的情况，因为Java<br>规定匿名内部类只能访问final修饰的外部变量。</p><h3 id="讲一下Java的编码方式？"><a href="#讲一下Java的编码方式？" class="headerlink" title="讲一下Java的编码方式？"></a>讲一下Java的编码方式？</h3><p>为什么需要编码</p><blockquote><p>计算机存储信息的最小单元是一个字节即8bit，所以能表示的范围是0~255，这个范围无法保存所有的字符，所以需要一个新的数据结构char来表示这些字符，从char到byte需要编码。</p></blockquote><p>常见的编码方式有以下几种：</p><ul><li>ASCII：总共有 128 个，用一个字节的低 7 位表示，0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。</li><li>GBK：码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</li><li>UTF-16：UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</li><li>UTF-8：统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</li></ul><p>Java中需要编码的地方一般都在字符到字节的转换上，这个一般包括磁盘IO和网络IO。</p><blockquote><p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。</p></blockquote><h3 id="静态代理与动态代理区别是什么，分别用在什么样的场景里？"><a href="#静态代理与动态代理区别是什么，分别用在什么样的场景里？" class="headerlink" title="静态代理与动态代理区别是什么，分别用在什么样的场景里？"></a>静态代理与动态代理区别是什么，分别用在什么样的场景里？</h3><p>静态代理与动态代理的区别在于代理类生成的时间不同，如果需要对多个类进行代理，并且代理的功能都是一样的，用静态代理重复编写代理类就非常的麻烦，可以用动态代理动态的生成代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">// 为目标对象生成代理对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</div><div class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                    System.out.println(<span class="string">"开启事务"</span>);</div><div class="line"></div><div class="line">                    <span class="comment">// 执行目标对象方法</span></div><div class="line">                    Object returnValue = method.invoke(target, args);</div><div class="line"></div><div class="line">                    System.out.println(<span class="string">"提交事务"</span>);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="描述一下Java的异常体系？"><a href="#描述一下Java的异常体系？" class="headerlink" title="描述一下Java的异常体系？"></a>描述一下Java的异常体系？</h3><ol><li>Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时， Java虚拟机（JVM）一般会选择线程终止。 </li><li>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常，程序中应当尽可能去处理这些异常。运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，<br>这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。 </li></ol><h3 id="描述一个类的加载过程？"><a href="#描述一个类的加载过程？" class="headerlink" title="描述一个类的加载过程？"></a>描述一个类的加载过程？</h3><p>Person person = new Person()</p><ol><li>查找Person.class，并加载到内存中。</li><li>执行类里的静态代码块。</li><li>在堆内存里开辟内存空间，并分配内存地址。</li><li>在堆内存里建立对象的属性，并进行默认的初始化。</li><li>对属性进行显示初始化。</li><li>对对象进行构造代码块初始化。</li><li>调用对象的构造函数进行初始化。</li><li>将对象的地址赋值给person变量。</li></ol><h3 id="Java对象的生命周期是什么？"><a href="#Java对象的生命周期是什么？" class="headerlink" title="Java对象的生命周期是什么？"></a>Java对象的生命周期是什么？</h3><ol><li>加载：将类的信息加载到JVM的方法区，然后在堆区中实例化一个java.lang.Class对象，作为方法去中这个类的信息入口。</li><li>连接：验证：验证类是否合法。准备：为静态变量分配内存并设置JVM默认值，非静态变量不会分配内存。解析：将常量池里的符号引用转换为直接引用。</li><li>初始化：初始化类的静态赋值语句和静态代码块，主动引用会被触发类的初始化，被动引用不会触发类的初始化。</li><li>使用：执行类的初始化，主动引用会被触发类的初始化，被动引用不会触发类的初始化。</li><li>卸载：卸载过程就是清楚堆里类的信息，以下情况会被卸载：① 类的所有实例都已经被回收。② 类的ClassLoader被回收。③ 类的CLass对象没有被任何地方引用，无法在任何地方通过<br>反射访问该类。</li></ol><h3 id="描述一下类的加载机制？"><a href="#描述一下类的加载机制？" class="headerlink" title="描述一下类的加载机制？"></a>描述一下类的加载机制？</h3><blockquote><p>类的加载就是虚拟机通过一个类的全限定名来获取描述此类的二进制字节流，而完成这个加载动作的就是类加载器。</p></blockquote><p>类和类加载器息息相关，判定两个类是否相等，只有在这两个类被同一个类加载器加载的情况下才有意义，否则即便是两个类来自同一个Class文件，被不同类加载器加载，它们也是不相等的。</p><p>注：这里的相等性包含Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果以及Instance关键字对对象所属关系的判定结果等。</p><p>类加载器可以分为三类：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：负责加载<java_home>\lib目录下或者被-Xbootclasspath参数所指定的路径的，并且是被虚拟机所识别的库到内存中。</java_home></li><li>扩展类加载器（Extension ClassLoader）：负责加载<java_home>\lib\ext目录下或者被java.ext.dirs系统变量所指定的路径的所有类库到内存中。</java_home></li><li>应用类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载器去加载应用程序中的类库。</li></ul><p>这么多类加载器，那么当类在加载的时候会使用哪个加载器呢？🤔</p><p>这个时候就要提到类加载器的双亲委派模型，流程图如下所示：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/vm/classloader_model_structure.png" width="600"></p><p>双亲委派模型的整个工作流程非常的简单，如下所示：</p><blockquote><p>如果一个类加载器收到了加载类的请求，它不会自己立即去加载类，它会先去请求父类加载器，每个层次的类加载器都是如此。层层传递，直到传递到最高层的类加载器，只有当<br>父类加载器反馈自己无法加载这个类，才会有当前子类加载器去加载该类。</p></blockquote><p>关于双亲委派机制，在ClassLoader源码里也可以看出，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">        <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">            <span class="comment">//首先，检查该类是否已经被加载</span></div><div class="line">            Class c = findLoadedClass(name);</div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//先调用父类加载器去加载</span></div><div class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        c = findBootstrapClassOrNull(name);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                    <span class="comment">// from the non-null parent class loader</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果父类加载器没有加载到该类，则自己去执行加载</span></div><div class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">                    c = findClass(name);</div><div class="line"></div><div class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为什么要这么做呢？🤔</p><p>这是为了要让越基础的类由越高层的类加载器加载，例如Object类，无论哪个类加载器去尝试加载这个类，最终都会传递给最高层的类加载器去加载，前面我们也说过，类的相等性是由<br>类与其类加载器共同判定的，这样Object类无论在何种类加载器环境下都是同一个类。</p><p>相反如果没有双亲委派模型，那么每个类加载器都会去加载Object，那么系统中就会出现多个不同的Object类了，如此一来系统的最基础的行为也就无法保证了。</p><h3 id="描述一下GC的原理和回收策略？"><a href="#描述一下GC的原理和回收策略？" class="headerlink" title="描述一下GC的原理和回收策略？"></a>描述一下GC的原理和回收策略？</h3><p>提到垃圾回收，我们可以先思考一下，如果我们去做垃圾回收需要解决哪些问题？ 🤔</p><p>一般说来，我们要解决以下三个问题：</p><ul><li>哪些内存回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>这些问题分别对应着引用管理和回收策略等方案。</p><p>提到引用，我们都知道Java中有四种引用类型：</p><ul><li>强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。</li><li>软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候回回收这类对象。</li><li>弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次GC发生时，当GC发生时，无论内存是否足够，都会回收该对象。</li><li>虚引用：PhantomReference，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用取得一个对象的引用，它存在的唯一目的是在这个对象被回收时可以收到一个系统通知。</li></ul><p>不同的引用类型，在做GC时会区别对待，我们平时生成的Java对象，默认都是强引用，也就是说只要强引用还在，GC就不会回收，那么如何判断强引用是否存在呢？🤔</p><p>一个简单的思路就是：引用计数法，有对这个对象的引用就+1，不再引用就-1，但是这种方式看起来简单美好，但它却不嫩解决循环引用计数的问题。</p><p>因此可达性分析算法登上历史舞台😎，用它来判断对象的引用是否存在。</p><blockquote><p>可达性分析算法通过一系列称为GC Roots的对象作为起始点，从这些节点从上向下搜索，搜索走过的路径称为引用链，当一个对象没有任何引用链<br>与GC Roots连接时就说明此对象不可用，也就是对象不可达。</p></blockquote><p>GC Roots对象通常包括：</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>方法去中类的静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>Native方法引用的对象</li></ul><p>可达性分析算法整个流程如下所示：</p><ol><li>第一次标记：对象在经过可达性分析后发现没有与GC Roots有引用链，则进行第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行finalize()方法。没有覆盖finalize()方法或者finalize()方法已经被执行过都会被<br>认为<strong>没有必要执行</strong>。<ul><li>如果有必要执行：则该对象会被放在一个F-Queue队列，并稍后在由虚拟机建立的低优先级Finalizer线程中触发该对象的finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的finalize()方法发生了死循环或者执行<br>时间较长的情况，会阻塞F-Queue队列里的其他对象，影响GC。</li></ul></li><li>第二次标记：GC对F-Queue队列里的对象进行第二次标记，如果在第二次标记时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。</li></ol><h3 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h3><p>共同点</p><ol><li>是上层的抽象层。</li><li>都不能被实例化</li><li>都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不会提供具体的实现。</li></ol><p>区别</p><ol><li>在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。</li><li>一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。</li></ol><hr><blockquote><p>问：抽象类是否可继承实体类 (concrete class)<br>答： 抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数</p></blockquote><p>答案很明确，可以继承。其实从Object就是个实体类，java的API文档里，每个抽象类的条目里都明确写着直接或间接继承自Object，所以这点是没有疑问的。<br>关键在于这答案里所说的“前提是实体类必须有明确的构造函数”一句，是什么意思。<br>一般学习者会写的简单试验代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</div></pre></td></tr></table></figure></p><p>结果完全正常，编译通过。似乎和“实体类必须有明确的构造函数”完全没有关系。</p><p>这个问题涉及到两个个基础知识：</p><ol><li><p>所有的class都必须有一个构造方法，如果你没有在代码里声明构造方法，系统会自动给你生成一个公有无参的构造方法。而只要你自己声明了一个构造方法，无论有参无参，私有公有，系统就不再帮你生成默认无参构造器了。</p></li><li><p>所有的子类构造器都要求在第一行代码中调用父类构造器，如果不写，系统默认去调用父类的无参构造器。</p></li></ol><p>所以，如果把系统默认配给的方法也算进去，class A{}的代码实际上是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>B继承 A 的时候，则是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">super</span>();</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要试验出这继承规则的内部情况，也很简单，在最上面那个简单试验代码里，加上个私有构造器，有参无参都行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">A</span><span class="params">()</span></span>&#123;&#125;   </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个时候，如基础知识(1) 中所说，系统不再给你默认无参构造器， B的构造器根据（2）中的规则去调用super()，却找不到A的无参构造器，所以导致abstract class B extends A{} 编译不能通过。（因为A中没有任何构造器可供子类调用，其实这个时候A只能够供内部类继承，我用的Eclipse的3.4版本会建议给B改名，但是这解决不了这个问题。）</p><p>现在，你应该了解了资料给的那句语焉不详的“实体类必须有明确的构造函数”的含义：</p><ol><li><p>没写构造器的，那是拥有默认无参公有构造函数的，子类可以什么都不写，让默认构造器去调用它。这是最初那两行代码的情况。</p></li><li><p>写了子类可访问的无参构造器的，也是一样，子类里可以什么都不写，用默认机制调用。</p></li><li><p>写了 有参构造器却没写无参构造器的，父类里没有子类可访问的无参构造器，子类必须在子类构造器里的第一句写明，调用父类有参构造器，并把参数传进去。</p></li><li><p>声明为final的以及所有构造器都不在子类访问权限之内的类无法继承 </p></li></ol><p>其实只要是在类的继承中，无论抽象还是实体，都需要符合这个规则的。在这个继承试验中随时删掉或是加上abstract的前缀，结果都没有变化。个人觉得“实体类必须有明确的构造函数”一句实在是无法把这个情况表达清楚，所以广大求职者还是写得清楚些好。</p><p>我喜欢的写法是“可以继承，但是和实体类的继承一样，也要求父类可继承，并且拥有子类可访问到的构造器。”</p><hr><h3 id="内部类、静态内部类在业务中的应用场景是什么？"><a href="#内部类、静态内部类在业务中的应用场景是什么？" class="headerlink" title="内部类、静态内部类在业务中的应用场景是什么？"></a>内部类、静态内部类在业务中的应用场景是什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Outer outer = <span class="keyword">new</span> Outer();</div><div class="line">Outer.Inner inner = outer.new Inner();</div><div class="line">Outer.StaticInner inner0 = <span class="keyword">new</span> Outer.StaticInner();</div></pre></td></tr></table></figure><ul><li>静态内部类：只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。</li><li>非静态内部类：持有外部类的引用，可以自由使用外部类的所有变量和方法</li></ul><h3 id="synchronized与ReentrantLock有什么区别？"><a href="#synchronized与ReentrantLock有什么区别？" class="headerlink" title="synchronized与ReentrantLock有什么区别？"></a>synchronized与ReentrantLock有什么区别？</h3><p>synchronized是互斥同步的一种实现。</p><blockquote><p>synchronized：当某个线程访问被synchronized标记的方法或代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个<br>线程才会释放该对象的锁，其他线程才能执行这个方法或代码块。</p></blockquote><p>前面我们已经说了volatile关键字，这里我们举个例子来综合分析volatile与synchronized关键字的使用。</p><p>:point_up: 举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//volatile保证了：1 instance在多线程并发的可见性 </span></div><div class="line">                   <span class="comment">//2 禁止instance在操作时的指令重排序</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//第一次判空，保证不必要的同步</span></div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//synchronized对Singleton加全局锁，保证每次只要一个线程创建实例</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="comment">//第二次判空时为了在null的情况下创建实例</span></div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个经典的DCL单例。</p><p>它的字节码如下：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/synchronized_bytecode.png"></p><p>可以看到被synchronized同步的代码块，会在前后分别加上monitorenter和monitorexit，这两个字节码都需要指定加锁和解锁的对象。</p><p>关于加锁和解锁的对象：</p><ul><li>synchronized代码块 ：同步代码块，作用范围是整个代码块，作用对象是调用这个代码块的对象。</li><li>synchronized方法 ：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。</li><li>synchronized静态方法 ：同步静态方法，作用范围是整个静态方法，作用对象是调用这个类的所有对象。</li><li>synchronized(this)：作用范围是该对象中所有被synchronized标记的变量、方法或代码块，作用对象是对象本身。</li><li>synchronized(ClassName.class) ：作用范围是静态的方法或者静态变量，作用对象是Class对象。</li></ul><p>synchronized(this)添加的是对象锁，synchronized(ClassName.class)添加的是类锁，它们的区别如下：</p><blockquote><p>对象锁：Java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。 </p><p>类锁：对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。我们都知道，java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是MyClass.class的方式。 类锁和对象锁不是同一个东西，一个是类的Class对象的锁，一个是类的实例的锁。也就是说：一个线程访问静态synchronized的时候，允许另一个线程访问对象的实例synchronized方法。反过来也是成立的，因为他们需要的锁是不同的。</p></blockquote><h3 id="volatile的原理是什么？"><a href="#volatile的原理是什么？" class="headerlink" title="volatile的原理是什么？"></a>volatile的原理是什么？</h3><p>volatile也是互斥同步的一种实现，不过它非常的轻量级。</p><p>volatile有两条关键的语义：</p><ul><li>保证被volatile修饰的变量对所有线程都是可见的</li><li>禁止进行指令重排序</li></ul><p>要理解volatile关键字，我们得先从Java的线程模型开始说起。如图所示：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/java_memory_model.png"></p><p>Java内存模型规定了所有字段（这些字段包括实例字段、静态字段等，不包括局部变量、方法参数等，因为这些是线程私有的，并不存在竞争）都存在主内存中，每个线程会<br>有自己的工作内存，工作内存里保存了线程所使用到的变量在主内存里的副本拷贝，线程对变量的操作只能在工作内存里进行，而不能直接读写主内存，当然不同内存之间也<br>无法直接访问对方的工作内存，也就是说主内存是线程传值的媒介。</p><p>我们来理解第一句话：</p><blockquote><p>保证被volatile修饰的变量对所有线程都是可见的</p></blockquote><p>如何保证可见性？🤔</p><p>被volatile修饰的变量在工作内存修改后会被强制写回主内存，其他线程在使用时也会强制从主内存刷新，这样就保证了一致性。</p><p>关于“保证被volatile修饰的变量对所有线程都是可见的”，有种常见的错误理解：</p><blockquote><p>错误理解：由于volatile修饰的变量在各个线程里都是一致的，所以基于volatile变量的运算在多线程并发的情况下是安全的。</p></blockquote><p>这句话的前半部分是对的，后半部分却错了，因此它忘记考虑变量的操作是否具有<strong>原子性</strong>这一问题。</p><p>举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">volatileKeyword</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                start++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">    Log.d(TAG, <span class="string">"start = "</span> + start);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/volatile_thread_safe.png"></p><p>这段代码启动了10个线程，每次10次自增，按道理最终结果应该是100，但是结果并非如此。</p><p>为什么会这样？🤔</p><p>仔细看一下start++，它其实并非一个原子操作，简单来看，它有两步：</p><ol><li>取出start的值，因为有volatile的修饰，这时候的值是正确的。</li><li>自增，但是自增的时候，别的线程可能已经把start加大了，这种情况下就有可能把较小的start写回主内存中。</li></ol><p>所以volatile只能保证可见性，在不符合以下场景下我们依然需要通过加锁来保证原子性：</p><ul><li>运算结果并不依赖变量当前的值，或者只有单一线程修改变量的值。（要么结果不依赖当前值，要么操作是原子性的，要么只要一个线程修改变量的值）</li><li>变量不需要与其他状态变量共同参与不变约束</li></ul><p>比方说我们会在线程里加个boolean变量，来判断线程是否停止，这种情况就非常适合使用volatile。</p><p>我们再来理解第二句话。</p><ul><li>禁止进行指令重排序</li></ul><p>什么是指令重排序？🤔</p><blockquote><p>指令重排序是值指令乱序执行，即在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开为获取下一条指令所需数据而造成的等待，通过乱序执行的技术，提供执行效率。</p></blockquote><p>指令重排序绘制被volatile修饰的变量的赋值操作前，添加一个内存屏障，指令重排序时不能把后面的指令重排序到内存屏障之前的位置。</p><p>关于指令重排序不是本篇文章重点讨论的内容，更多细节可以参考<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="external">指令重排序</a>。</p><h3 id="如何防止反射、序列化攻击单例？"><a href="#如何防止反射、序列化攻击单例？" class="headerlink" title="如何防止反射、序列化攻击单例？"></a>如何防止反射、序列化攻击单例？</h3><p>枚举单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"read"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"write"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">super</span>(s, i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton[] values()</div><div class="line">    &#123;</div><div class="line">        Singleton asingleton[];</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        Singleton asingleton1[];</div><div class="line">        System.arraycopy(asingleton = ENUM$VALUES, <span class="number">0</span>, asingleton1 = <span class="keyword">new</span> Singleton[i = asingleton.length], <span class="number">0</span>, i);</div><div class="line">        <span class="keyword">return</span> asingleton1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">valueOf</span><span class="params">(String s)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (Singleton)Enum.valueOf(singleton/Singleton, s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Singleton(String s, <span class="keyword">int</span> i, Singleton singleton)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>(s, i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton ENUM$VALUES[];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> </div><div class="line">    &#123;</div><div class="line">        INSTANCE = <span class="keyword">new</span> Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></div><div class="line">            &#123;</div><div class="line">                System.out.println(<span class="string">"read"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></div><div class="line">            &#123;</div><div class="line">                System.out.println(<span class="string">"write"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line">        ENUM$VALUES = (<span class="keyword">new</span> Singleton[] &#123;</div><div class="line">            INSTANCE</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>类的修饰abstract，所以没法实例化，反射也无能为力。</li><li>关于线程安全的保证，其实是通过类加载机制来保证的，我们看看INSTANCE的实例化时机，是在static块中，JVM加载类的过程显然是线程安全的。</li><li>对于防止反序列化生成新实例的问题还不是很明白，一般的方法我们会在该类中添加上如下方法，不过枚举中也没有显示的写明该方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//readResolve to prevent another instance of Singleton</span></div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="线程为什么阻塞，为和要使用多线程？"><a href="#线程为什么阻塞，为和要使用多线程？" class="headerlink" title="线程为什么阻塞，为和要使用多线程？"></a>线程为什么阻塞，为和要使用多线程？</h3><p>使用多线程更多的是为了提高CPU的并发，可以让CPU同事处理多个事情，多线程场景的使用场景：</p><ol><li>为了不让耗时操作阻塞主线程，开启新线程执行耗时操作。</li><li>某种任务虽然耗时但是不消耗CPU，例如：磁盘IO，可以开启新线程来做，可以显著的提高效率。</li><li>优先级比较低的任务，但是需要经常去做，例如：GC，可以开启新线程来做。</li></ol><h3 id="了解线程的生命周期吗，描述一下？"><a href="#了解线程的生命周期吗，描述一下？" class="headerlink" title="了解线程的生命周期吗，描述一下？"></a>了解线程的生命周期吗，描述一下？</h3><p>线程状态流程图图</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/java_thread_state.png"></p><ul><li>NEW：创建状态，线程创建之后，但是还未启动。</li><li>RUNNABLE：运行状态，处于运行状态的线程，但有可能处于等待状态，例如等待CPU、IO等。</li><li>WAITING：等待状态，一般是调用了wait()、join()、LockSupport.spark()等方法。</li><li>TIMED_WAITING：超时等待状态，也就是带时间的等待状态。一般是调用了wait(time)、join(time)、LockSupport.sparkNanos()、LockSupport.sparkUnit()等方法。</li><li>BLOCKED：阻塞状态，等待锁的释放，例如调用了synchronized增加了锁。</li><li>TERMINATED：终止状态，一般是线程完成任务后退出或者异常终止。 </li></ul><p>NEW、WAITING、TIMED_WAITING都比较好理解，我们重点说一说RUNNABLE运行态和BLOCKED阻塞态。</p><p>线程进入RUNNABLE运行态一般分为五种情况：</p><ul><li>线程调用sleep(time)后查出了休眠时间</li><li>线程调用的阻塞IO已经返回，阻塞方法执行完毕</li><li>线程成功的获取了资源锁</li><li>线程正在等待某个通知，成功的获得了其他线程发出的通知</li><li>线程处于挂起状态，然后调用了resume()恢复方法，解除了挂起。</li></ul><p>线程进入BLOCKED阻塞态一般也分为五种情况：</p><ul><li>线程调用sleep()方法主动放弃占有的资源</li><li>线程调用了阻塞式IO的方法，在该方法返回前，该线程被阻塞。</li><li>线程视图获得一个资源锁，但是该资源锁正被其他线程锁持有。</li><li>线程正在等待某个通知</li><li>线程调度器调用suspend()方法将该线程挂起</li></ul><p>我们再来看看和线程状态相关的一些方法。</p><ul><li>sleep()方法让当前正在执行的线程在指定时间内暂停执行，正在执行的线程可以通过Thread.currentThread()方法获取。</li><li>yield()方法放弃线程持有的CPU资源，将其让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。</li><li>wait()方法是当前执行代码的线程进行等待，将当前线程放入预执行队列，并在wait()所在的代码处停止执行，知道接到通知或者被中断为止。该方法可以使得调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到再次被唤醒。该方法只能在同步代码块里调用，否则会抛出IllegalMonitorStateException异常。</li><li>wait(long millis)方法等待某一段时间内是否有线程对锁进行唤醒，如果超过了这个时间则自动唤醒。</li><li>notify()方法用来通知那些可能等待该对象的对象锁的其他线程，该方法可以随机唤醒等待队列中等同一共享资源的一个线程，并使该线程退出等待队列，进入可运行状态。</li><li>notifyAll()方法可以是所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，进入可运行状态，一般会是优先级高的线程先执行，但是根据虚拟机的实现不同，也有可能是随机执行。</li><li>join()方法可以让调用它的线程正常执行完成后，再去执行该线程后面的代码，它具有让线程排队的作用。</li></ul><h3 id="线程池了解吗，有几种线程池，应用场景是什么？"><a href="#线程池了解吗，有几种线程池，应用场景是什么？" class="headerlink" title="线程池了解吗，有几种线程池，应用场景是什么？"></a>线程池了解吗，有几种线程池，应用场景是什么？</h3><p>Executors类提供了一系列工厂方法用来创建线程池。这些线程是适用于不同的场景。</p><ul><li>newCachedThreadPool()：无界可自动回收线程池，查看线程池中有没有以前建立的线程，如果有则复用，如果没有则建立一个新的线程加入池中，池中的线程超过60s不活动则自动终止。适用于生命<br>周期比较短的异步任务。</li><li>newFixedThreadPool(int nThreads)：固定大小线程池，与newCachedThreadPool()类似，但是池中持有固定数目的线程，不能随时创建线程，如果创建新线程时，超过了固定<br>线程数，则放在队列里等待，直到池中的某个线程被移除时，才加入池中。适用于很稳定、很正规的并发线程，多用于服务器。</li><li>newScheduledThreadPool(int corePoolSize)：周期任务线程池，该线程池的线程可以按照delay依次执行线程，也可以周期执行。</li><li>newSingleThreadExecutor()：单例线程池，任意时间内池中只有一个线程。</li></ul><h3 id="ThreadLocal的原理了解吗？"><a href="#ThreadLocal的原理了解吗？" class="headerlink" title="ThreadLocal的原理了解吗？"></a>ThreadLocal的原理了解吗？</h3><p>ThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示：</p><ol><li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等。</li><li>实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例。</li><li>承载一些线程相关的数据，避免在方法中来回传递参数。</li></ol><h3 id="wait和notify机制，手写一下生产者和消费者模型？"><a href="#wait和notify机制，手写一下生产者和消费者模型？" class="headerlink" title="wait和notify机制，手写一下生产者和消费者模型？"></a>wait和notify机制，手写一下生产者和消费者模型？</h3><p>生成者消费者模型</p><p>生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p><p>wait()和notify()方法的实现生成者消费者模型，缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndCustomerModel</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer FULL = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String LOCK = <span class="string">"lock"</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ProducerAndCustomerModel  PACM  =  <span class="keyword">new</span>  ProducerAndCustomerModel();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Producer()).start();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Consumer()).start();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Producer()).start();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Consumer()).start();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Producer()).start();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Consumer()).start();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Producer()).start();</div><div class="line"><span class="keyword">new</span>  Thread(PACM.new  Consumer()).start();</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">3000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</div><div class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            LOCK.wait();</div><div class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    count++;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产，目前总共有"</span> + count);</div><div class="line">                    LOCK.notifyAll();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">3000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</div><div class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            LOCK.wait();</div><div class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    count--;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"消费者消费，目前总共有"</span> + count);</div><div class="line">                    LOCK.notifyAll();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="死锁是如何发生的，如何避免死锁？"><a href="#死锁是如何发生的，如何避免死锁？" class="headerlink" title="死锁是如何发生的，如何避免死锁？"></a>死锁是如何发生的，如何避免死锁？</h3><p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 线程a</span></div><div class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                DeadLockDemo.method1();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 线程b</span></div><div class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                DeadLockDemo.method2();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        td1.start();</div><div class="line">        td2.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程a尝试获取integer.class"</span>);</div><div class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Integer.class) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程b尝试获取String.class"</span>);</div><div class="line">            <span class="keyword">synchronized</span> (String.class) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>造成死锁的四个条件：</p><ol><li>互斥条件：一个资源每次只能被一个线程使用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakDeadLockDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 线程a</span></div><div class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                BreakDeadLockDemo.method1();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 线程b</span></div><div class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                BreakDeadLockDemo.method2();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        td1.start();</div><div class="line">        td2.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程a尝试获取integer.class"</span>);</div><div class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</div><div class="line">                System.out.println(<span class="string">"线程a获取到integer.class"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></div><div class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程b尝试获取Integer.class"</span>);</div><div class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</div><div class="line">                System.out.println(<span class="string">"线程b获取到Integer.class"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="了解Java注解的原理吗，注解如何获取？"><a href="#了解Java注解的原理吗，注解如何获取？" class="headerlink" title="了解Java注解的原理吗，注解如何获取？"></a>了解Java注解的原理吗，注解如何获取？</h3><p>注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用Java的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。</p><h3 id="String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？"><a href="#String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？" class="headerlink" title="String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？"></a>String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？</h3><ol><li>String是不可变的（修改String时，不会在原有的内存地址修改，而是重新指向一个新对象），String用final修饰，不可继承，String本质上是个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String也没有对外暴露修改char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。</li><li>StringBuffer是线程安全的。</li><li>StringBuilder是非线程安全的。</li></ol><h3 id="Java里的幂等性了解吗？"><a href="#Java里的幂等性了解吗？" class="headerlink" title="Java里的幂等性了解吗？"></a>Java里的幂等性了解吗？</h3><blockquote><p>幂等性原本是数学上的一个概念，即：f(x) = f(f(x))，对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。</p></blockquote><p>幂等性最为常见的应用就是电商的客户付款，试想一下，如果你在付款的时候因为网络等各种问题失败了，然后又去重复的付了一次，是一种多么糟糕的体验。幂等性就是为了解决这样的问题。</p><p>实现幂等性可可以使用Token机制。</p><blockquote><p>核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。</p></blockquote><p>例如：电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。</p><h3 id="Java泛型了解吗，知道它的运行机制吗？"><a href="#Java泛型了解吗，知道它的运行机制吗？" class="headerlink" title="Java泛型了解吗，知道它的运行机制吗？"></a>Java泛型了解吗，知道它的运行机制吗？</h3><blockquote><p>泛型是为了参数化类型。</p></blockquote><p>为什么使用泛型？</p><ol><li>相对于使用Object这种简单粗暴的方式，泛型提供了一种参数化的能力，使得数据的类型可以像参数一样被传递进来，这提供了一种扩展能力。</li><li>当数据类型确定以后，提供了一种类型检测机制，只有相匹配的数据才可以正常赋值，否则编译错误，增强了安全性。</li><li>泛型提高了代码的可读性，不必等到运行时采取执行类型转换，在编写代码阶段，程序员就可以通过参数书写正确的数据类型。</li></ol><p>除了用  <strong><t></t></strong>  表示泛型外，还有 <strong>&lt;?&gt;</strong> 这种形式。<strong>?</strong> 被称为通配符。</p><ul><li>&lt;?&gt; 被称作无限定的通配符。</li><li>&lt;? extends T&gt; 被称作有上限的通配符。</li><li>&lt;? super T&gt; 被称作有下限的通配符。</li></ul><h3 id="Java里的反射为何会消耗性能？"><a href="#Java里的反射为何会消耗性能？" class="headerlink" title="Java里的反射为何会消耗性能？"></a>Java里的反射为何会消耗性能？</h3><p>反射慢主要因为反射是动态类型，这样导致把在zhuang</p><h3 id="Java的类型擦除，知道它的原理吗？"><a href="#Java的类型擦除，知道它的原理吗？" class="headerlink" title="Java的类型擦除，知道它的原理吗？"></a>Java的类型擦除，知道它的原理吗？</h3><blockquote><p>泛型信息只存在代码编译阶段，在进入JVM之前，与泛型相关的信息都会被擦除掉。</p></blockquote><p>在类型擦除的时候，如果泛型类里的类型参数没有指定上限，例如：<strong><t></t></strong>，则会被转成Object类型，如果指定了上限，例如：<t extends="" string="">，则会被传换成对应的类型上限。</t></p><h3 id="闭包了解吗，Java里有闭包吗？"><a href="#闭包了解吗，Java里有闭包吗？" class="headerlink" title="闭包了解吗，Java里有闭包吗？"></a>闭包了解吗，Java里有闭包吗？</h3><blockquote><p>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    test</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> test = <span class="keyword">if</span> (<span class="number">5</span> &gt; <span class="number">3</span>) &#123;</div><div class="line">    print(<span class="string">"yes"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    print(<span class="string">"no"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Lambda表达式了解吗？"><a href="#Lambda表达式了解吗？" class="headerlink" title="Lambda表达式了解吗？"></a>Lambda表达式了解吗？</h3><blockquote><p>Lambda 表达式俗称匿名函数。Kotlin 的 Lambda表达式更“纯粹”一点， 因为它是真正把Lambda抽象为了一种类型，而 Java 8 的 Lambda 只是单方法匿名接口实现的语法糖罢了。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> printMsg = &#123; msg: String -&gt; </div><div class="line">println(msg) </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  printMsg(<span class="string">"hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="高阶函数了解吗？"><a href="#高阶函数了解吗？" class="headerlink" title="高阶函数了解吗？"></a>高阶函数了解吗？</h3><blockquote><p>当定义一个闭包作为参数的函数，称这个函数为高阶函数。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    log(<span class="string">"world"</span>, printMsg)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> printMsg = &#123; str: String -&gt;</div><div class="line">    println(str)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> log = &#123; str: String, printLog: (String) -&gt; <span class="built_in">Unit</span> -&gt;</div><div class="line">    printLog(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/08/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/08/Android面试题集/</id>
    <published>2018-04-08T01:07:14.000Z</published>
    <updated>2018-04-21T04:35:53.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a><br>并且在此基础上对一些问题进行了补充、深入剖析</p></blockquote><h3 id="手画一下Android系统架构图，描述一下各个层次的作用？"><a href="#手画一下Android系统架构图，描述一下各个层次的作用？" class="headerlink" title="手画一下Android系统架构图，描述一下各个层次的作用？"></a>手画一下Android系统架构图，描述一下各个层次的作用？</h3><p>Android系统架构图</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/android_system_structure.png" width="600"></p><p>从上到下依次分为六层：</p><ul><li>应用框架层</li><li>进程通信层</li><li>系统服务层</li><li>Android运行时层</li><li>硬件抽象层</li><li>Linux内核层</li></ul><h3 id="Activity如与Service通信？"><a href="#Activity如与Service通信？" class="headerlink" title="Activity如与Service通信？"></a>Activity如与Service通信？</h3><p>可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法<br>里执行相关操作。<br><em>注：只有activities,services,和contentproviders可以绑定到一个service—你不能从一个broadcastreceiver绑定到service．</em></p><h3 id="Service的生命周期与启动方法有什么区别？"><a href="#Service的生命周期与启动方法有什么区别？" class="headerlink" title="Service的生命周期与启动方法有什么区别？"></a>Service的生命周期与启动方法有什么区别？</h3><ul><li>startService()：开启Service，调用者退出后Service仍然存在。</li><li>bindService()：开启Service，调用者退出后Service也随即退出。</li></ul><p>Service生命周期：</p><ul><li>只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory</li><li>只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory</li><li>同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory</li></ul><h3 id="Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？"><a href="#Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？" class="headerlink" title="Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？"></a>Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20150902003400081" alt="bindService生命周期" title="">                </div>                <div class="image-caption">bindService生命周期</div>            </figure><p>通过IBinder<br>从你的客户端绑定到一个service，你必须：</p><ul><li><p>１实现ServiceConnection.</p><p>你的实现必须重写两个回调方法：</p><ul><li><p>onServiceConnected()</p><p>系统调用这个来传送在service的onBind()中返回的IBinder．</p></li><li><p>OnServiceDisconnected()</p><p>Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用．</p></li></ul></li><li><p>２调用bindService()，传给它ServiceConnection的实现．</p></li><li><p>３当系统调用你的onServiceConnected()方法时，你就可以使用接口定义的方法们开始调用service了．</p></li><li><p>４要与service断开连接，调用unbindService()．</p><p>　　当你的客户端被销毁，它将从service解除绑定，但是你必须总是在你完成与service的交互时或当你的activity暂停于是service在不被使用时可以关闭此两种情况下解</p><p>除绑定．(下面会讨论更多在适当的时候绑定和解除绑定的问题．</p><p>使用这个ServiceConnection，客户端可以绑定到一个service，通过把它传给bindService()．例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intentintent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService.class);</div><div class="line">bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</div></pre></td></tr></table></figure></li><li><p>第一个bindService()的参数是一个明确指定了要绑定的service的Intent．</p></li><li><p>第二个参数是ServiceConnection对象．</p></li><li><p>第三个参数是一个标志，它表明绑定中的操作．它一般应是BIND_AUTO_CREATE，这样就会在service不存在时创建一个．其它可选的值是BIND_DEBUG_UNBIND和BIND_NOT_FOREGROUND,不想指定时设为0即可。</p></li></ul><h4 id="补充事项"><a href="#补充事项" class="headerlink" title="补充事项"></a>补充事项</h4><p>下面是一些关于绑定到service的重要事项：</p><ul><li><p>你总是需要捕获DeadObjectException异常．它会在连接被打断时抛出．这是被远程方法抛出的唯一异常．</p></li><li><p>对象引用计数是跨进程的作用的．</p></li><li><p>你应该在客户端的生命期内使绑定和解除绑定配对进行，例如：</p><ul><li><p>如果你需要在你的activity可见时与service交互，你应该在onStart()绑定并在onStop()中解除绑定．</p></li><li><p>如果你想让你的activity即使在它停止时也能接收回应，那么你可以在onCreate()中绑定并在onDestroy()中解除绑定．注意这意味着你的activity需要使用在自己整</p><p>个运行期间使用service(即使位于后台)，所以如果service在另一个进程中，那么你增加了这个进程的负担而使它变得更容易被系统杀掉．</p><p>注：你一般不应该在你的activity的onResume()和onPause()中绑定和解除绑定到service，因为这些回调方法,出现在每个生命期变化中，并且你需要使发生在这</p><p>些变化中的处理最小化．还有，如果你应用中的多个activity绑定到同一个service，并且有一个变化发生在其中两个activity之间，service可能在当前activity解除绑</p><p>定(pause中)和下一个绑定前(rusume中)被销毁又重建．</p></li></ul></li></ul><h3 id="bindService和startService混合使用时"><a href="#bindService和startService混合使用时" class="headerlink" title="bindService和startService混合使用时"></a>bindService和startService混合使用时</h3><ol><li><p>如果先bindService,再startService:<br>在bind的Activity退出的时候,Service会执行unBind方法而不执行onDestory方法,因为有startService方法调用过,所以Activity与Service解除绑定后会有一个与调用者没有关连的Service存在</p></li><li><p>如果先bindService,再startService,再调用Context.stopService<br>Service的onDestory方法不会立刻执行,因为有一个与Service绑定的Activity,但是在Activity退出的时候,会执行onDestory,如果要立刻执行stopService,就得先解除绑定</p><hr></li></ol><p>把上面的”如果先bindService,再startService”换成”如果先startService,再bindService”,结果是一样的 </p><ul><li>问题:<br>如果在一个Activity的onCreate方法中,<br>先bindService(serviceIntent,conn,Context.BIND_AUTO_CREATE);<br>再startService(serviceIntent);<br>退出这个Activity时,会执行onUnBind<br>但是再次进入这个Activity的时候,为什么不执行onBind方法了?<br>只有在这个Service销毁后(执行onDestory),再进这个Activity才会执行onBind，还有就是当有两个客户端时，在第一个客户端startServie启动服务再bindService绑定服务,这时跳到第二个客户端里（启动时会调用onBind())，再客户端startServie启动服务再bindService绑定服务，启动时不会调用用onBind()了(因为之前客户端已经启动后没有onDestory()销毁Service，所以再客户端第二次绑定服务时，只会返回IBinder对象给onServiceConnected())，而且要注意的是当，当第一个服务启动并绑定一个服务时，再跳去第二个服务端启动并绑定这个服务时，第二个服务端再解绑时，不会调用onUnbind()，只有回到第一个客户端时，解绑这是才会调用onUnbind(),顺序反过来结果是一样的。得出一个结论是：当一个服务没被onDestory()销毁之前，只有第一个启动它的客户端能调用它的onBind()和onUnbind()。</li></ul><h3 id="广播分为哪几种，应用场景是什么？"><a href="#广播分为哪几种，应用场景是什么？" class="headerlink" title="广播分为哪几种，应用场景是什么？"></a>广播分为哪几种，应用场景是什么？</h3><ul><li>普通广播：调用sendBroadcast()发送，最常用的广播。</li><li>有序广播：调用sendOrderedBroadcast()，发出去的广播会被广播接受者按照顺序接收，广播接收者按照Priority属性值从大-小排序，Priority属性相同者，动态注册的广播优先，广播接收者还可以选择对广播进行截断和修改。</li></ul><h3 id="广播的两种注册方式有什么区别？"><a href="#广播的两种注册方式有什么区别？" class="headerlink" title="广播的两种注册方式有什么区别？"></a>广播的两种注册方式有什么区别？</h3><ul><li>静态注册：常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。</li><li>动态注册：非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造成内存泄漏。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-0ae738c6d50c0adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h3 id="广播发送和接收的原理了解吗？"><a href="#广播发送和接收的原理了解吗？" class="headerlink" title="广播发送和接收的原理了解吗？"></a>广播发送和接收的原理了解吗？</h3><ol><li>继承BroadcastReceiver，重写onReceive()方法。</li><li>通过Binder机制向ActivityManagerService注册广播。</li><li>通过Binder机制向ActivityMangerService发送广播。</li><li>ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。</li><li>BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。</li></ol><h3 id="广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="广播传输的数据是否有限制，是多少，为什么要限制？"></a>广播传输的数据是否有限制，是多少，为什么要限制？</h3><h3 id="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"><a href="#ContentProvider、ContentResolver与ContentObserver之间的关系是什么？" class="headerlink" title="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"></a>ContentProvider、ContentResolver与ContentObserver之间的关系是什么？</h3><ul><li>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。</li><li>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</li><li>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</li></ul><h3 id="遇到过哪些关于Fragment的问题，如何处理的？"><a href="#遇到过哪些关于Fragment的问题，如何处理的？" class="headerlink" title="遇到过哪些关于Fragment的问题，如何处理的？"></a>遇到过哪些关于Fragment的问题，如何处理的？</h3><ul><li><p>getActivity()空指针：这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()，此时就会有空指针，解决方案是在Fragment里使用<br>一个全局变量mActivity，在onAttach()方法里赋值，这样可能会引起内存泄漏，但是异步任务没有停止的情况下本身就已经可能内存泄漏，相比直接crash，这种方式<br>显得更妥当一些。</p></li><li><p>Fragment视图重叠：在类onCreate()的方法加载Fragment，并且没有判断saveInstanceState==null或if(findFragmentByTag(mFragmentTag) == null)，导致重复加载了同一个Fragment导致重叠。（PS：replace情况下，如果没有加入回退栈，则不判断也不会造成重叠，但建议还是统一判断下）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line"><span class="comment">// 在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠 ;</span></div><div class="line">    <span class="keyword">if</span>(saveInstanceState == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">// 或者 if(findFragmentByTag(mFragmentTag) == null)</span></div><div class="line">       <span class="comment">// 正常情况下去 加载根Fragment </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Android里的Intent传递的数据有大小限制吗，如何解决？"><a href="#Android里的Intent传递的数据有大小限制吗，如何解决？" class="headerlink" title="Android里的Intent传递的数据有大小限制吗，如何解决？"></a>Android里的Intent传递的数据有大小限制吗，如何解决？</h3><p>Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。处理方式如下：</p><ul><li>进程内：EventBus，文件缓存、磁盘缓存。</li><li>进程间：通过ContentProvider进行款进程数据共享和传递。</li></ul><h3 id="描述一下Android的事件分发机制？"><a href="#描述一下Android的事件分发机制？" class="headerlink" title="描述一下Android的事件分发机制？"></a>描述一下Android的事件分发机制？</h3><p>Android事件分发机制的本质：事件从哪个对象发出，经过哪些对象，最终由哪个对象处理了该事件。此处对象指的是Activity、Window与View。</p><p>Android事件的分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View</p><p>Android事件的分发主要由三个方法来完成，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父View调用dispatchTouchEvent()开始分发事件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 父View决定是否拦截事件</span></div><div class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(event))&#123;</div><div class="line">        <span class="comment">// 父View调用onTouchEvent(event)消费事件，如果该方法返回true，表示</span></div><div class="line">        <span class="comment">// 该View消费了该事件，后续该事件序列的事件（Down、Move、Up）将不会在传递</span></div><div class="line">        <span class="comment">// 该其他View。</span></div><div class="line">        consume = onTouchEvent(event);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 调用子View的dispatchTouchEvent(event)方法继续分发事件</span></div><div class="line">        consume = child.dispatchTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="描述一下View的绘制原理？"><a href="#描述一下View的绘制原理？" class="headerlink" title="描述一下View的绘制原理？"></a>描述一下View的绘制原理？</h3><p>View的绘制流程主要分为三步：</p><ol><li>onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成绘制工作。</li><li>onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。</li><li>onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。<br>④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。</li></ol><h3 id="requestLayout-、invalidate-与postInvalidate-有什么区别？"><a href="#requestLayout-、invalidate-与postInvalidate-有什么区别？" class="headerlink" title="requestLayout()、invalidate()与postInvalidate()有什么区别？"></a>requestLayout()、invalidate()与postInvalidate()有什么区别？</h3><ul><li>requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定<br>会触发onDraw()方法。</li><li>invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。</li><li>postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。</li></ul><p>一般说来需要重新布局就调用requestLayout()方法，需要重新绘制就调用invalidate()方法。</p><h3 id="Scroller用过吗，了解它的原理吗？"><a href="#Scroller用过吗，了解它的原理吗？" class="headerlink" title="Scroller用过吗，了解它的原理吗？"></a>Scroller用过吗，了解它的原理吗？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div></pre></td><td class="code"><pre><div class="line">//实例化Scroller对象，在自定义View中，mContext可以在自定义View的构造方法中获取</div><div class="line">Scroller mScroller = new Scroller(mContext);</div><div class="line"></div><div class="line">//在一个自定义View中实现该方法，方法名可以自定义</div><div class="line">public void smoothScrollTo(int destX,int destY)&#123;</div><div class="line">    int scrollX = getScrollX();</div><div class="line">    int scrollY  = getScrollY();</div><div class="line">    int dx = destX - scrollX;</div><div class="line">    int dy = destY - scrollY;</div><div class="line">    //前两个参数表示起始位置，第三第四个参数表示位移量，最后一个参数表示时间</div><div class="line">    mScroller.startScroll(scrollX,scrollY,dx,dy,1000);</div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//自定义View中重写该方法</div><div class="line">@Override</div><div class="line">public void computeScroll()&#123;</div><div class="line">    if(mScroller.computeScrollOffset())&#123;</div><div class="line">       scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</div><div class="line">       postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">Scroller滑动的整个过程(图片From：https://img-blog.csdn.net/20160919174056964)</div><div class="line">&lt;img src="https://img-blog.csdn.net/20160919174056964"/&gt;</div><div class="line"></div><div class="line">### 了解APK的打包流程吗，描述一下？</div><div class="line"></div><div class="line">Android的包文件APK分为两个部分：代码和资源，所以打包方面也分为资源打包和代码打包两个方面，这篇文章就来分析资源和代码的编译打包原理。</div><div class="line"></div><div class="line">APK整体的的打包流程如下图所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/vm/apk_package_flow.png"/&gt;</div><div class="line"></div><div class="line">具体说来：</div><div class="line"></div><div class="line">1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。</div><div class="line">2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。</div><div class="line">3. 通过Javac工具编译项目源码，生成Class文件。</div><div class="line">4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。</div><div class="line">5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。</div><div class="line">6. 利用KeyStore对生成的APK文件进行签名。</div><div class="line">7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件</div><div class="line">的速度会更快。</div><div class="line"></div><div class="line">### 了解APK的安装流程吗，描述一下？</div><div class="line"></div><div class="line">APK的安装流程如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/package/apk_install_structure.png" width="600"/&gt;</div><div class="line"></div><div class="line">1. 复制APK到/data/app目录下，解压并扫描安装包。</div><div class="line">2. 资源管理器解析APK里的资源文件。</div><div class="line">3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。</div><div class="line">4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。</div><div class="line">5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。</div><div class="line">5. 安装完成后，发送广播。</div><div class="line"></div><div class="line">### 当点击一个应用图标以后，都发生了什么，描述一下这个过程？</div><div class="line"></div><div class="line">点击应用图标后会去启动应用的LauncherActivity，如果LancerActivity所在的进程没有创建，还会创建新进程，整体的流程就是一个Activity的启动流程。</div><div class="line"></div><div class="line">Activity的启动流程图（放大可查看）如下所示：</div><div class="line"></div><div class="line">![Activity的启动流程图](https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_start_flow.png)</div><div class="line"></div><div class="line">整个流程涉及的主要角色有：</div><div class="line"></div><div class="line">- Instrumentation: 监控应用与系统相关的交互行为。</div><div class="line">- AMS：组件管理调度中心，什么都不干，但是什么都管。</div><div class="line">- ActivityStarter：Activity启动的控制器，处理Intent与Flag对Activity启动的影响，具体说来有：1 寻找符合启动条件的Activity，如果有多个，让用户选择；2 校验启动参数的合法性；3 返回int参数，代表Activity是否启动成功。</div><div class="line">- ActivityStackSupervisior：这个类的作用你从它的名字就可以看出来，它用来管理任务栈。</div><div class="line">- ActivityStack：用来管理任务栈里的Activity。</div><div class="line">- ActivityThread：最终干活的人，是ActivityThread的内部类，Activity、Service、BroadcastReceiver的启动、切换、调度等各种操作都在这个类里完成。</div><div class="line"></div><div class="line">注：这里单独提一下ActivityStackSupervisior，这是高版本才有的类，它用来管理多个ActivityStack，早期的版本只有一个ActivityStack对应着手机屏幕，后来高版本支持多屏以后，就</div><div class="line">有了多个ActivityStack，于是就引入了ActivityStackSupervisior用来管理多个ActivityStack。</div><div class="line"></div><div class="line">整个流程主要涉及四个进程：</div><div class="line"></div><div class="line">- 调用者进程，如果是在桌面启动应用就是Launcher应用进程。</div><div class="line">- ActivityManagerService等所在的System Server进程，该进程主要运行着系统服务组件。</div><div class="line">- Zygote进程，该进程主要用来fork新进程。</div><div class="line">- 新启动的应用进程，该进程就是用来承载应用运行的进程了，它也是应用的主线程（新创建的进程就是主线程），处理组件生命周期、界面绘制等相关事情。</div><div class="line">![img](http://upload-images.jianshu.io/upload_images/3985563-b7edc7b70c9c332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">有了以上的理解，整个流程可以概括如下：</div><div class="line"></div><div class="line">1. 点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。</div><div class="line">2. AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack</div><div class="line">处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。</div><div class="line">3. Zygote接收到新进程创建请求后fork出新进程。</div><div class="line">4. 在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。</div><div class="line">5. ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。</div><div class="line"></div><div class="line">### BroadcastReceiver与LocalBroadcastReceiver有什么区别？</div><div class="line"></div><div class="line">- BroadcastReceiver 是跨应用广播，利用Binder机制实现。</div><div class="line">- LocalBroadcastReceiver 是应用内广播，利用Handler实现，利用了IntentFilter的match功能，提供消息的发布与接收功能，实现应用内通信，效率比较高。</div><div class="line"></div><div class="line">### Android Handler机制是做什么的，原理了解吗？</div><div class="line"></div><div class="line">Android消息循环流程图如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_structure.png"/&gt;</div><div class="line"></div><div class="line">主要涉及的角色如下所示：</div><div class="line"></div><div class="line">- Message：消息，分为硬件产生的消息（例如：按钮、触摸）和软件产生的消息。</div><div class="line">- MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。</div><div class="line">- Looper：消息循环器，主要用来把消息分发给相应的处理者。</div><div class="line">- Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。</div><div class="line"></div><div class="line">整个消息的循环流程还是比较清晰的，具体说来：</div><div class="line"></div><div class="line">1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。</div><div class="line">2. Looper通过loop()不断提取触发条件的Message，并将Message交给对应的target handler来处理。</div><div class="line">3. target handler调用自身的handleMessage()方法来处理Message。</div><div class="line"></div><div class="line">事实上，在整个消息循环的流程中，并不只有Java层参与，很多重要的工作都是在C++层来完成的。我们来看下这些类的调用关系。</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_class.png"/&gt;</div><div class="line"></div><div class="line">注：虚线表示关联关系，实线表示调用关系。</div><div class="line"></div><div class="line">在这些类中MessageQueue是Java层与C++层维系的桥梁，MessageQueue与Looper相关功能都通过MessageQueue的Native方法来完成，而其他虚线连接的类只有关联关系，并没有</div><div class="line">直接调用的关系，它们发生关联的桥梁是MessageQueue。</div><div class="line"></div><div class="line">### Android Binder机制是做什么的，为什么选用Binder，原理了解吗？</div><div class="line"></div><div class="line">Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。</div><div class="line"></div><div class="line">为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种：</div><div class="line"></div><div class="line">1. 管道：在创建时分配一个page大小的内存，缓存区大小比较有限；</div><div class="line">2. 消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</div><div class="line">3. 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</div><div class="line">4. 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</div><div class="line">5. 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</div><div class="line">6. 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</div><div class="line"></div><div class="line">既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量：</div><div class="line"></div><div class="line">- 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。</div><div class="line">- 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。</div><div class="line">- 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传送IPC只能由用户在数据包里填入UID/PID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。</div><div class="line"></div><div class="line">### 描述一下Activity的生命周期，这些生命周期是如何管理的？</div><div class="line"></div><div class="line">Activity与Fragment生命周期如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/complete_android_fragment_lifecycle.png"/&gt;</div><div class="line"></div><div class="line">读者可以从上图看出，Activity有很多种状态，状态之间的变化也比较复杂，在众多状态中，只有三种是常驻状态：</div><div class="line"></div><div class="line">- Resumed（运行状态）：Activity处于前台，用户可以与其交互。</div><div class="line">- Paused（暂停状态）：Activity被其他Activity部分遮挡，无法接受用户的输入。</div><div class="line">- Stopped（停止状态）：Activity被完全隐藏，对用户不可见，进入后台。</div><div class="line"></div><div class="line">其他的状态都是中间状态。</div><div class="line"></div><div class="line">我们再来看看生命周期变化时的整个调度流程，生命周期调度流程图如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_lifecycle_structure.png" /&gt;</div><div class="line"></div><div class="line">所以你可以看到，整个流程是这样的：</div><div class="line"></div><div class="line">1. 比方说我们点击跳转一个新Activity，这个时候Activity会入栈，同时它的生命周期也会从onCreate()到onResume()开始变换，这个过程是在ActivityStack里完成的，ActivityStack</div><div class="line">是运行在Server进程里的，这个时候Server进程就通过ApplicationThread的代理对象ApplicationThreadProxy向运行在app进程ApplicationThread发起操作请求。</div><div class="line">2. ApplicationThread接收到操作请求后，因为它是运行在app进程里的其他线程里，所以ApplicationThread需要通过Handler向主线程ActivityThread发送操作消息。</div><div class="line">3. 主线程接收到ApplicationThread发出的消息后，调用主线程ActivityThread执行响应的操作，并回调Activity相应的周期方法。</div><div class="line"></div><div class="line">注：这里提到了主线程ActivityThread，更准确来说ActivityThread不是线程，因为它没有继承Thread类或者实现Runnable接口，它是运行在应用主线程里的对象，那么应用的主线程</div><div class="line">到底是什么呢？从本质上来讲启动启动时创建的进程就是主线程，线程和进程处理是否共享资源外，没有其他的区别，对于Linux来说，它们都只是一个struct结构体。</div><div class="line"></div><div class="line">### Activity的通信方式有哪些？</div><div class="line"></div><div class="line">- startActivityForResult</div><div class="line">- EventBus</div><div class="line">- LocalBroadcastReceiver</div><div class="line"></div><div class="line">### Android应用里有几种Context对象，</div><div class="line"></div><div class="line">Context类图如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/context_uml.png" width="600" /&gt;</div><div class="line"></div><div class="line">可以发现Context是个抽象类，它的具体实现类是ContextImpl，ContextWrapper是个包装类，内部的成员变量mBase指向的也是个ContextImpl对象，ContextImpl完成了</div><div class="line">实际的功能，Activity、Service与Application都直接或者间接的继承ContextWrapper。</div><div class="line"></div><div class="line">### 描述一下进程和Application的生命周期？</div><div class="line"></div><div class="line">一个安装的应用对应一个LoadedApk对象，对应一个Application对象，对于四大组件，Application的创建和获取方式也是不尽相同的，具体说来：</div><div class="line"></div><div class="line">- Activity：通过LoadedApk的makeApplication()方法创建。</div><div class="line">- Service：通过LoadedApk的makeApplication()方法创建。</div><div class="line">- 静态广播：通过其回调方法onReceive()方法的第一个参数指向Application。</div><div class="line">- ContentProvider：无法获取Application，因此此时Application不一定已经初始化。</div><div class="line"></div><div class="line">### Android哪些情况会导致内存泄漏，如何分析内存泄漏？</div><div class="line"></div><div class="line">常见的产生内存泄漏的情况如下所示：</div><div class="line"></div><div class="line">- 持有静态的Context（Activity）引用。</div><div class="line">- 持有静态的View引用，</div><div class="line">- 内部类&amp;匿名内部类实例无法释放（有延迟时间等等），而内部类又持有外部类的强引用，导致外部类无法释放，这种匿名内部类常见于监听器、Handler、Thread、TimerTask</div><div class="line">- 资源使用完成后没有关闭，例如：BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap。</div><div class="line">- 不正确的单例模式，比如单例持有Activity。</div><div class="line">- 集合类内存泄漏，如果一个集合类是静态的（缓存HashMap），只有添加方法，没有对应的删除方法，会导致引用无法被释放，引发内存泄漏。</div><div class="line">- 错误的覆写了finalize()方法，finalize()方法执行执行不确定，可能会导致引用无法被释放。</div><div class="line"></div><div class="line">查找内存泄漏可以使用Android Profiler工具或者利用LeakCanary工具。</div><div class="line"></div><div class="line">### Android有哪几种进程，是如何管理的？</div><div class="line"></div><div class="line">Android的进程主要分为以下几种：</div><div class="line"></div><div class="line">**前台进程**</div><div class="line"></div><div class="line">用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</div><div class="line"></div><div class="line">- 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</div><div class="line">- 托管某个 Service，后者绑定到用户正在交互的 Activity</div><div class="line">- 托管正在“前台”运行的 Service（服务已调用 startForeground()）</div><div class="line">- 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</div><div class="line">- 托管正执行其 onReceive() 方法的 BroadcastReceiver</div><div class="line"></div><div class="line">通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</div><div class="line"></div><div class="line">**可见进程**</div><div class="line"></div><div class="line">没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</div><div class="line"></div><div class="line">- 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</div><div class="line">- 托管绑定到可见（或前台）Activity 的 Service。</div><div class="line"></div><div class="line">可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</div><div class="line"></div><div class="line">**服务进程**</div><div class="line"></div><div class="line">正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关</div><div class="line">心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</div><div class="line"></div><div class="line">**后台进程**</div><div class="line"></div><div class="line">包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</div><div class="line"></div><div class="line">**空进程**</div><div class="line"></div><div class="line">不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</div><div class="line"></div><div class="line">ActivityManagerService负责根据各种策略算法计算进程的adj值，然后交由系统内核进行进程的管理。</div><div class="line"></div><div class="line">### SharePreference性能优化，可以做进程同步吗？</div><div class="line"></div><div class="line">在Android中, SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件</div><div class="line">存放在/data/data/ &lt; package name &gt; /shared_prefs目录下.</div><div class="line"></div><div class="line">之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会把整个文件全部加载进内存，如果SharedPreference文件比较大，会带来以下问题：</div><div class="line"></div><div class="line">1. 第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。</div><div class="line">2. 解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。</div><div class="line">3. 这些key和value会永远存在于内存之中，占用大量内存。</div><div class="line"></div><div class="line">优化建议</div><div class="line"></div><div class="line">1. 不要存放大的key和value，会引起界面卡、频繁GC、占用内存等等。</div><div class="line">2. 毫不相关的配置项就不要放在在一起，文件越大读取越慢。</div><div class="line">3. 读取频繁的key和不易变动的key尽量不要放在一起，影响速度，如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失。</div><div class="line">4. 不要乱edit和apply，尽量批量修改一次提交，多次apply会阻塞主线程。</div><div class="line">5. 尽量不要存放JSON和HTML，这种场景请直接使用JSON。</div><div class="line">6. SharedPreference无法进行跨进程通信，MODE_MULTI_PROCESS只是保证了在API 11以前的系统上，如果sp已经被读取进内存，再次获取这个SharedPreference的时候，如果有这个flag，会重新读一遍文件，仅此而已。</div><div class="line"></div><div class="line">### 如何做SQLite升级？</div><div class="line"></div><div class="line">数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：</div><div class="line"></div><div class="line">1. 将现有表命名为临时表。</div><div class="line">2. 创建新表。</div><div class="line">3. 将临时表的数据导入新表。</div><div class="line">4. 删除临时表。</div><div class="line"></div><div class="line">重写</div><div class="line"></div><div class="line">如果是跨版本数据库升级，可以由两种方式，如下所示：</div><div class="line"></div><div class="line">1. 逐级升级，确定相邻版本与现在版本的差别，V1升级到V2,V2升级到V3，依次类推。</div><div class="line">2. 跨级升级，确定每个版本与现在数据库的差别，为每个case编写专门升级大代码。</div><div class="line"></div><div class="line">### 进程保护如何做，如何唤醒其他进程？</div><div class="line"></div><div class="line">进程保活主要有两个思路：</div><div class="line"></div><div class="line">1. 提升进程的优先级，降低进程被杀死的概率。</div><div class="line">2. 拉活已经被杀死的进程。</div><div class="line"></div><div class="line">如何提升优先级，如下所示：</div><div class="line"></div><div class="line">监控手机锁屏事件，在屏幕锁屏时启动一个像素的Activity，在用户解锁时将Activity销毁掉，前台Activity可以将进程变成前台进程，优先级升级到最高。</div><div class="line"></div><div class="line">如果拉活</div><div class="line"></div><div class="line">利用广播拉活Activity。</div><div class="line"></div><div class="line">### 理解序列化吗，Android为什么引入Parcelable？</div><div class="line"></div><div class="line">所谓序列化就是将对象变成二进制流，便于存储和传输。</div><div class="line"></div><div class="line">- Serializable是java实现的一套序列化方式，可能会触发频繁的IO操作，效率比较低，适合将对象存储到磁盘上的情况。</div><div class="line">- Parcelable是Android提供一套序列化机制，它将序列化后的字节流写入到一个共性内存中，其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息。</div><div class="line"></div><div class="line">### 如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？</div><div class="line"></div><div class="line">Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</div><div class="line"></div><div class="line">注：这里inDensity表示目标图片的dpi（放在哪个资源文件夹下），inTargetDensity表示目标屏幕的dpi，所以你可以发现inDensity和inTargetDensity会对Bitmap的宽高</div><div class="line">进行拉伸，进而改变Bitmap占用内存的大小。</div><div class="line"></div><div class="line">在Bitmap里有两个获取内存占用大小的方法。</div><div class="line"></div><div class="line">- getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。</div><div class="line">- getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 getByteCount() 方法。</div><div class="line"></div><div class="line">在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大</div><div class="line">小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。</div><div class="line"></div><div class="line">为了保证在加载Bitmap的时候不产生内存溢出，可以受用BitmapFactory进行图片压缩，主要有以下几个参数：</div><div class="line"></div><div class="line">- BitmapFactory.Options.inPreferredConfig：将ARGB_8888改为RGB_565，改变编码方式，节约内存。</div><div class="line">- BitmapFactory.Options.inSampleSize：缩放比例，可以参考Luban那个库，根据图片宽高计算出合适的缩放比例。</div><div class="line">- BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。</div><div class="line"></div><div class="line">### Android如何在不压缩的情况下加载高清大图？</div><div class="line"></div><div class="line">使用BitmapRegionDecoder进行布局加载。</div><div class="line"></div><div class="line">### Android里的内存缓存和磁盘缓存是怎么实现的。</div><div class="line"></div><div class="line">内存缓存基于LruCache实现，磁盘缓存基于DiskLruCache实现。这两个类都基于Lru算法和LinkedHashMap来实现。</div><div class="line"></div><div class="line">LRU算法可以用一句话来描述，如下所示：</div><div class="line"></div><div class="line">&gt;LRU是Least Recently Used的缩写，最近最久未使用算法，从它的名字就可以看出，它的核心原则是如果一个数据在最近一段时间没有使用到，那么它在将来被</div><div class="line">访问到的可能性也很小，则这类数据项会被优先淘汰掉。</div><div class="line"></div><div class="line">LruCache的原理是利用LinkedHashMap持有对象的强引用，按照Lru算法进行对象淘汰。具体说来假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。</div><div class="line">                                                      </div><div class="line">为什么会选择LinkedHashMap呢？</div><div class="line"></div><div class="line">这跟LinkedHashMap的特性有关，LinkedHashMap的构造函数里有个布尔参数accessOrder，当它为true时，LinkedHashMap会以访问顺序为序排列元素，否则以插入顺序为序排序元素。</div><div class="line"></div><div class="line">DiskLruCache与LruCache原理相似，只是多了一个journal文件来做磁盘文件的管理和迎神，如下所示：</div></pre></td></tr></table></figure><p>libcore.io.DiskLruCache<br>1<br>1<br>1</p><p>DIRTY 1517126350519<br>CLEAN 1517126350519 5325928<br>REMOVE 1517126350519<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注：这里的缓存目录是应用的缓存目录/data/data/pckagename/cache，未root的手机可以通过以下命令进入到该目录中或者将该目录整体拷贝出来：</div><div class="line"></div><div class="line">```java</div><div class="line"></div><div class="line">//进入/data/data/pckagename/cache目录</div><div class="line">adb shell</div><div class="line">run-as com.your.packagename </div><div class="line">cp /data/data/com.your.packagename/</div><div class="line"></div><div class="line">//将/data/data/pckagename目录拷贝出来</div><div class="line">adb backup -noapk com.your.packagename</div></pre></td></tr></table></figure></p><p>我们来分析下这个文件的内容：</p><ul><li>第一行：libcore.io.DiskLruCache，固定字符串。</li><li>第二行：1，DiskLruCache源码版本号。</li><li>第三行：1，App的版本号，通过open()方法传入进去的。</li><li>第四行：1，每个key对应几个文件，一般为1.</li><li>第五行：空行</li><li>第六行及后续行：缓存操作记录。</li></ul><p>第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以下三点：</p><ol><li>DIRTY 表示一个entry正在被写入。写入分两种情况，如果成功会紧接着写入一行CLEAN的记录；如果失败，会增加一行REMOVE记录。注意单独只有DIRTY状态的记录是非法的。</li><li>当手动调用remove(key)方法的时候也会写入一条REMOVE记录。</li><li>READ就是说明有一次读取的记录。</li><li>CLEAN的后面还记录了文件的长度，注意可能会一个key对应多个文件，那么就会有多个数字。</li></ol><h3 id="PathClassLoader与DexClassLoader有什么区别？"><a href="#PathClassLoader与DexClassLoader有什么区别？" class="headerlink" title="PathClassLoader与DexClassLoader有什么区别？"></a>PathClassLoader与DexClassLoader有什么区别？</h3><ul><li>PathClassLoader：只能加载已经安装到Android系统的APK文件，即/data/app目录，Android默认的类加载器。</li><li>DexClassLoader：可以加载任意目录下的dex、jar、apk、zip文件。</li></ul><h3 id="WebView优化了解吗，如何提高WebView的加载速度？"><a href="#WebView优化了解吗，如何提高WebView的加载速度？" class="headerlink" title="WebView优化了解吗，如何提高WebView的加载速度？"></a>WebView优化了解吗，如何提高WebView的加载速度？</h3><p>为什么WebView加载会慢呢？</p><blockquote><p>这是因为在客户端中，加载H5页面之前，需要先初始化WebView，在WebView完全初始化完成之前，后续的界面加载过程都是被阻塞的。</p></blockquote><p>优化手段围绕着以下两个点进行：</p><ol><li>预加载WebView。</li><li>加载WebView的同时，请求H5页面数据。</li></ol><p>因此常见的方法是：</p><ol><li>全局WebView。</li><li>客户端代理页面请求。WebView初始化完成后向客户端请求数据。</li><li>asset存放离线包。</li></ol><p>除此之外还有一些其他的优化手段：</p><ul><li>脚本执行慢，可以让脚本最后运行，不阻塞页面解析。</li><li>DNS与链接慢，可以让客户端复用使用的域名与链接。</li><li>React框架代码执行慢，可以将这部分代码拆分出来，提前进行解析。</li></ul><h3 id="Java和JS的相互调用怎么实现，有做过什么优化吗？"><a href="#Java和JS的相互调用怎么实现，有做过什么优化吗？" class="headerlink" title="Java和JS的相互调用怎么实现，有做过什么优化吗？"></a>Java和JS的相互调用怎么实现，有做过什么优化吗？</h3><p>jockeyjs：<a href="https://github.com/tcoulter/jockeyjs" target="_blank" rel="external">https://github.com/tcoulter/jockeyjs</a></p><p>对协议进行统一的封装和处理。</p><h3 id="JNI了解吗，Java与C-如何相互调用？"><a href="#JNI了解吗，Java与C-如何相互调用？" class="headerlink" title="JNI了解吗，Java与C++如何相互调用？"></a>JNI了解吗，Java与C++如何相互调用？</h3><p>Java调用C++</p><ol><li>在Java中声明Native方法（即需要调用的本地方法）</li><li>编译上述 Java源文件javac（得到 .class文件）</li><li>通过 javah 命令导出JNI的头文件（.h文件）</li><li>使用 Java需要交互的本地代码 实现在 Java中声明的Native方法 </li><li>编译.so库文件</li><li>通过Java命令执行 Java程序，最终实现Java调用本地代码</li></ol><p>C++调用Java</p><ol><li>从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。</li><li>获取类的默认构造方法ID。</li><li>查找实例方法的ID。</li><li>创建该类的实例。</li><li>调用对象的实例方法。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod</span>  </span></div><div class="line"><span class="params">(JNIEnv *env, jclass cls)</span>  </div><div class="line">&#123;  </div><div class="line">    jclass clazz = <span class="literal">NULL</span>;  </div><div class="line">    jobject jobj = <span class="literal">NULL</span>;  </div><div class="line">    jmethodID mid_construct = <span class="literal">NULL</span>;  </div><div class="line">    jmethodID mid_instance = <span class="literal">NULL</span>;  </div><div class="line">    jstring str_arg = <span class="literal">NULL</span>;  </div><div class="line">    <span class="comment">// 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  </span></div><div class="line">    clazz = (*env)-&gt;FindClass(env, <span class="string">"com/study/jnilearn/ClassMethod"</span>);  </div><div class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"找不到'com.study.jnilearn.ClassMethod'这个类"</span>);  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 2、获取类的默认构造方法ID  </span></div><div class="line">    mid_construct = (*env)-&gt;GetMethodID(env,clazz, <span class="string">"&lt;init&gt;"</span>,<span class="string">"()V"</span>);  </div><div class="line">    <span class="keyword">if</span> (mid_construct == <span class="literal">NULL</span>) &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"找不到默认的构造方法"</span>);  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 3、查找实例方法的ID  </span></div><div class="line">    mid_instance = (*env)-&gt;GetMethodID(env, clazz, <span class="string">"callInstanceMethod"</span>, <span class="string">"(Ljava/lang/String;I)V"</span>);  </div><div class="line">    <span class="keyword">if</span> (mid_instance == <span class="literal">NULL</span>) &#123;  </div><div class="line"></div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 4、创建该类的实例  </span></div><div class="line">    jobj = (*env)-&gt;NewObject(env,clazz,mid_construct);  </div><div class="line">    <span class="keyword">if</span> (jobj == <span class="literal">NULL</span>) &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法"</span>);  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 5、调用对象的实例方法  </span></div><div class="line">    str_arg = (*env)-&gt;NewStringUTF(env,<span class="string">"我是实例方法"</span>);  </div><div class="line">    (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,<span class="number">200</span>);  </div><div class="line"></div><div class="line">    <span class="comment">// 删除局部引用  </span></div><div class="line">    (*env)-&gt;DeleteLocalRef(env,clazz);  </div><div class="line">    (*env)-&gt;DeleteLocalRef(env,jobj);  </div><div class="line">    (*env)-&gt;DeleteLocalRef(env,str_arg);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"><a href="#了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？" class="headerlink" title="了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"></a>了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？</h3><ul><li>插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。</li><li>热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。</li></ul><p>利用PathClassLoader和DexClassLoader去加载与bug类同名的类，替换掉bug类，进而达到修复bug的目的，原理是在app打包的时候阻止类打上CLASS_ISPREVERIFIED标志，然后在<br>热修复的时候动态改变BaseDexClassLoader对象间接引用的dexElements，替换掉旧的类。</p><p>目前热修复框架主要分为两大类：</p><ul><li>Sophix：修改方法指针。</li><li>Tinker：修改dex数组元素。</li></ul><h3 id="如何做性能优化？"><a href="#如何做性能优化？" class="headerlink" title="如何做性能优化？"></a>如何做性能优化？</h3><ol><li>节制的使用Service，当启动一个Service时，系统总是倾向于保留这个Service依赖的进程，这样会造成系统资源的浪费，可以使用IntentService，执行完成任务后会自动停止。</li><li>当界面不可见时释放内存，可以重写Activity的onTrimMemory()方法，然后监听TRIM_MEMORY_UI_HIDDEN这个级别，这个级别说明用户离开了页面，可以考虑释放内存和资源。</li><li>避免在Bitmap浪费过多的内存，使用压缩过的图片，也可以使用Fresco等库来优化对Bitmap显示的管理。</li><li>使用优化过的数据集合SparseArray代替HashMap，HashMap为每个键值都提供一个对象入口，使用SparseArray可以免去基本对象类型转换为引用数据类想的时间。</li></ol><h3 id="如果防止过度绘制，如何做布局优化？"><a href="#如果防止过度绘制，如何做布局优化？" class="headerlink" title="如果防止过度绘制，如何做布局优化？"></a>如果防止过度绘制，如何做布局优化？</h3><ol><li>使用include复用布局文件。</li><li>使用merge标签避免嵌套布局。</li><li>使用stub标签仅在需要的时候在展示出来。</li></ol><h3 id="如何提交代码质量？"><a href="#如何提交代码质量？" class="headerlink" title="如何提交代码质量？"></a>如何提交代码质量？</h3><ol><li>避免创建不必要的对象，尽可能避免频繁的创建临时对象，例如在for循环内，减少GC的次数。</li><li>尽量使用基本数据类型代替引用数据类型。</li><li>静态方法调用效率高于动态方法，也可以避免创建额外对象。</li><li>对于基本数据类型和String类型的常量要使用static final修饰，这样常量会在dex文件的初始化器中进行初始化，使用的时候可以直接使用。</li><li>多使用系统API，例如数组拷贝System.arrayCopy()方法，要比我们用for循环效率快9倍以上，因为系统API很多都是通过底层的汇编模式执行的，效率比较高。</li></ol><h3 id="有没有遇到64k问题，为什么，如何解决？"><a href="#有没有遇到64k问题，为什么，如何解决？" class="headerlink" title="有没有遇到64k问题，为什么，如何解决？"></a>有没有遇到64k问题，为什么，如何解决？</h3><ul><li>在DEX文件中，method、field、class等的个数使用short类型来做索引，即两个字节（65535），method、field、class等均有此限制。</li><li>APK在安装过程中会调用dexopt将DEX文件优化成ODEX文件，dexopt使用LinearAlloc来存储应用信息，关于LinearAlloc缓冲区大小，不同的版本经历了4M/8M/16M的限制，超出<br>缓冲区时就会抛出INSTALL_FAILED_DEXOPT错误。</li></ul><p>解决方案是Google的MultiDex方案，具体参见：<a href="https://developer.android.com/studio/build/multidex.html?hl=zh-cn" target="_blank" rel="external">配置方法数超过 64K 的应用</a>。</p><h3 id="MVC、MVP与MVVM之间的对比分析？"><a href="#MVC、MVP与MVVM之间的对比分析？" class="headerlink" title="MVC、MVP与MVVM之间的对比分析？"></a>MVC、MVP与MVVM之间的对比分析？</h3><p><img src="https://github.com/BeesAndroid/BeesAndroid/blob/master/art/practice/project/module/mvp_structure.png"></p><ul><li>MVC：PC时代就有的架构方案，在Android上也是最早的方案，Activity/Fragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到<br>耦合过重，Activity/Fragment类过大等问题。</li><li>MVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。</li><li>MVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是<br>一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享View<br>Model数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础汇总</title>
    <link href="https://edward7zhang.github.io/2018/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/"/>
    <id>https://edward7zhang.github.io/2018/03/30/计算机网络基础汇总/</id>
    <published>2018-03-30T02:43:13.000Z</published>
    <updated>2018-04-16T06:43:14.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络体系分类："><a href="#计算机网络体系分类：" class="headerlink" title="计算机网络体系分类："></a>计算机网络体系分类：</h1><p>计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。</p><table><thead><tr><th>OSI七层模型</th><th>TCP/IP四层模型</th></tr></thead><tbody><tr><td>应用层</td><td>—-</td></tr><tr><td>表示层</td><td>应用层</td></tr><tr><td>会话层</td><td>—-</td></tr><tr><td>传输层</td><td>传输层</td></tr><tr><td>网络层</td><td>网络层</td></tr><tr><td>数据链路层</td><td>物理接入层</td></tr><tr><td>物理层</td><td>—-</td></tr></tbody></table><h1 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h1><p>物理层主要是实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p><h2 id="通信方式："><a href="#通信方式：" class="headerlink" title="通信方式："></a>通信方式：</h2><ul><li><p><strong>单工通信：</strong>只能由A主机向B主机发送消息，通信是单向的。</p></li><li><p><strong>半双工通信：</strong>同一时间只能是由A主机向B主机或者是B主机向A主机发送信息，不能同时发送消息。</p></li><li><p><strong>全双工通信：</strong> A主机和B主机可以实现在同一时间内既接收消息，又发送消息，极大的提升了通信效率。</p></li></ul><h2 id="常见引导型传输媒体："><a href="#常见引导型传输媒体：" class="headerlink" title="常见引导型传输媒体："></a>常见引导型传输媒体：</h2><h3 id="双绞线："><a href="#双绞线：" class="headerlink" title="双绞线："></a>双绞线：</h3><p>分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP），屏蔽双绞线就是在非屏蔽双绞线外边又加了一层屏蔽层</p><p>tips：为什么双绞线要两根线绞起来，两个线绞起来可以有效的减少相互之间的电磁干扰。</p><h3 id="同轴电缆："><a href="#同轴电缆：" class="headerlink" title="同轴电缆："></a>同轴电缆：</h3><p>由内导体铜制芯线，绝缘层，网状编织的外导体屏蔽层，以及塑料保护外层组成。有良好的抗干扰性，被广泛用于较高速率的传输。</p><h3 id="光缆："><a href="#光缆：" class="headerlink" title="光缆："></a>光缆：</h3><p>由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通讯柱。可以分为单模光纤和多模光纤。</p><h2 id="信道复用技术："><a href="#信道复用技术：" class="headerlink" title="信道复用技术："></a>信道复用技术：</h2><ul><li><p><strong>频分复用：</strong>根据传输的波的频率的不同，将不同频段的波用于不同的通信。</p></li><li><p><strong>时分复用：</strong>将时间分割为时间段，规定在某个时间段内发送什么样的信息，根据时间段来进行信息类别的区分。也称为<strong>同步时分复用</strong></p></li><li><p><strong>统计时分复用：</strong>基于时分复用的一种改进，由于基本的时分复用并没有考虑到每个时间段内是否有信息发出，例如说每个时间段是20，但是发送消息只占用其中的2，那么剩下的18就处于空闲时间。统计时分复用就是基于这种考虑而设计的，他允许用户有数据时就将数据发送到缓存中，然后会依次扫描输入缓存，把缓存中的数据放入到STMD帧中，若没有就跳过，每当一个帧满了就把这个帧发出去。STMD帧不是分配的固定时序，而是根据需要动态的分配时隙，也称之为<strong>异步时分复用</strong></p></li><li><p>光分复用：就是光的频分复用，根据光谱中频率的不同，用不同频率的光来携带不同的信息。</p></li></ul><h1 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h1><p>数据链路层主要是将上层的数据转化为数据帧发送到链路上，以及把接受到的帧中的数据取出并交给网络层。</p><h2 id="通信方式：-1"><a href="#通信方式：-1" class="headerlink" title="通信方式："></a>通信方式：</h2><ul><li><p><strong>点对点通信：</strong>通信方式是点到点的，也就是只能是两个点之间的通信。常见的就是PPP协议</p></li><li><p><strong>广播通信：</strong>广播通讯，也就是可以同时实现一对多的通信。常见的就是CSMA/CD（载波监听多点访问/冲突检测）</p></li></ul><h2 id="核心要解决的问题："><a href="#核心要解决的问题：" class="headerlink" title="核心要解决的问题："></a>核心要解决的问题：</h2><ul><li><p><strong>封装成帧：</strong>在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在接受到后就可以方便准确的确定帧的首尾，也称为帧定界符。同时定义出了最大传输单元（MTU）–表示一次可以传输的最大长度上限。</p></li><li><p><strong>透明传输：</strong> 由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的转义字符，这种方法称为字符填充或者是字节填充。</p></li><li><p><strong>差错检测：</strong> 比特在传输过程中可能产生差错，差错检测就是用于检测出现的差错，以便及时的重传，最常用的差错检测算法就是<a href="http://baike.sogou.com/v7730112.htm?fromTitle=CRC%E6%A0%A1%E9%AA%8C" target="_blank" rel="external">CRC（循环冗余检验）</a></p></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层主要是向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。</p><h2 id="IP协议（网际协议）："><a href="#IP协议（网际协议）：" class="headerlink" title="IP协议（网际协议）："></a>IP协议（网际协议）：</h2><p>IP协议是TCP/IP体系中最主要的协议之一，一切在IP之下，一切又在IP之上。我们常说的应该是IP协议族，还包含配套的协议：</p><ul><li><p>ARP（地址解析协议）：将网络的IP地址转化为实际的物理地址（MAC地址），并存储在MAC地址表中。</p></li><li><p>ICMP（网际控制报文协议）：用于进行差错情况和异常情况的反馈，分为询问报文和差错报告报文。</p></li><li><p>IGMP（网际组管理协议）：用于控制和管理多播和组播的协议。</p></li></ul><p>网络地址（IP地址）主要分为五类：</p><ul><li><p>A类：前8位为网络位，后24位为主机位，首位为0</p></li><li><p>B类：前16位为网络位，后16位为主机位，前两位为10</p></li><li><p>C类：前24位为网络位，后8位位主机位，前三位为110</p></li><li><p>D类：前四位为1110，用于多播地址</p></li><li><p>E类：前四位为1111，保留为以后使用</p></li></ul><h2 id="路由选择协议："><a href="#路由选择协议：" class="headerlink" title="路由选择协议："></a>路由选择协议：</h2><p>路由选择协议分为<strong>内部网关协议（IGP）</strong>和<strong>外部网关协议（EGP）</strong></p><h3 id="内部网关协议："><a href="#内部网关协议：" class="headerlink" title="内部网关协议："></a>内部网关协议：</h3><p>主要是有RIP协议和OSPF协议</p><ul><li><p><strong>RIP协议（路由信息协议）：</strong>基于距离矢量的协议</p></li><li><p><strong>OSPF（开放最短路径优先协议）：</strong>基于链路状态的协议</p></li></ul><h3 id="外部网关协议："><a href="#外部网关协议：" class="headerlink" title="外部网关协议："></a>外部网关协议：</h3><p>主要是<strong>边界网关协议（BGP）</strong>，将一个大的网络分为多个小的自治域，每个自治域内有一个网关路由负责和其他的自治域的网关进行通讯。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>网络层主要是为主机之间提供逻辑通讯，而传输层为应用程序之间提供端到端的逻辑通讯。主要是两种类型的通讯方式，面向连接的TCP协议和面向无连接的UDP。</p><h2 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h2><p>端口号按照使用地方的不同分为两大类：服务端端口号，客户端端口号。<br>按照占用时长又可以分为熟知端口号（0~1023），登记端口号（1024~49151），短暂端口号（49152~65535）</p><h3 id="常见端口："><a href="#常见端口：" class="headerlink" title="常见端口："></a>常见端口：</h3><ul><li><p>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制</p></li><li><p>Telnet（远程登录协议）：23 </p></li><li><p>DNS（域名解析服务）：53</p></li><li><p>TFTP（简单文件传输协议）：69</p></li><li><p>HTTP（超文本传输协议）：80</p></li></ul><h2 id="两种协议："><a href="#两种协议：" class="headerlink" title="两种协议："></a>两种协议：</h2><ul><li><p><strong>UDP（用户数据报协议）：</strong> </p><ul><li>UDP是无连接的</li><li>UDP使用尽最大努力交付，但是不保证可靠交付</li><li>UDP是面向报文的</li><li>UDP没有拥塞控制</li><li>UDP支持一对一，一对多，多对一，多对一的交互通讯</li><li>UDP首部的开销小</li></ul></li><li><p><strong>TCP（传输控制协议）：</strong></p><ul><li>TCP是面向连接的</li><li>每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的$TCP连接：：= { socket_1,socket_2 } ={ (IP_1:port_1),(IP_2:port_2)}$</li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信</li><li>面向字节流</li></ul></li></ul><h3 id="可靠传输的实现机制："><a href="#可靠传输的实现机制：" class="headerlink" title="可靠传输的实现机制："></a>可靠传输的实现机制：</h3><ul><li><p><strong>停止等待协议：</strong> 每发完一个分组就停止发送，直到收到上一个分组的确认信息。若超过规定时间没有接收到确认信息，边认为是分组丢失，开始重传。</p></li><li><p><strong>连续ARQ协议：</strong>  发送方采用滑动窗口的形式，处于滑动窗口的分组可以直接发送出去；接收方一般采用累积确认的方式，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认，而发送方每接收到一个确认，窗口就向前滑动一定距离。</p></li><li><p><strong>流量控制：</strong>协调发送方和接收方的收发速率，利用滑动窗口来协调，使用探测报文来探测当前应该发送的速率，采用<a href="http://baike.sogou.com/v10500918.htm?fromTitle=Nagle%E7%AE%97%E6%B3%95" target="_blank" rel="external">Nagle算法</a></p></li><li><p><strong>拥塞控制：</strong><br>当网络中某一资源的需求超出了该资源所能提供的可用部分，这时网络的性能就要开始变坏，这种情况就叫做拥塞。而拥塞控制就是为了减少或者避免拥塞对网络性能的影响而做出的一种控制手段。</p><ul><li><p><strong>拥塞控制思路：</strong>发送方维持一个叫做<strong>拥塞窗口</strong>的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化。发送方让自己的发送窗口等于拥塞窗口，如果在考虑接收方的接收能力，一般发送窗口还要小于拥塞窗口。</p></li><li><p><strong>慢开始：</strong>当主机开始发送数据的时候，由小到大的增大发送窗口，也就是由小到大的增大拥塞窗口。接收方接收到一个报文之后就回传一个确认报文，发送方每接收到一个确认报文，就将拥塞窗口加1，这样每经过一个传输轮次之后，拥塞窗口就增大一倍。</p></li><li><p><strong>拥塞避免：</strong>思路是让拥塞窗口缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，而不是加倍，这样拥塞窗口就是线性缓慢增加，比慢开始的增长速率缓慢的多。</p></li><li><p><strong>慢开始门限：</strong>为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限</p><ul><li>拥塞窗口&lt;慢开始门限时，使用慢开始算法</li><li>拥塞窗口&gt;慢开始门限时，使用拥塞避免算法</li><li>拥塞窗口=慢开始门限时，两种算法都可以</li></ul></li><li><p><strong>快重传：</strong>要求收到方每收到一个时序的报文段之后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。而发送方只要一连收到三个重复确认就应当立即重传对方尚未接受到的报文，而不必等待为报文设置的重传计时器到期。 </p></li><li><p><strong>快回复：</strong>与快重传配合使用，当发送方连续收到三个重复确认的时候，就执行“乘法减小”算法，将慢开始门限减半。将拥塞窗口设置为慢开始门限减半之后的值，并开始指向拥塞避免算法。</p></li></ul></li></ul><h3 id="TCP的连接管理："><a href="#TCP的连接管理：" class="headerlink" title="TCP的连接管理："></a>TCP的连接管理：</h3><h4 id="连接三次握手："><a href="#连接三次握手：" class="headerlink" title="连接三次握手："></a>连接三次握手：</h4><ol><li>客户端请求建立连接：SYN=1，seq=x；</li><li>服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1</li><li>客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1</li></ol><p><strong>注：</strong> SYN为同步信息，在建立连接过程中始终为1</p><h4 id="断开连接四次握手："><a href="#断开连接四次握手：" class="headerlink" title="断开连接四次握手："></a>断开连接四次握手：</h4><ol><li>客户端请求断开连接： FIN=1，seq = u；</li><li>服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1；</li><li>服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1；</li><li>客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1；</li></ol><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层有多种协议，常用到的就是HTTP以及HTTPS。</p><p><strong>HTTP协议报文格式</strong></p><table><thead><tr><th>请求报文</th><th>相应报文</th></tr></thead><tbody><tr><td>请求行（用于区分是请求报文还是响应报文，在响应报文中为状态行）</td><td>状态行</td></tr><tr><td>首部行（用来说明浏览器，服务器或者是报文主体的一些信息）</td><td>首部行</td></tr><tr><td>空行（用于隔开请求实体和首部行）</td><td>空行</td></tr><tr><td>实体主体（用于一些请求或者是响应的的参数内容等）</td><td>实体主体</td></tr></tbody></table><p><strong>常见状态码</strong></p><blockquote><p>1xx：表示通知信息，例如表示收到或者是正在处理<br>2xx：表示成功，例如表示接受或知道了<br>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动<br>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成<br>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p></blockquote><p>HTTPS协议就是对HTTP协议的加密，更加安全可靠，采用HTTP+SSL（安全套接字层）来保证数据的安全性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络体系分类：&quot;&gt;&lt;a href=&quot;#计算机网络体系分类：&quot; class=&quot;headerlink&quot; title=&quot;计算机网络体系分类：&quot;&gt;&lt;/a&gt;计算机网络体系分类：&lt;/h1&gt;&lt;p&gt;计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是
      
    
    </summary>
    
    
      <category term="Network" scheme="https://edward7zhang.github.io/tags/Network/"/>
    
  </entry>
  
</feed>
