<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EdwardZhang&#39;s Blog</title>
  
  <subtitle>Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://edward7zhang.github.io/"/>
  <updated>2019-03-03T05:19:31.272Z</updated>
  <id>https://edward7zhang.github.io/</id>
  
  <author>
    <name>EdwardZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Retrofit2.0 使用教程（与常见网络请求库对比）</title>
    <link href="https://edward7zhang.github.io/2019/03/03/Retrofit2.0%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
    <id>https://edward7zhang.github.io/2019/03/03/Retrofit2.0 使用教程（与常见网络请求库对比）/</id>
    <published>2019-03-03T04:07:14.000Z</published>
    <updated>2019-03-03T05:19:31.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在<strong>Android</strong>开发中，网络请求十分常用</li><li>当下的网络请求加载库中，<strong>Retrofit</strong>则是当下hottest的一个网络请求库</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-a3109ad0446b0540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>特别注意：</p><ul><li>准确来说，<strong>Retrofit是一个 RESTful 的 HTTP 网络请求框架的封装</strong></li><li>原因：网络请求的工作本质上是<code>OkHttp</code>完成的，而<code>Retrofit</code>仅负责网络请求接口的封装<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-b5194f1d16673589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>App应用程序通过 Retrofit 请求网络，实际上是使用Retrofit接口层封装请求参数、Header、Url等信息，之后由OkHttp完成后续的请求操作</li><li>在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析</li></ul><h1 id="与其他开源库对比"><a href="#与其他开源库对比" class="headerlink" title="与其他开源库对比"></a>与其他开源库对比</h1><p>除了 Retrofit，如今 Android 中主流的网络请求框架有：</p><ul><li>Android-Async-Http</li><li>Volly</li><li>OkHttp<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-3089d23889f04d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="介绍" title="">                </div>                <div class="image-caption">介绍</div>            </figure></li></ul><p>几种网络请求库之间的区别对比<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/944365-58819416dfd2767a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>附：各个主流网络请求库的 Github 地址</p><ul><li><a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">Android-Async-Http</a></li><li><a href="https://github.com/stormzhang/AndroidVolley" target="_blank" rel="external">Volley</a></li><li><a href="https://github.com/square/okhttp" target="_blank" rel="external">OkHttp</a></li><li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a></li></ul><h1 id="Retrofit使用介绍"><a href="#Retrofit使用介绍" class="headerlink" title="Retrofit使用介绍"></a>Retrofit使用介绍</h1><p>使用Retrofit的步骤共有7个：</p><pre><code>步骤1：添加 Retrofit 库的依赖步骤2：创建 接受服务器返回数据 的类步骤3：创建 用于描述网络请求 的接口步骤4：创建 Retrofit 实例步骤5：创建 网络请求接口实例 并 配置网络请求参数步骤6：发送网络请求（异步\同步）    &gt; 封装了 数据转换、线程切换的操作步骤7：处理服务器返回的数据</code></pre><p>接下来我们将这些步骤进行分解</p><h2 id="步骤1：添加-Retrofit-库的依赖"><a href="#步骤1：添加-Retrofit-库的依赖" class="headerlink" title="步骤1：添加 Retrofit 库的依赖"></a>步骤1：添加 Retrofit 库的依赖</h2><h3 id="1-在Gradle加入Retrofit库的依赖"><a href="#1-在Gradle加入Retrofit库的依赖" class="headerlink" title="1.在Gradle加入Retrofit库的依赖"></a>1.在<code>Gradle</code>加入<code>Retrofit</code>库的依赖</h3><blockquote><p>由于<code>Retrofit</code>是基于<code>OkHttp</code>，所以还需要添加<code>OkHttp</code>库依赖</p></blockquote><p><em>build.gradle</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123; </div><div class="line">  compile&apos;com.squareup.retrofit2:retrofit:2.0.2&apos;  </div><div class="line">  // Retrofit库 </div><div class="line">  compile &apos;com.squareup.okhttp3:okhttp:3.1.2&apos;  </div><div class="line">  // Okhttp库 </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-添加-网络权限"><a href="#2-添加-网络权限" class="headerlink" title="2.添加 网络权限"></a>2.添加 网络权限</h3><p><em>AndroidManifest.xml</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</div></pre></td></tr></table></figure><h2 id="步骤2：创建-接受服务器返回数据-的类"><a href="#步骤2：创建-接受服务器返回数据-的类" class="headerlink" title="步骤2：创建 接受服务器返回数据 的类"></a>步骤2：创建 接受服务器返回数据 的类</h2><p><em>Reception.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reception</span></span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">//根据返回数据的格式和数据解析方式（Json、XML等）定义</span></div><div class="line">  <span class="comment">//下面会在实例中进行说明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="步骤3：创建-用于描述网络请求-的接口"><a href="#步骤3：创建-用于描述网络请求-的接口" class="headerlink" title="步骤3：创建 用于描述网络请求 的接口"></a>步骤3：创建 用于描述网络请求 的接口</h2><ul><li>Retrofit将Http请求抽象成Java接口：采用<strong>注解</strong>描述网络请求的参数 和 配置网络请求参数</li></ul><blockquote><p>1.用 动态代理 动态 将该接口的注解“翻译”成一个Http请求，最后再执行Http请求<br>2.注：接口中的每个方法的参数都需要使用注解标注，否则会报错</p></blockquote><p><em>GetRequest__Interface.interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span></span>&#123;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>)</div><div class="line">    <span class="function">Call&lt;Translation&gt; <span class="title">getCall</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//@GET注解的作用：采用Get方法发送网络请求</span></div><div class="line">    <span class="comment">//getCall() = 接受网络请求数据的方法</span></div><div class="line">    <span class="comment">//其中返回类型为Call&lt;*&gt;,*是接收数据的类（即上面定义的Translation类）</span></div><div class="line">    <span class="comment">//如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="步骤4：创建-Retrofit-实例"><a href="#步骤4：创建-Retrofit-实例" class="headerlink" title="步骤4：创建 Retrofit 实例"></a>步骤4：创建 Retrofit 实例</h2><h2 id="步骤5：创建-网络请求接口实例-并-配置网络请求参数"><a href="#步骤5：创建-网络请求接口实例-并-配置网络请求参数" class="headerlink" title="步骤5：创建 网络请求接口实例 并 配置网络请求参数"></a>步骤5：创建 网络请求接口实例 并 配置网络请求参数</h2><h2 id="步骤6：发送网络请求（异步-同步）"><a href="#步骤6：发送网络请求（异步-同步）" class="headerlink" title="步骤6：发送网络请求（异步\同步）"></a>步骤6：发送网络请求（异步\同步）</h2><h2 id="步骤7：处理服务器返回的数据"><a href="#步骤7：处理服务器返回的数据" class="headerlink" title="步骤7：处理服务器返回的数据"></a>步骤7：处理服务器返回的数据</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;Android&lt;/strong&gt;开发中，网络请求十分常用&lt;/li&gt;
&lt;li&gt;当下的网络请求加载库中，&lt;stro
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记一道简单的Java面试题【转载自 知乎——方志宏】</title>
    <link href="https://edward7zhang.github.io/2019/03/01/%E8%AE%B0%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://edward7zhang.github.io/2019/03/01/记一道简单的Java面试题/</id>
    <published>2019-03-01T11:07:14.000Z</published>
    <updated>2019-03-01T08:35:17.911Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是历史上最简单的一道java面试题了。</p><p>题目很简单，完成代码，判断一个整数是否是奇数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span></span></div></pre></td></tr></table></figure><p>相信相当数量的人都已经在准备吐槽了，只要看过《编程珠玑》的人都知道这道题的答案和其中极为简单的道理。不过别着急骂街，不管你信不信，这道笔试题我拿到的答案好多都长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"是奇数"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"是偶数"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后编译一下，发现错误了，挠挠头，顶多改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好吧，我承认我在筛选简历的能力可能有一些问题，不过不管你信不信，好多大厂工作了几年的程序员，都会写出如上风格的代码。</p><p>于是我继续进行引导：</p><p>我：“这个函数的定义要求返回一个什么类型的值？”</p><p>候选人看了看题干：“布尔类型。”</p><p>我：“那么，你if后面的括号里面的表达式的值是一个什么类型的？”</p><p>引导到这一步的时候，依然有高达两成的候选人选择了放弃，表示他们不知道。好吧，我真的不知道你们来面试这个职位的信心何在。不过大部分人想了想，还会回答出正确答案：</p><p>候选人：“也是布尔类型。”</p><p>我：“然后呢？”</p><p>有少量候选人虽然没说出来，但是我能看出来他们觉得这只是一个巧合，并不知道怎么进行下一步。不过，大多数人想了想之后，还是会优化成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>终于过了第一关了，进行第二关的引导：</p><p>我：“那我传进来一个-1呢？”</p><p>将近一半的人在想了想之后会嘴硬地表示他们从小被教导只有自然数才有奇数偶数之分，负数没有奇偶这一说。剩余的人接受了这个设定，想了一会儿，改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span> || i % <span class="number">2</span> == -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>并且在提示之后优化成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好吧，这是迄今为止第一个能通过编译且完全满足了需求的代码实现了。说实话，一开始就写成这样的人，如果没有其他什么明显的缺点的话，我这里基本就能通过了。我承认我的要求比较低，但是来面试的人能直接写出这样的真的不太多，粗略地估计的话，大概占一到两成吧。</p><p>但是这里还没完呢，还有最重要的第三关呢：</p><p>我：“有更好的办法吗？”</p><p>候选人：“？”</p><p>我：“我觉得取模操作比较慢，有更快的解决方案吗？”</p><p>除了少数人能自己想想就想出来了之外，绝大部分（毫不夸张）候选人表示没有或者不知道，于是进行下一步提示：</p><p>我：“奇数和偶数转换成二进制有什么区别？”</p><p>相当一部分候选人表示自己不懂什么叫二进制和位运算，有的还表示java不是c语言，不用研究这些，就跟很多评论会吐槽我在装逼一样。少部分候选人想了想，会怯怯地回答。</p><p>候选人：“奇数最后一位是1，偶数最后一位是0。”</p><p>我：“然后呢？”</p><p>这里很奇怪的点是，大部分能聊到这里来的候选人会想起来移位操作，我真的不知道是为什么，虽然这道题确实可以有这种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i &gt;&gt; <span class="number">1</span> &lt;&lt; <span class="number">1</span> != i;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是这根本不是重点好吧！！！</p><p>总之，无论如何，能在第三关的各种引导之后，能写出下面这个结果来的人，真的不多。能一开始没有任何引导的就写出来的人，至今只见过两个，一个我去哪儿都带着，一个拒了我的offer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (i &amp; <span class="number">1</span>) == <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>别以为这就完了！终极boss来了：</p><p>我：“这样是不是比上面取模运算要快？”</p><p>候选人：“那当然了，位运算肯定快啊。”</p><p>我：“但是我们实际代码测试过，发现上面的按位与操作和取模操作，实际运行的时间是差不多的，为什么呢？”</p><p>候选人心里mmp：“闹了半天你这是在逗我玩啊？？？”</p><p>然而真正能回答出原因来的人，面试过程中我没见过，可能是大牛都看不上我所在的公司吧。只有在某公司的时候，一个同事想了想，给出了我正确答案：“编译器会将对2的指数的取模操作，优化成位运算操作。”</p><p>难道是我经历的公司都太low了么……</p><p>作者：方志宏<br>链接：<a href="https://zhuanlan.zhihu.com/p/57859872" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/57859872</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这可能是历史上最简单的一道java面试题了。&lt;/p&gt;
&lt;p&gt;题目很简单，完成代码，判断一个整数是否是奇数：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;l
      
    
    </summary>
    
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance【一面总结】</title>
    <link href="https://edward7zhang.github.io/2019/02/18/ByteDance%E3%80%90%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93%E3%80%91/"/>
    <id>https://edward7zhang.github.io/2019/02/18/ByteDance【一面总结】/</id>
    <published>2019-02-18T11:07:14.000Z</published>
    <updated>2019-03-02T14:28:47.932Z</updated>
    
    <content type="html"><![CDATA[<p>大概在数天前投递了字节跳动-抖音方向的实习生岗位<br>昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题）</p><h2 id="1-Java中的引用类型有没有什么了解？"><a href="#1-Java中的引用类型有没有什么了解？" class="headerlink" title="1.Java中的引用类型有没有什么了解？"></a>1.Java中的引用类型有没有什么了解？</h2><p>Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类。</p><pre><code>StrongReference（强引用）SoftReference（软引用）WeakReference（弱引用）PhantomReference（虚引用）</code></pre><h3 id="引用类型对比"><a href="#引用类型对比" class="headerlink" title="引用类型对比"></a>引用类型对比</h3><table><thead><tr><th>序号</th><th>引用类型</th><th>取得目标对象方式</th><th>垃圾回收条件</th><th>是否可能内存泄漏</th></tr></thead><tbody><tr><td>1</td><td>强引用</td><td>直接调用</td><td>不回收</td><td>可能</td></tr><tr><td>2</td><td>软引用</td><td>通过 get()方法</td><td>视内存情况回收</td><td>不可能</td></tr><tr><td>3</td><td>弱引用</td><td>通过 get()方法</td><td>永远回收</td><td>不可能</td></tr><tr><td>4</td><td>虚引用</td><td>无法取得</td><td>不回收</td><td>可能</td></tr></tbody></table><h4 id="1-StrongReference（强引用）"><a href="#1-StrongReference（强引用）" class="headerlink" title="1.StrongReference（强引用）"></a>1.StrongReference（强引用）</h4><p>如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</div></pre></td></tr></table></figure><h4 id="2-SoftReference（软引用）"><a href="#2-SoftReference（软引用）" class="headerlink" title="2.SoftReference（软引用）"></a>2.SoftReference（软引用）</h4><p>如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h4 id="3-WeakReference（弱引用）"><a href="#3-WeakReference（弱引用）" class="headerlink" title="3.WeakReference（弱引用）"></a>3.WeakReference（弱引用）</h4><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>    弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>    <br><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example1</span></div><div class="line">WeakReference&lt;String[]&gt; weakBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</div><div class="line"><span class="comment">//Example2</span></div><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">WeakReference&lt;String[]&gt; softBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h4 id="4-PhantomReference（虚引用）"><a href="#4-PhantomReference（虚引用）" class="headerlink" title="4.PhantomReference（虚引用）"></a>4.PhantomReference（虚引用）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</div><div class="line">PhantomReference&lt;String[]&gt; referent = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</div></pre></td></tr></table></figure></p><h2 id="2-Java中创建线程的方式有哪些"><a href="#2-Java中创建线程的方式有哪些" class="headerlink" title="2.Java中创建线程的方式有哪些"></a>2.Java中创建线程的方式有哪些</h2><h3 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h3><pre><code>(1) 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。(2) 创建Thread子类的实例，即创建了线程对象。(3) 调用线程对象的start()方法来启用该线程。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">FirstThreadTest</span>  <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</div><div class="line"><span class="keyword">int</span>  i  =  <span class="number">0</span>; <span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">System.out.println(getName() +  <span class="string">" "</span>  + i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i  =  <span class="number">0</span>; i &lt;  <span class="number">100</span>; i++) &#123;</div><div class="line">System.out.println(Thread.currentThread().getName() +  <span class="string">" : "</span>  + i);</div><div class="line"><span class="keyword">if</span> (i ==  <span class="number">20</span>) &#123;</div><div class="line"><span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line"><span class="keyword">new</span>  FirstThreadTest().start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName() 方法返回调用该方法的线程的名字。</p><h3 id="2-通过Runnable接口创建线程类"><a href="#2-通过Runnable接口创建线程类" class="headerlink" title="2.通过Runnable接口创建线程类"></a>2.通过Runnable接口创建线程类</h3><pre><code>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法 体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread 对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。</code></pre><h3 id="3-通过Callable和Future创建线程"><a href="#3-通过Callable和Future创建线程" class="headerlink" title="3.通过Callable和Future创建线程"></a>3.通过Callable和Future创建线程</h3><pre><code>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行 体，并且有返回值。（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该 FutureTask对象封装了该Callable对象的call()方法的返回值。（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用 get()方法会阻塞线程。</code></pre><h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><p>采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程 来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型， 较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接 使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。</p><h2 id="3-Object类对象含有的方法有哪些？"><a href="#3-Object类对象含有的方法有哪些？" class="headerlink" title="3.Object类对象含有的方法有哪些？"></a>3.Object类对象含有的方法有哪些？</h2><p>Java中的Object类是所有类的父类，它提供了以下11个方法：</p><pre><code>1.public final native Class&lt;?&gt;getClass()2.public native int hashCode()3.public boolean equals(Object obj)4.protected native Object clone() throws CloneNotSupportedException5.public String toString()6.public final native void notify()7.public final native void notifyAll()8.public final native void wait(long timeout) throws InterruptedException9.public final void wait(long timeout,int nanos)throws InterruptedException10.public final void wait() throws InterruptedException11.protected void finalize() throws Throwable{}</code></pre><h2 id="4-Android中的进程间通信有哪些方式？具体说说Binder"><a href="#4-Android中的进程间通信有哪些方式？具体说说Binder" class="headerlink" title="4.Android中的进程间通信有哪些方式？具体说说Binder"></a>4.Android中的进程间通信有哪些方式？具体说说Binder</h2><p>Android中的IPC方式</p><pre><code>使用Intent使用文件共享使用Messenger使用AIDL使用ContentProvider使用Socket</code></pre><h3 id="1-使用Intent"><a href="#1-使用Intent" class="headerlink" title="1.使用Intent"></a>1.使用Intent</h3><h4 id="1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"><a href="#1-Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。" class="headerlink" title="1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。"></a>1.Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，可以在不同的进程间进行传输。</h4><h4 id="2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"><a href="#2-在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。" class="headerlink" title="2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。"></a>2.在一个进程中启动了另一个进程的Activity，Service和Receiver，可以在Bundle中附加要传递的数据通过Intent发送出去。</h4><h3 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2.使用文件共享"></a>2.使用文件共享</h3><h4 id="1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem"><a href="#1-Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although-this-may-be-a-problem" class="headerlink" title="1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem."></a>1.Windows上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而Android系统基于Linux，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，although this may be a problem.</h4><h4 id="2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"><a href="#2-可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）" class="headerlink" title="2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）"></a>2.可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（Attention：并不是同一个对象，只是内容相同）</h4><h4 id="3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"><a href="#3-SharePreference是个特例，系统对它的读-写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读-写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。" class="headerlink" title="3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。"></a>3.SharePreference是个特例，系统对它的读/写有一定的缓存策略，即内存中会有一份SharePreferences文件的缓存，系统对它的读/写就变得不可靠，当面对高并发的读写访问，SharePreferences有很大的几率丢失数据。因此，IPC不建议采用SharePreferences。</h4><h3 id="3-使用Messenger"><a href="#3-使用Messenger" class="headerlink" title="3.使用Messenger"></a>3.使用Messenger</h3><p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，可以在不同进程中传递Message对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形</p><ul><li><p>服务端进程：服务端创建一个Service来处理客户端请求，同时通过一个Handler对象来实例化一个Meaaenger对象，然后在Servive的onBind中返回这个Messenger对象底层的Binder即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerSercive</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MessengerSercive.class.getSimpleName();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> msg</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</div><div class="line">                    Log.d(TAG, <span class="string">"receive msg from client: msg = ["</span></div><div class="line">                    + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>);</div><div class="line">                    Toast.makeText(MessengerService.<span class="keyword">this</span>, <span class="string">"receive msg from client: msg = ["</span> + msg.getData().getString(Constants.MSG_KEY) + <span class="string">"]"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                    Messenger client = msg.replyTo;</div><div class="line">                    Message replyMsg = Message.obtain(<span class="keyword">null</span>, Constants.MSG_FROM_SERVICE);</div><div class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">                    bundle.putString(Constants.MSG_KEY, <span class="string">"我已经收到你的消息，稍后回复你！"</span>);</div><div class="line">                    replyMsg.setData(bundle);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        client.send(replyMsg);</div><div class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> mMessenger.getBinder();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>客户端进程：首先绑定服务端Service，绑定成功之后用服务端的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，消息类型是Message。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个Messenger（和服务端一样），并通过Message的replyTo参数传递给服务端。服务端通过Message的replyTo参数就可以回应客户端了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity&#123;</div><div class="line">    private static final String TAG = MainActivity.class.getSimpleName();</div><div class="line">    private Messenger mGetReplyMessenger = new Messenger(new MessageHandler());</div><div class="line">    private Messenger mService;</div><div class="line">    private class MessageHandler extends Handler&#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg)&#123;</div><div class="line">            switch(msg.what)&#123;</div><div class="line">                case Constants.MSG_FROM_SERVICE:</div><div class="line">                Log.d(TAG, "received msg form service: msg = </div><div class="line">                [" + msg.getData().getString(Constants.MSG_KEY) + "]");</div><div class="line">                Toast.makeText(MainActivity.this, "received vice: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                super.handleMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInsttanceState)&#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">    public void bindService(View v)&#123;</div><div class="line">        Intent mIntent = new Intent(thia,MessengerService.class);</div><div class="line">        bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">    public void sendMessage(View v)&#123;</div><div class="line">        Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);</div><div class="line">        Bundle data = new Bunle();</div><div class="line">        data.putString(Constants.MSG_KEY, "Hello! This is client.");</div><div class="line">        msg.setData(data);</div><div class="line">        msg.replyTo = mGetReplyMessenger;</div><div class="line">        try&#123;</div><div class="line">            mService.send(mag);</div><div class="line">        &#125;catch(RemoteException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDestroy()&#123;</div><div class="line">        unbindService(mServiceConnection);</div><div class="line">        super.onDestroy();</div><div class="line">    &#125;</div><div class="line">    private ServiceConnection mServiceConnection = new ServiceConnection()&#123;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         * @param service</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder service)&#123;</div><div class="line">            mService = new Messenger(service);</div><div class="line">            Message msg = Message.obtain(null, Constants.MSG_FROM_CLIENT);</div><div class="line">            Bundle data = new Bundle();</div><div class="line">            data.putString(Constants.MSG_KEY,"Hello! This is cient.");</div><div class="line">            msg.setData(data);</div><div class="line">            mag.replyTo = mGetReplyMessenger;</div><div class="line">            try&#123;</div><div class="line">                mService.send(msg);</div><div class="line">            &#125;catch(RemoteException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * @param name</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void onServiceDiscommected(ComponentName name)&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>注意： 客户端和服务端是通过通过拿到对方的Messenger来发送Message的。只不过客户端通过bindService onServiceConnected而服务端通过message.replyTo来获得对方的Messenger。Messenger中有一个Hanlder以串行的方式处理队列中的消息。不存在并发执行，因此我们不考虑线程同步的问题。</p><h3 id="4-使用AIDL"><a href="#4-使用AIDL" class="headerlink" title="4.使用AIDL"></a>4.使用AIDL</h3><p>Messenger是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用Messenger，而且Messenger只适合传递消息，不能跨进程调用方法的问题，要知道Messenger本质上也是AIDL，只不过系统做了封装方便上层的调用而已。</p><p><strong>AIDL文件支持的数据类型</strong></p><ul><li>基本数据类型；</li><li>String和CharSequence；</li><li>ArrayList，里面的元素必须能够被AIDL支持；</li><li>HashMap，实现Parcelable接口的对象；注意：如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件。</li><li>AIDL，AIDL接口本身也可以在AIDL文件中使用。<br><strong>服务端</strong><br>服务端创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。<br><strong>客户端</strong><br>绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，然后就可以调用AIDL中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致ANR。客户端的onServiceConnected和onServiceDisconnected方法都在UI线程中。</li></ul><h2 id="5-Android中的AsyncTask的作用？"><a href="#5-Android中的AsyncTask的作用？" class="headerlink" title="5.Android中的AsyncTask的作用？"></a>5.Android中的AsyncTask的作用？</h2><h2 id="6-Android中的消息机制？"><a href="#6-Android中的消息机制？" class="headerlink" title="6.Android中的消息机制？"></a>6.Android中的消息机制？</h2><h2 id="7-Android中的事件分发机制了解多少？如何解决滑动冲突"><a href="#7-Android中的事件分发机制了解多少？如何解决滑动冲突" class="headerlink" title="7.Android中的事件分发机制了解多少？如何解决滑动冲突"></a>7.Android中的事件分发机制了解多少？如何解决滑动冲突</h2><h2 id="8-Java中的抽象类和接口的区别？"><a href="#8-Java中的抽象类和接口的区别？" class="headerlink" title="8.Java中的抽象类和接口的区别？"></a>8.Java中的抽象类和接口的区别？</h2><h3 id="理解抽象"><a href="#理解抽象" class="headerlink" title="理解抽象"></a>理解抽象</h3><p>abstract class 和 interface 是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract calss和interface之间对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。</p><p>其实，两者之间还是有很大区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p><h3 id="语法定义理解"><a href="#语法定义理解" class="headerlink" title="语法定义理解"></a>语法定义理解</h3><h4 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修饰的数据成员（也就是必须是<strong>static final</strong>的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract calss。</p><h3 id="编程角度理解"><a href="#编程角度理解" class="headerlink" title="编程角度理解"></a>编程角度理解</h3><p>首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多继承的支持方面的一种折中考虑吧。</p><p>其次，在abstract class的定义中，我们可以赋予方法的默认行为。</p><p>但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用<strong>default</strong>关键字实现默认方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 Java 8 之前，接口与其实现类之间的<strong>耦合度</strong>太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在lambda表达式作为Java8语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。</p><h3 id="一般性理解"><a href="#一般性理解" class="headerlink" title="一般性理解"></a>一般性理解</h3><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是“like-a”关系，抽象类反映的是“is-a”关系。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（if they are class），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它，所以，在高级语言上，一个类只能继承一个类（抽象类）（正如人不可能同时是生物和非生物），但是可以实现多个接口（吃饭接口、走路接口）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。2.抽象类要被子类继承，接口要被类实现。3.接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。4.抽象类里可以没有抽象方法。5.接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。6.接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。7.抽象类不能在Java 8的 lambda 表达式中使用。</code></pre><h2 id="9-Java设计模式了解多少？观察者模式在哪里使用过？"><a href="#9-Java设计模式了解多少？观察者模式在哪里使用过？" class="headerlink" title="9.Java设计模式了解多少？观察者模式在哪里使用过？"></a>9.Java设计模式了解多少？观察者模式在哪里使用过？</h2><h2 id="10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？"><a href="#10-有没有用过MVC-MVP-MVVM？有什么区别？MVP是如何使model与view进行互通的？" class="headerlink" title="10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？"></a>10.有没有用过MVC\MVP\MVVM？有什么区别？MVP是如何使model与view进行互通的？</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大概在数天前投递了字节跳动-抖音方向的实习生岗位&lt;br&gt;昨天接到了面试通知，今天面试后对涉及到的问题进行一个复盘。（字节跳动果然名不虚传…面试官相当亲切且善于循循善诱来引导我回答问题）&lt;/p&gt;
&lt;h2 id=&quot;1-Java中的引用类型有没有什么了解？&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>深度学习模型的转换 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://edward7zhang.github.io/2019/01/26/深度学习模型的转换/</id>
    <published>2019-01-26T11:07:14.000Z</published>
    <updated>2019-01-26T14:04:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端部署我们可能会使用feather CNN nihui的NCNN或者小米的mace等框架。facebook ONNX的出现为模型的转换提供了一种思路，但除了pytorch等框架能很好的支持ONNX。其他等框架并未很好的对接ONNX。在<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>出现之前，大家都把caffemodel作为一个中间体来进行转换。</p><p>其实就模型转换而言只是个填参数的过程，把模型结构搭好，把参数填进去就即可，但是实践过的朋友大家一定会知道这其中存在不少坑，但是我们更希望有一种自动化的模型转换方案来进行模型转换。</p><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的出现为模型转换带来了不少的福音，<a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>提供了一种IR(中间表示)来来衔接各个模型之间的转换。他囊括并支持了主流的DNN框架。</p><p>下面我就简要讲一下几个的简单模型转换</p><p>在此我推荐一个查看模型结构的工具<a href="https://github.com/lutzroeder/Netron" target="_blank" rel="external">Netron</a> 支持数种主流深度学习框架(Caffe,Tensorflow,ONNX等)的模型结构查看。</p><p>例如下图是MTCNN Pnet的模型结构图</p><p><img src="https://i.loli.net/2019/01/09/5c35f0ad3eaf1.png" alt="det1.png"></p><h3 id="MMdnn的安装"><a href="#MMdnn的安装" class="headerlink" title="MMdnn的安装"></a>MMdnn的安装</h3><p><a href="https://github.com/Microsoft/MMdnn" target="_blank" rel="external">MMdnn</a>的安装非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mmdnn</div></pre></td></tr></table></figure><h4 id="转换中的一些坑"><a href="#转换中的一些坑" class="headerlink" title="转换中的一些坑"></a>转换中的一些坑</h4><h5 id="1-并不是所有Layer和所有网络都支持转换"><a href="#1-并不是所有Layer和所有网络都支持转换" class="headerlink" title="1.并不是所有Layer和所有网络都支持转换"></a>1.并不是所有Layer和所有网络都支持转换</h5><p>由于各个深度学习框架之间的设计模式不同有的是基于命令式的有的是基于符号形式的。各个框架之间的op的粒度不同，又由于没有一个统一的标准，支持所有框架之间的转换是一件非常难的事情。MMdnn也只是把一些提供的常用的op，如conv,pooling等常规op。</p><h5 id="2-Tensorflow与caffe的padding方式并不相同"><a href="#2-Tensorflow与caffe的padding方式并不相同" class="headerlink" title="2.Tensorflow与caffe的padding方式并不相同"></a>2.Tensorflow与caffe的padding方式并不相同</h5><p>这个问题会出现在MobileNet在转换的过程中，因为Tensorflow的padding方式和其他框架是不同的。Tensorflow标准的卷积操作通常采用非对称的padding，而caffe等其他框架的卷积操作则是采用对称的padding。</p><p>如下图 ，比如当 卷积核的大小为3x3 stride为2的时候。尽管他们的padding方式不同，但卷积之后的尺寸确是一样的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/Microsoft/MMdnn/wiki/image/mobilenet1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h4><p>例如现在我们想把MTCNN的Keras Pnet转化成caffeodel用于部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtoir -f keras -w pnet.h5 -o pnet</div></pre></td></tr></table></figure><p>把keras模型转化成MMdnn IR中间表示，在当然目录下会生成一个.npy 的weights文件和一个.pb文件。接着使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mmtomodel -f caffe -in pnet -iw pnet.npy -o pnet</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于各种深度学习框架的层出不穷，我们在进行算法开发到算法部署的过程中，往往都需要用到不同的框架。例如我们很有可能使用tensorflow,pytorch等进行算法开发和调试，在早期工程inference的时候我们往往使用较为轻量的caffe或者魔改后的caffe。到了移动端
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习经典卷积神经网络 [学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://edward7zhang.github.io/2019/01/16/深度学习经典卷积神经网络/</id>
    <published>2019-01-16T11:07:14.000Z</published>
    <updated>2019-01-26T14:03:30.420Z</updated>
    
    <content type="html"><![CDATA[<p>随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：</p><pre><code>1.LeNet-5, 1998年2.AlexNet, 2012年3.ZF-Net, 2013年4.GoogleNet, 2014年5.VGG, 2014年6.ResNet, 2015年</code></pre><p>经过科研工作者的反复验证及广泛使用，这些模型逐渐成为经典，我们这里收集了一些常用的模型进行介绍。</p><h3 id="1-VGG"><a href="#1-VGG" class="headerlink" title="1. VGG"></a>1. VGG</h3><p><a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="external">论文地址</a></p><p>VGGNet是牛津大学计算机视觉组（Visual Geometry Group）和 Google DeepMind 公司的研究员一起研发的的深度卷积神经网络。VGGNet 探索了卷积神经网络的深度与其性能之间的关系，一共有六种不同的网络结构，但是每种结构都有含有５组卷积，每组卷积都使用３ｘ３的卷积核，每组卷积后进行一个２ｘ２最大池化，接下来是三个全连接层。在训练高级别的网络时，可以先训练低级别的网络，用前者获得的权重初始化高级别的网络，可以加速网络的收敛。VGGNet 相比之前state-of-the-art的网络结构，错误率大幅下降，并取得了ILSVRC 2014比赛分类项目的第2名和定位项目的第1名。同时VGGNet的拓展性很强，迁移到其他图片数据上的泛化性非常好。VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3<em>3）和最大池化尺寸（2</em>2）。<br>到目前为止，VGGNet依然经常被用来提取图像特征。</p><p><a href="https://blog.csdn.net/marsjhao/article/details/72955935" target="_blank" rel="external">经典卷积神经网络之VGGNet</a></p><p><a href="https://blog.csdn.net/qq_40027052/article/details/79015827" target="_blank" rel="external">VGG模型核心拆解</a></p><h3 id="2-GoogLeNet"><a href="#2-GoogLeNet" class="headerlink" title="2. GoogLeNet"></a>2. GoogLeNet</h3><p><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="external">[v1] Going Deeper with Convolutions</a></p><p><a href="http://arxiv.org/abs/1502.03167" target="_blank" rel="external">[v2] Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></p><p><a href="http://arxiv.org/abs/1512.00567" target="_blank" rel="external">[v3] Rethinking the Inception Architecture for Computer Vision</a> </p><p><a href="http://arxiv.org/abs/1602.07261" target="_blank" rel="external">[v4] Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning</a></p><p>GoogLeNet的最早版本，出现在2014年的” Going deeper with convolutions “。之所以名为 “GoogLeNet” 而非 “GoogleNet” ,文章说是为了向早期的LeNet致敬。GoogleNet提出了一个全新的深度 CNN 架构——Inception，无全连接层，可以节省运算的同时，减少了很多参数，参数数量是AlexNet的1/12，数量只有5 million，而且在ImageNet竞赛中取得了很好的成绩。</p><p><a href="https://blog.csdn.net/cdknight_happy/article/details/79247280" target="_blank" rel="external">GoogleNet系列论文学习</a></p><h3 id="3-Resnet"><a href="#3-Resnet" class="headerlink" title="3. Resnet"></a>3. Resnet</h3><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="external">论文地址</a></p><p>ResNet在2015年被提出，在ImageNet比赛classification任务上获得第一名，因为它 “简单与实用” 并存，之后很多方法都建立在ResNet50或者ResNet101的基础上完成的，检测，分割，识别等领域都纷纷使用ResNet，具有很强的适应性。ResNet的作者<a href="http://kaiminghe.com/" target="_blank" rel="external">何凯明</a>也因此摘得CVPR2016最佳论文奖。</p><p><a href="https://blog.csdn.net/lanran2/article/details/79057994" target="_blank" rel="external">ResNet解析</a></p><p><a href="https://blog.csdn.net/xxy0118/article/details/78324256" target="_blank" rel="external">ResNet学习</a></p><h3 id="4-MobileNet-V1-amp-MobileNet-V2"><a href="#4-MobileNet-V1-amp-MobileNet-V2" class="headerlink" title="4. MobileNet-V1 &amp; MobileNet -V2"></a>4. MobileNet-V1 &amp; MobileNet -V2</h3><p><a href="https://arxiv.org/abs/1704.04861" target="_blank" rel="external">V1论文地址</a></p><p><a href="https://arxiv.org/abs/1801.04381" target="_blank" rel="external">V2论文地址</a></p><p>MobileNet是Google团队针对移动端提出的高效图像识别网络，深入的研究了Depthwise Separable Convolutions使用方法后设计出MobileNet，Depthwise Separable Convolutions的本质是冗余信息更少的稀疏化表达。在此基础上给出了高效模型设计的两个选择：宽度因子(Width Multiplier)和分辨率因子(Resolution Multiplier)；通过权衡大小、延迟时间以及精度，来构建规模更小、速度更快的MobileNet。</p><p>MobileNet V2是之前MobileNet V1的改进版。MobileNet V1中主要是引入了Depthwise Separable Convolution代替传统的卷积操作，相当于实现了spatial和channel之间的解耦，达到模型加速的目的，整体网络结构还是延续了VGG网络直上直下的特点。和MobileNet V1相比，MobileNet V2主要的改进有两点：1、Linear Bottlenecks。也就是去掉了小维度输出层后面的非线性激活层，目的是为了保证模型的表达能力。2、Inverted Residual block。该结构和传统residual block中维度先缩减再扩增正好相反，因此shotcut也就变成了连接的是维度缩减后的feature map。</p><p><a href="https://blog.csdn.net/t800ghb/article/details/78879612" target="_blank" rel="external">深度解读谷歌MobileNet</a></p><p><a href="https://blog.csdn.net/u011995719/article/details/79135818" target="_blank" rel="external">轻量化网络：MobileNet-V2</a></p><h3 id="5-U-NET"><a href="#5-U-NET" class="headerlink" title="5. U-NET"></a>5. U-NET</h3><p><a href="http://arxiv.org/abs/1505.04597" target="_blank" rel="external">论文地址</a></p><p><a href="https://lmb.informatik.uni-freiburg.de/people/ronneber/u-net/" target="_blank" rel="external">项目地址</a></p><p>这是Encoder-Decoder网络的一种，在无监督学习中的框架，利用conv与deconv降维升维来进行学习，分别叫做encoder与decoder编码解码，一般基于卷积网络，encoder后相当于学习到了特征，而decoder后相当于还原了图像，既可以用输入图像进行训练，训练好一层加深一层。再可以利用有监督微调，从而达到分类或者图像转换的目的。</p><h3 id="6-GAN"><a href="#6-GAN" class="headerlink" title="6. GAN"></a>6. GAN</h3><p>总结：利用两个网络对抗生成模型，生成器与辨别器，生成器输入图像，生成所需图像，辨别器辨别所需图像与生成图像，使生成器的生成图像骗过辨别器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着深度学习的发展，研究人员提出了很多模型，这其中一些设计方式，在当时取得了很好的效果，也为其他科研工作者提供了很好的思路。CNN 的经典结构始于1998年的LeNet-5，成于2012年历史性的AlexNet，从此广泛用于图像相关领域，主要包括：&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>常用深度学习框架[学习&amp;转载]</title>
    <link href="https://edward7zhang.github.io/2019/01/09/%E5%B8%B8%E8%A7%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>https://edward7zhang.github.io/2019/01/09/常见深度学习框架/</id>
    <published>2019-01-09T11:07:14.000Z</published>
    <updated>2019-01-09T12:55:52.270Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，针对主流的深度学习框架进行简单对比及介绍。</p><table><thead><tr><th>框架</th><th>机构</th><th>支持语言</th><th>Stars</th><th>Forks</th></tr></thead><tbody><tr><td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">Caffe</a></td><td>BVLC</td><td>C++/Python/Matlab</td><td>25480</td><td>15560</td></tr><tr><td><a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">CNTK</a></td><td>Microsoft</td><td>C++</td><td>15083</td><td>4020</td></tr><tr><td><a href="notebooks/Keras_TF_CNN.ipynb">Keras</a></td><td>Fchollet</td><td>Python</td><td>33332</td><td>12563</td></tr><tr><td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">Tensorflow</a></td><td>Google</td><td>Python/C++/Go…</td><td>109115</td><td>67339</td></tr><tr><td><a href="https://github.com/apache/incubator-mxnet" target="_blank" rel="external">MXNet</a></td><td>DMLC</td><td>Python/C++/R…</td><td>15162</td><td>5484</td></tr><tr><td><a href="https://github.com/pytorch/pytorch" target="_blank" rel="external">PyTorch</a></td><td>Facebook</td><td>Python</td><td>18517</td><td>4426</td></tr></tbody></table><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><h4 id="1-训练时间-Network-DenseNet-121-Multi-GPU"><a href="#1-训练时间-Network-DenseNet-121-Multi-GPU" class="headerlink" title="1. 训练时间: Network DenseNet-121 (Multi-GPU)"></a>1. 训练时间: Network DenseNet-121 (Multi-GPU)</h4><p><strong>运行于 SSD 硬盘</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">27min</td><td style="text-align:center">10min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">38min</td><td style="text-align:center">18min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">33min</td><td style="text-align:center">22min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">29min</td><td style="text-align:center">10min</td></tr></tbody></table><p><strong>运行于RAM内存中</strong></p><table><thead><tr><th>框架</th><th style="text-align:center">1xV100/CUDA 9/CuDNN 7</th><th style="text-align:center">4xV100/CUDA 9/CuDNN 7</th></tr></thead><tbody><tr><td>Pytorch</td><td style="text-align:center">25min</td><td style="text-align:center">8min</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">36min</td><td style="text-align:center">15min</td></tr><tr><td>Tensorflow</td><td style="text-align:center">25min</td><td style="text-align:center">14min</td></tr><tr><td>MXNet(Gluon)</td><td style="text-align:center">28min</td><td style="text-align:center">8min</td></tr></tbody></table><h4 id="2-1000张图片推理时间-s-Network-ResNet-50"><a href="#2-1000张图片推理时间-s-Network-ResNet-50" class="headerlink" title="2. 1000张图片推理时间(s): Network ResNet-50"></a>2. 1000张图片推理时间(s): Network ResNet-50</h4><table><thead><tr><th>框架</th><th style="text-align:center">K80/CUDA 8/CuDNN 6</th><th style="text-align:center">P100/CUDA 8/CuDNN 6</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">8.5</td><td style="text-align:center">1.6</td></tr><tr><td>Keras(TF)</td><td style="text-align:center">10.2</td><td style="text-align:center">2.9</td></tr><tr><td>Tensorflow</td><td style="text-align:center">6.5</td><td style="text-align:center">1.8</td></tr><tr><td>MXNet</td><td style="text-align:center">7.7</td><td style="text-align:center">1.6</td></tr><tr><td>PyTorch</td><td style="text-align:center">7.7</td><td style="text-align:center">1.9</td></tr></tbody></table><h4 id="3-CPU推理时间-s-E5-2630v4-Network-FCN5"><a href="#3-CPU推理时间-s-E5-2630v4-Network-FCN5" class="headerlink" title="3. CPU推理时间(s): E5-2630v4, Network FCN5"></a>3. CPU推理时间(s): E5-2630v4, Network FCN5</h4><table><thead><tr><th>框架</th><th style="text-align:center">1 Thread</th><th style="text-align:center">2 Threads</th><th style="text-align:center">4 Threads</th><th style="text-align:center">8 Threads</th><th style="text-align:center">16 Threads</th><th style="text-align:center">32 Threads</th></tr></thead><tbody><tr><td>Caffe</td><td style="text-align:center">1887.2ms</td><td style="text-align:center">1316.7ms</td><td style="text-align:center">1051.8ms</td><td style="text-align:center">952.1ms</td><td style="text-align:center">952.3ms</td><td style="text-align:center">834.7ms</td></tr><tr><td>CNTK</td><td style="text-align:center">1238.7ms</td><td style="text-align:center">616.3ms</td><td style="text-align:center">352.7ms</td><td style="text-align:center">229.5ms</td><td style="text-align:center">155.9ms</td><td style="text-align:center">192.4ms</td></tr><tr><td>Tensorflow</td><td style="text-align:center">992.2ms</td><td style="text-align:center">773.6ms</td><td style="text-align:center">419.3ms</td><td style="text-align:center">252.3ms</td><td style="text-align:center">149.7ms</td><td style="text-align:center">124.7ms</td></tr><tr><td>MXNet</td><td style="text-align:center">1386.8ms</td><td style="text-align:center">915.5ms</td><td style="text-align:center">559.0ms</td><td style="text-align:center">499.1ms</td><td style="text-align:center">416.3ms</td><td style="text-align:center">413.9ms</td></tr></tbody></table><h3 id="框架评价"><a href="#框架评价" class="headerlink" title="框架评价"></a>框架评价</h3><table><thead><tr><th>框架</th><th style="text-align:center">安装成本</th><th style="text-align:center">代码理解程度</th><th style="text-align:center">API丰富程度</th><th style="text-align:center">模型丰富程度</th><th style="text-align:center">文档完整程度</th><th style="text-align:center">训练与测过程</th><th style="text-align:center">学习资源</th></tr></thead><tbody><tr><td>CNTK</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Keras</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td></tr><tr><td>MXNet</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Pytorch</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td></tr><tr><td>Tensorflow</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td><td style="text-align:center">优秀</td></tr><tr><td>Caffe</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td><td style="text-align:center">良好</td><td style="text-align:center">优秀</td></tr></tbody></table><h3 id="推荐框架"><a href="#推荐框架" class="headerlink" title="推荐框架"></a>推荐框架</h3><p>目前众多的深度学习框架，使用者只要选择适合自己的框架即可，我们在日常使用中，考虑到训练的快捷程度，部署难度以及对CNN、RNN模型的直接程度，推荐以下几款深度学习框架。</p><h4 id="1-Keras"><a href="#1-Keras" class="headerlink" title="1.Keras"></a>1.Keras</h4><p>Keras 提供了简单易用的 API 接口，入门快，特别适合初学者入门。其后端采用 TensorFlow, CNTK，以及 Theano。另外，Deeplearning4j 的 Python 也是基于 Keras 实现的。Keras 几乎已经成了 Python 神经网络的接口标准。</p><h4 id="2-TensorFlow"><a href="#2-TensorFlow" class="headerlink" title="2.TensorFlow"></a>2.TensorFlow</h4><p>谷歌出品，追随者众多。代码质量高，支持模型丰富，支持语言多样， TensorBoard 可视化工具使用方便。</p><h4 id="3-MXNet"><a href="#3-MXNet" class="headerlink" title="3.MXNet"></a>3.MXNet</h4><p>已被亚马逊选为 AWS 上的深度学习框架，支持动态图计算。MXNet 有许多中国开发者，因而有非常良好的中文文档支持。Gluon 接口使得 MXNet 像 Keras 一样简单易用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://dlbench.comp.hkbu.edu.hk/?v=v8" target="_blank" rel="external">香港浸会大学深度学习框架Benchmark</a></li><li><a href="https://github.com/ilkarman/DeepLearningFrameworks" target="_blank" rel="external">DeepLearningFrameworks</a></li><li><a href="http://app.myzaker.com/news/article.php?pk=5a13b55c1bc8e05d71000016" target="_blank" rel="external">博客</a></li><li><a href="https://www.zhihu.com/question/68114194/answer/465874315" target="_blank" rel="external">开发者如何选择深度学习框架?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深度学习研究的热潮持续高涨，各种开源深度学习框架也层出不穷，其中包括TensorFlow、Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon等。我们参考开源的测试结果，结合自己整理的数据，
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://edward7zhang.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>回环，未来可期</title>
    <link href="https://edward7zhang.github.io/2018/08/27/%E5%9B%9E%E7%8E%AF%EF%BC%8C%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/"/>
    <id>https://edward7zhang.github.io/2018/08/27/回环，未来可期/</id>
    <published>2018-08-26T17:42:07.000Z</published>
    <updated>2018-08-26T13:25:57.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天，是我21岁的生日。<br>在一个半月前我辞职了，但准确的说是被动式辞职。<br>现在看来这是一件好事。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8176988f43d.jpg" alt="第一天到公司楼下" title="">                </div>                <div class="image-caption">第一天到公司楼下</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac7c155.jpg" alt="工牌" title="">                </div>                <div class="image-caption">工牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b81769918ccc.jpg" alt="第一天安顿下来" title="">                </div>                <div class="image-caption">第一天安顿下来</div>            </figure><h2 id="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"><a href="#似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历" class="headerlink" title="似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历"></a>似乎人生进入弱冠之后，很多事情都事发突然，好在事情发生过后，再回头看，不失是一种不错的经历</h2><p>辞职的原因是优秀的project不被认可…所以和我的直接主管就一并选择了离职…</p><p>在外界人看来可能这种做法简直是不解…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173aeb88e9.jpg" alt="嗯，希望这家公司可以保持初心" title="">                </div>                <div class="image-caption">嗯，希望这家公司可以保持初心</div>            </figure><p>可是对于程序猿这类人来说，能做自己感兴趣的事情应该是最高的荣誉…</p><p>况且是在一个优秀project并且在有良好实现的基础上被否掉…这种痛苦莫过于饮鸩</p><p>正如标题所言<strong> 回环 </strong>，刚刚接到消息的时候自己还郁闷了一整天，现在回头看这应该是一种回环，就如同立交桥的转环匝道，虽然又绕回了原点，但是却提升了一个维度。</p><p>幸运如我，在这短暂的实习中遇到了非常nice的主管，涨了很多见识，意识到我之前是多么的短视…从而也看到了自己未来的一些可能，但前提要做一些付出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad848db.jpg" alt="公司对面的腾讯&完美世界" title="">                </div>                <div class="image-caption">公司对面的腾讯&完美世界</div>            </figure><h2 id="在这两个月的实习中，项目进展有如神助"><a href="#在这两个月的实习中，项目进展有如神助" class="headerlink" title="在这两个月的实习中，项目进展有如神助"></a>在这两个月的实习中，项目进展有如神助</h2><p>在实习这段时间，项目进展速度惊人，每天都很充实，每天一组的伙伴们都在一起想对策，现在回头想想也许是之前自己在人工智能方面的一点小小的经验加之主管之前在NLP方面的研究的共交使得项目发展迅速。</p><p>两个月的时间实现了模型的搭建以及demo的实现&amp;项目预演…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a8e14d3.png" alt="工位" title="">                </div>                <div class="image-caption">工位</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac5d381.jpg" alt="在公司最后一天的项目汇报" title="">                </div>                <div class="image-caption">在公司最后一天的项目汇报</div>            </figure><p>至于为什么否掉我们…各种因素…不想明说了…有点官宦风格…各位看客自己想象吧…</p><h2 id="下一步，再进站"><a href="#下一步，再进站" class="headerlink" title="下一步，再进站"></a>下一步，再进站</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ad86919.jpg" alt="反射" title="">                </div>                <div class="image-caption">反射</div>            </figure><p>这一趟实习下来，可以说彻底改变了我曾经对自己的看法…</p><p>总的来说，过去我常常视线过度短浅…在对自己人生的规划上也过于保守吧…</p><p>事实上，一个人所看到的往往是狭窄的，通过不断的接触高层次的人和事物才能让自己变得更open。</p><p>决定了考研，也看清了国内的互联网环境的虚实…希望自己能付有所得…</p><p>如果有机会，还是去接触接触技术原始地熏陶熏陶吧…</p><h2 id="未来可期"><a href="#未来可期" class="headerlink" title="未来可期"></a>未来可期</h2><p>在大学里的三年再算上实习的经历…尝试了互联网开发的很多方向…</p><p>最终吸引我的并不是各种框架炫技的开发…而是能赋予应用灵魂的人工智能方向…</p><p>大概未来的发展方向也就定在这样的趋势了…</p><p><strong>继续行走，未来可期。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173ac9ba83.jpg" alt="离开那天天气很好" title="">                </div>                <div class="image-caption">离开那天天气很好</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/25/5b8173a5c08cd.jpg" alt="未来可期" title="">                </div>                <div class="image-caption">未来可期</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天，是我21岁的生日。&lt;br&gt;在一个半月前我辞职了，但准确的说是被动式辞职。&lt;br&gt;现在看来这是一件好事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div 
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>基于TensorFlow的CNN中文文本分类</title>
    <link href="https://edward7zhang.github.io/2018/05/20/%E5%9F%BA%E4%BA%8ETensorFlow%E7%9A%84CNN%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    <id>https://edward7zhang.github.io/2018/05/20/基于TensorFlow的CNN中文文本分类/</id>
    <published>2018-05-20T10:00:07.000Z</published>
    <updated>2018-05-20T10:50:21.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。</p></blockquote><h1 id="CNN实现文本分类的原理"><a href="#CNN实现文本分类的原理" class="headerlink" title="CNN实现文本分类的原理"></a>CNN实现文本分类的原理</h1><p>下图展示了如何使用cnn进行句子分类。输入是一个句子，为了使其可以进行卷积，首先需要将其转化为向量表示，通常使用word2vec实现。d=5表示每个词转化为5维的向量，矩阵的形状是[sentence_length ×× 5]，即[7 ×× 5]。6个filter（卷积核），与图像中使用的卷积核不同的是，nlp使用的卷积核的宽与句子矩阵的宽相同，只是长度不同。这里有（2，3，4）三种size，每种size有两个filter，一共有6个filter。然后开始卷积，从图中可以看出，stride是1，因为对于高是4的filter，最后生成4维的向量，（7-4）/1+1=4。对于高是3的filter，最后生成5维的向量，（7-3）/1+1=5。卷积之后，我们得到句子的特征，使用activation function和1-max-pooling得到最后的值，每个filter最后得到两个特征。将所有特征合并后，使用softmax进行分类。图中没有用到chanel,下文的实验将会使用两个通道，static和non-static，有相关的具体解释。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-12.05.40-PM-1024x937.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h1 id="本文使用的模型"><a href="#本文使用的模型" class="headerlink" title="本文使用的模型"></a>本文使用的模型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-8.03.47-AM-1024x413.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>主要包括五层，第一层是embedding layer,第二层是convolutional layer,第三层是max-pooling layer,第四层是fully connected layer，最后一层是softmax layer.接下来依次介绍相关代码实现。</p><h2 id="Input-placeholder"><a href="#Input-placeholder" class="headerlink" title="Input placeholder"></a>Input placeholder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Placeholders for input, output and dropout</div><div class="line">self.input_x = tf.placeholder(tf.int32, [None, sequence_length], name=&quot;input_x&quot;)</div><div class="line">self.input_y = tf.placeholder(tf.float32, [None, num_classes], name=&quot;input_y&quot;)</div><div class="line">self.dropout_keep_prob = tf.placeholder(tf.float32, name=&quot;dropout_keep_prob&quot;)</div></pre></td></tr></table></figure><p><code>tf.placeholder</code> 创建一个占位符变量，在训练或者测试的时候，需要将占位符输入到网络中进行计算，其中的第二个参数是输入张量的形状。None 意味着它可以是任何维度的长度，在我们的实验中它代表批处理的大小，None使得网络可以处理任意长度的batches。<br>失活率同样也是输入的一部分，在训练的时候使用dropout ，测试的时候不使用dropout 。</p><h2 id="EMBEDDING-LAYER"><a href="#EMBEDDING-LAYER" class="headerlink" title="EMBEDDING LAYER"></a>EMBEDDING LAYER</h2><p>这一层将单词索引映射到低维的向量表示，它本质上是一个查找表，我们从数据中通过学习得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with tf.device(&apos;/cpu:0&apos;), tf.name_scope(&quot;embedding&quot;):</div><div class="line">    W = tf.Variable(tf.random_uniform([vocab_size, embedding_size], -1.0, 1.0), name=&quot;W&quot;)</div><div class="line">    self.embedded_chars = tf.nn.embedding_lookup(W, self.input_x)</div><div class="line">    self.embedded_chars_expanded = tf.expand_dims(self.embedded_chars, -1)</div></pre></td></tr></table></figure><p>其中，<code>W</code> 是 在训练时得到的embedding matrix.，用随机均匀分布进行初始化。<a href="http://blog.csdn.net/u013713117/article/details/55048040" target="_blank" rel="external">tf.nn.embedding_lookup</a>实现embedding操作，得到 一个3-dimensional 的张量，形状是 <code>[None, sequence_length, embedding_size].</code> <code>sequence_length</code> 是数据集中最长句子的长度，其他句子都通过添加“PAD”补充到这个长度。<code>embedding_size</code> 是词向量的大小。</p><p>TensorFlow的卷积函数-<code>conv2d</code> 需要四个参数， 分别是batch, width, height 以及channel。 embedding之后不包括 channel, 所以我们人为地添加上它，并设置为1。现在就是<code>[None, sequence_length, embedding_size, 1]</code></p><h2 id="CONVOLUTION-AND-MAX-POOLING-LAYERS"><a href="#CONVOLUTION-AND-MAX-POOLING-LAYERS" class="headerlink" title="CONVOLUTION AND MAX-POOLING LAYERS"></a>CONVOLUTION AND MAX-POOLING LAYERS</h2><p>由图中可知， 我们有不同size的filters。因为每次卷积都会产生不同形状的张量，所以我们要遍历每个filter，然后将结果合并成一个大的特征向量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pooled_outputs = []</div><div class="line">for i, filter_size in enumerate(filter_sizes):</div><div class="line">    with tf.name_scope(&quot;conv-maxpool-%s&quot; % filter_size):</div><div class="line">        # Convolution Layer</div><div class="line">        filter_shape = [filter_size, embedding_size, 1, num_filters]</div><div class="line">        W = tf.Variable(tf.truncated_normal(filter_shape, stddev=0.1), name=&quot;W&quot;)</div><div class="line">        b = tf.Variable(tf.constant(0.1, shape=[num_filters]), name=&quot;b&quot;)</div><div class="line">        conv = tf.nn.conv2d(</div><div class="line">            self.embedded_chars_expanded,</div><div class="line">            W,</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&quot;VALID&quot;,</div><div class="line">            name=&quot;conv&quot;)</div><div class="line">        # Apply nonlinearity</div><div class="line">        h = tf.nn.relu(tf.nn.bias_add(conv, b), name=&quot;relu&quot;)</div><div class="line">        # Max-pooling over the outputs</div><div class="line">        pooled = tf.nn.max_pool(</div><div class="line">            h,</div><div class="line">            ksize=[1, sequence_length - filter_size + 1, 1, 1],</div><div class="line">            strides=[1, 1, 1, 1],</div><div class="line">            padding=&apos;VALID&apos;,</div><div class="line">            name=&quot;pool&quot;)</div><div class="line">        pooled_outputs.append(pooled)</div><div class="line"></div><div class="line"># Combine all the pooled features</div><div class="line">num_filters_total = num_filters * len(filter_sizes)</div><div class="line">self.h_pool = tf.concat(3, pooled_outputs)</div><div class="line">self.h_pool_flat = tf.reshape(self.h_pool, [-1, num_filters_total])</div></pre></td></tr></table></figure><p>这里<code>W</code> 是filter 矩阵，<code>h</code> 是对卷积结果进行非线性转换之后的结果。每个 filter都从整个embedding划过,不同之处在于覆盖多少单词。 “VALID” padding意味着没有对句子的边缘进行padding,也就是用了narrow convolution，输出的形状是 <code>[1, sequence_length - filter_size + 1, 1, 1]</code>。narrow convolution与 wide convolution的区别是是否对边缘进行填充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-9.47.41-AM-1024x261.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br><em>Narrow vs. Wide Convolution. Filter size 5, input size 7. Source: A Convolutional Neural Network for Modelling Sentences (2014)</em><br>当你的filter比输入的size还大时，你可以看到wide convolution是多么的有用，甚至说是必须的。如上所示，narrow convolution产出的尺寸是（7-5）+1=3，而wide convolution产出尺寸是（7+2*4-5）+1=11。通常，输出尺寸的规则表达式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161218225721289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVlbWFpY2hh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><br>对输出进行max-pooling后得到形状是 <code>[batch_size, 1, 1, num_filters]</code> 的张量，本质上是一个特征向量，最后一个维度是特征代表数量。把每一个max-pooling之后的张量合并起来之后得到一个长向量 <code>[batch_size, num_filters_total]</code>. in <code>tf.reshape</code> 中的 -1表示T将向量展平。</p><h2 id="DROPOUT-LAYER"><a href="#DROPOUT-LAYER" class="headerlink" title="DROPOUT LAYER"></a>DROPOUT LAYER</h2><p>Dropout也许是cnn中最流行的正则化方法。dropout的想法很简单，dropout layer随机地选择一些神经元，使其失活。这样可以阻止co-adapting,迫使它们每一个都学习到有用的特征。失活的神经单元个数由<code>dropout_keep_prob</code> 决定。在训练的时候设为 0.5 ,测试的时候设为 1 (disable dropout) .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Add dropout</div><div class="line">with tf.name_scope(&quot;dropout&quot;):</div><div class="line">    self.h_drop = tf.nn.dropout(self.h_pool_flat, self.dropout_keep_prob)</div></pre></td></tr></table></figure><h2 id="SCORES-AND-PREDICTIONS"><a href="#SCORES-AND-PREDICTIONS" class="headerlink" title="SCORES AND PREDICTIONS"></a>SCORES AND PREDICTIONS</h2><p>利用特征向量，我们可以用矩阵相乘计算两类的得分，也可以用 softmax函数计算两类的概率值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">with tf.name_scope(&quot;output&quot;):</div><div class="line">    W = tf.Variable(tf.truncated_normal([num_filters_total, num_classes], stddev=0.1), name=&quot;W&quot;)</div><div class="line">    b = tf.Variable(tf.constant(0.1, shape=[num_classes]), name=&quot;b&quot;)</div><div class="line">    self.scores = tf.nn.xw_plus_b(self.h_drop, W, b, name=&quot;scores&quot;)</div><div class="line">    self.predictions = tf.argmax(self.scores, 1, name=&quot;predictions&quot;)</div></pre></td></tr></table></figure><h2 id="LOSS-AND-ACCURACY"><a href="#LOSS-AND-ACCURACY" class="headerlink" title="LOSS AND ACCURACY"></a>LOSS AND ACCURACY</h2><p>可以用得分定义损失值。损失计算的是网络的误差，我们的目标是将其最小化，分类问题标准的损失函数是交叉熵损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate mean cross-entropy loss</div><div class="line">with tf.name_scope(&quot;loss&quot;):</div><div class="line">    losses = tf.nn.softmax_cross_entropy_with_logits(self.scores, self.input_y)</div><div class="line">    self.loss = tf.reduce_mean(losses)</div></pre></td></tr></table></figure><p>计算正确率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Calculate Accuracy</div><div class="line">with tf.name_scope(&quot;accuracy&quot;):</div><div class="line">    correct_predictions = tf.equal(self.predictions, tf.argmax(self.input_y, 1))</div><div class="line">    self.accuracy = tf.reduce_mean(tf.cast(correct_predictions, &quot;float&quot;), name=&quot;accuracy&quot;)</div></pre></td></tr></table></figure><h2 id="MINIMIZING-THE-LOSS"><a href="#MINIMIZING-THE-LOSS" class="headerlink" title="MINIMIZING THE LOSS"></a>MINIMIZING THE LOSS</h2><p>利用TensorFlow 内置的optimizers，例如 Adam optimizer，优化网络损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">global_step = tf.Variable(0, name=&quot;global_step&quot;, trainable=False)</div><div class="line">optimizer = tf.train.AdamOptimizer(1e-4)</div><div class="line">grads_and_vars = optimizer.compute_gradients(cnn.loss)</div><div class="line">train_op = optimizer.apply_gradients(grads_and_vars, global_step=global_step)</div></pre></td></tr></table></figure><p><code>train_op</code> 是一个新建的操作，我们可以在参数上进行梯度更新。每执行一次 <code>train_op</code> 就是一次训练步骤。 TensorFlow 可以自动地计算才那些变量是“可训练的”然后计算他们的梯度。通过<code>global_step</code>这个变量可以计算训练的步数，每训练一次自动加一。</p><h2 id="CHECKPOINTING"><a href="#CHECKPOINTING" class="headerlink" title="CHECKPOINTING"></a>CHECKPOINTING</h2><p>TensorFlow 中可以用checkpointing 保存模型的参数。checkpointing中的参数也可以用来继续训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Checkpointing</div><div class="line">checkpoint_dir = os.path.abspath(os.path.join(out_dir, &quot;checkpoints&quot;))</div><div class="line">checkpoint_prefix = os.path.join(checkpoint_dir, &quot;model&quot;)</div><div class="line"># Tensorflow assumes this directory already exists so we need to create it</div><div class="line">if not os.path.exists(checkpoint_dir):</div><div class="line">    os.makedirs(checkpoint_dir)</div><div class="line">saver = tf.train.Saver(tf.all_variables())</div></pre></td></tr></table></figure><h2 id="DEFINING-A-SINGLE-TRAINING-STEP"><a href="#DEFINING-A-SINGLE-TRAINING-STEP" class="headerlink" title="DEFINING A SINGLE TRAINING STEP"></a>DEFINING A SINGLE TRAINING STEP</h2><p>用一个batch的数据进行一次训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def train_step(x_batch, y_batch):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    A single training step</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: FLAGS.dropout_keep_prob</div><div class="line">    &#125;</div><div class="line">    _, step, summaries, loss, accuracy = sess.run(</div><div class="line">        [train_op, global_step, train_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    train_summary_writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><p><code>train_op</code> 什么也不返回，只是更新网络中的参数。最终，打印出当前训练的损失值与正确率。如果batch的size很小的话，这两者在不同的batch中差别很大。因为使用了dropout，训练的metrics可能要比测试的metrics糟糕。</p><p>同样的函数也可以用在测试时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def dev_step(x_batch, y_batch, writer=None):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Evaluates model on a dev set</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    feed_dict = &#123;</div><div class="line">      cnn.input_x: x_batch,</div><div class="line">      cnn.input_y: y_batch,</div><div class="line">      cnn.dropout_keep_prob: 1.0</div><div class="line">    &#125;</div><div class="line">    step, summaries, loss, accuracy = sess.run(</div><div class="line">        [global_step, dev_summary_op, cnn.loss, cnn.accuracy],</div><div class="line">        feed_dict)</div><div class="line">    time_str = datetime.datetime.now().isoformat()</div><div class="line">    print(&quot;&#123;&#125;: step &#123;&#125;, loss &#123;:g&#125;, acc &#123;:g&#125;&quot;.format(time_str, step, loss, accuracy))</div><div class="line">    if writer:</div><div class="line">        writer.add_summary(summaries, step)</div></pre></td></tr></table></figure><h2 id="TRAINING-LOOP"><a href="#TRAINING-LOOP" class="headerlink" title="TRAINING LOOP"></a>TRAINING LOOP</h2><p>通过迭代数据进行训练。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Generate batches</div><div class="line">batches = data_helpers.batch_iter(</div><div class="line">    zip(x_train, y_train), FLAGS.batch_size, FLAGS.num_epochs)</div><div class="line"># Training loop. For each batch...</div><div class="line">for batch in batches:</div><div class="line">    x_batch, y_batch = zip(*batch)</div><div class="line">    train_step(x_batch, y_batch)</div><div class="line">    current_step = tf.train.global_step(sess, global_step)</div><div class="line">    if current_step % FLAGS.evaluate_every == 0:</div><div class="line">        print(&quot;\nEvaluation:&quot;)</div><div class="line">        dev_step(x_dev, y_dev, writer=dev_summary_writer)</div><div class="line">        print(&quot;&quot;)</div><div class="line">    if current_step % FLAGS.checkpoint_every == 0:</div><div class="line">        path = saver.save(sess, checkpoint_prefix, global_step=current_step)</div><div class="line">        print(&quot;Saved model checkpoint to &#123;&#125;\n&quot;.format(path))</div></pre></td></tr></table></figure><h2 id="VISUALIZING-RESULTS-IN-TENSORBOARD"><a href="#VISUALIZING-RESULTS-IN-TENSORBOARD" class="headerlink" title="VISUALIZING RESULTS IN TENSORBOARD"></a>VISUALIZING RESULTS IN TENSORBOARD</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.29.14-AM-1024x347.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/12/Screen-Shot-2015-12-11-at-6.27.48-AM-1024x350.png" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>从上图中我们可以观察到:</p><ul><li>我们的训练 metrics不平滑，因为用的batch sizes很小。如果用大的batches (或者在整个测试集上进行评估)，会得到平滑的线。</li><li>测试集的 accuracy明显比训练集的低，说明网络过拟合了，我们应该用更大的数据集，更强的正则化，更少的模型参数。</li><li>训练集上的 loss 和 accuracy比测试集低的原因是用了dropout.</li></ul><h1 id="参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow"><a href="#参考：http-www-wildml-com-2015-12-implementing-a-cnn-for-text-classification-in-tensorflow" class="headerlink" title="参考：http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/"></a>参考：<a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="external">http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CNN在计算机视觉领域取得了很好的结果，同时它可以应用在文本分类上面，此文主要介绍如何使用tensorflow实现此任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;CNN实现文本分类的原理&quot;&gt;&lt;a href=&quot;#CNN实现文本分类的原理
      
    
    </summary>
    
    
      <category term="TensorFlow" scheme="https://edward7zhang.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>实验室招新题目②</title>
    <link href="https://edward7zhang.github.io/2018/05/08/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE(2)/"/>
    <id>https://edward7zhang.github.io/2018/05/08/实验室招新题目(2)/</id>
    <published>2018-05-08T10:00:07.000Z</published>
    <updated>2018-05-08T16:09:44.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="火车装箱"><a href="#火车装箱" class="headerlink" title="火车装箱"></a>火车装箱</h1><hr><h2 id="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"><a href="#现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车" class="headerlink" title="现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车"></a>现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车</h2><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul><li>其中每节车厢中包含两种元素 车厢号：<code>TrainNum</code> 以及所装载货物数量：<code>GoodsNum</code>；</li><li>其中每节车厢以<code>前车厢</code> -&gt; <code>后车厢</code> 的形式进行连接；</li><li>按照每节车厢的<code>GoodsNum</code>的降序进行连接；</li><li><p>自定义一个<code>TrainCabin</code>数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span>&#123;</span></div><div class="line"></div><div class="line"><span class="comment">//TODO structure your struct</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>写出一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin* TrainList)</span></span>;</div><div class="line"><span class="comment">//选择你认为时间复杂度最小的算法进行编码</span></div></pre></td></tr></table></figure></li></ul><blockquote><p>返回值为已按照以上要求排好序后的火车链表</p></blockquote><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>第一个值为<code>TrainNum</code></li><li>第二个值为<code>GoodsNum</code></li><li>中间以<code>|</code>分割</li><li>输入<code>-1</code> 以结束输入</li></ul><h3 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h3><pre><code>1 | 32 | 53 | 74 | 25 | 0-1</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>在控制台中打印排好序的火车列</li><li>按照以下示例格式</li></ul><h3 id="Output："><a href="#Output：" class="headerlink" title="Output："></a>Output：</h3><pre><code>| 3 | 7 | -&gt; | 2 | 5 | -&gt; | 1 | 3 | -&gt; | 4 | 2 | -&gt; | 5 | 0 |</code></pre><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>非常基础的一道考察数据抽象、数据结构构造、排序算法、单向链表的简单题…但今天的现场情况不容乐观<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum;</div><div class="line"><span class="keyword">int</span> GoodsNum;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainCabin</span> *<span class="title">next</span>;</span></div><div class="line">&#125;TrainCabin;</div><div class="line"></div><div class="line"><span class="function">TrainCabin* <span class="title">AssembleTraninCabin</span><span class="params">(TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line">TrainCabin *i=TrainList;</div><div class="line">TrainCabin *j;</div><div class="line">TrainCabin *temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"><span class="keyword">while</span>(i!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">j=i-&gt;next;</div><div class="line"><span class="keyword">while</span>(j!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>((*i).GoodsNum&gt;(*j).GoodsNum)</div><div class="line">&#123;</div><div class="line">(*temp).TrainNum=(*i).TrainNum;</div><div class="line">(*temp).GoodsNum=(*i).GoodsNum;</div><div class="line">(*i).TrainNum=(*j).TrainNum;</div><div class="line">(*i).GoodsNum=(*j).GoodsNum;</div><div class="line">(*j).TrainNum=(*temp).TrainNum;</div><div class="line">(*j).GoodsNum=(*temp).GoodsNum;</div><div class="line">&#125;</div><div class="line">j=j-&gt;next;</div><div class="line">&#125;</div><div class="line">i=i-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> TrainList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> TrainCabin *TrainList)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span>(TrainList-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"| -&gt; "</span>;</div><div class="line">TrainList=TrainList-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).TrainNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;(*TrainList).GoodsNum&lt;&lt;<span class="string">"|"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> TrainNum=<span class="number">0</span>,GoodsNum=<span class="number">0</span>;</div><div class="line">TrainCabin *frist,*last;</div><div class="line">TrainCabin *temp;</div><div class="line">frist=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">frist-&gt;next=<span class="literal">NULL</span>;</div><div class="line">last=frist;</div><div class="line"><span class="keyword">char</span> input;</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;TrainNum;</div><div class="line"><span class="keyword">if</span>(TrainNum==<span class="number">-1</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;input;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;GoodsNum;</div><div class="line"></div><div class="line">temp=(TrainCabin*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TrainCabin));</div><div class="line">temp-&gt;TrainNum=TrainNum;</div><div class="line">temp-&gt;GoodsNum=GoodsNum;</div><div class="line">temp-&gt;next=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line">last-&gt;next=temp;</div><div class="line">last=temp;</div><div class="line">&#125;</div><div class="line">TrainCabin *result=AssembleTraninCabin((*frist).next);</div><div class="line">display(result);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;火车装箱&quot;&gt;&lt;a href=&quot;#火车装箱&quot; class=&quot;headerlink&quot; title=&quot;火车装箱&quot;&gt;&lt;/a&gt;火车装箱&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;现有一批火车车厢需要按照每节车厢中所含货物数量进行连接发车&quot;&gt;&lt;a href=&quot;#现有一批火车车厢需要按
      
    
    </summary>
    
    
      <category term="Lab_Interview" scheme="https://edward7zhang.github.io/tags/Lab-Interview/"/>
    
  </entry>
  
  <entry>
    <title>后生可畏</title>
    <link href="https://edward7zhang.github.io/2018/05/06/%E5%90%8E%E7%94%9F%E5%8F%AF%E7%95%8F/"/>
    <id>https://edward7zhang.github.io/2018/05/06/后生可畏/</id>
    <published>2018-05-06T15:20:07.000Z</published>
    <updated>2018-05-06T15:44:43.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Take-your-Child-to-work-Day-at-Google-2018"><a href="#Take-your-Child-to-work-Day-at-Google-2018" class="headerlink" title="Take your Child to work Day at Google 2018"></a>Take your Child to work Day at Google 2018</h1><iframe width="600" height="337.3" src="https://www.youtube.com/embed/2nWkYwC2XHI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>When I heared a kid who Firmly said I will be a video game programmer, I realize that it is extraordinary.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Take-your-Child-to-work-Day-at-Google-2018&quot;&gt;&lt;a href=&quot;#Take-your-Child-to-work-Day-at-Google-2018&quot; class=&quot;headerlink&quot; title=&quot;Take you
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Fragment Navigation Drawer</title>
    <link href="https://edward7zhang.github.io/2018/05/05/Fragment%20Navigation%20Drawer/"/>
    <id>https://edward7zhang.github.io/2018/05/05/Fragment Navigation Drawer/</id>
    <published>2018-05-05T14:20:07.000Z</published>
    <updated>2018-05-05T15:28:55.945Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://camo.githubusercontent.com/6d366e1a5c41a4fc25432102224848023987a8f8/68747470733a2f2f692e6c6f6c692e6e65742f323031382f30352f30352f356165643265643962393236632e706e67" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>..最近这段时间在着手做一个<a href="https://github.com/Edward7Zhang/Sorry-AndroidClient" target="_blank" rel="external">开源项目</a>..使用新鲜的Kotlin以及Google最经典的MaterialDesign..由于刚开始使用自然会碰到很多坑..上面是我的项目Logo🤣<br>本篇文章重点讲解最经典的MaterialDesign中的抽屉式布局 <a href="http://developer.android.com/training/implementing-navigation/nav-drawer.html" target="_blank" rel="external">Navigation Drawer</a>虽然AndroidStudio已经集成了Sample但跟手复现一遍还是很受益的。</p></blockquote><p>在2015年I/O大会上..Google发布了NavigationView，与之前的官方文档相比，本文档更容易创建完整的抽屉式布局<br>随着Android 5.0 Lollipop的发布，新的材料设计风格的抽屉横跨屏幕的整个高度，并显示在<code>ActionBar</code>半透明的上方并重叠<code>StatusBar</code>。<br>Like this：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/hPOFJUf.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>本指南将介绍如何建立一个基于MaterialDesign的可以切换不同Fragment到内容区域的抽屉式导航。In this way,you can define multiple fragments, and then define the list of options which will display in the drawers items list. Each item when clicked will switch the relevant fragment into the activity’s container view.</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>Make sure to setup the Google Design Support Library before using Google’s new NavigationView,announced as part of the Android M release. The NavigationView should be backwards compatible with all versions down to Android 2.1.</p><p>Make sure you have this Gradle dependency added to your <code>app/build.gradle</code> file:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.android.support:design:27.1.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Setup Drawer Resources</p><p>Create a <code>menu/drawer_view.xml</code> file:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_first_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_one"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"First"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_second_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_two"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"Second"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_third_fragment"</span></div><div class="line">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_three"</span></div><div class="line">            <span class="attr">android:title</span>=<span class="string">"Third"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Note that you can set one of these elements to be default selected by using <code>android:checked=&quot;true&quot;</code> .</p><p>You can also create subheaders too and group elements together:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:title</span>=<span class="string">"Sub items"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">                    <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_dashboard"</span></div><div class="line">                    <span class="attr">android:title</span>=<span class="string">"Sub item 1"</span> /&gt;</div><div class="line">                <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">                    <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_forum"</span></div><div class="line">                    <span class="attr">android:title</span>=<span class="string">"Sub item 2"</span> /&gt;</div><div class="line">            <span class="tag">&lt;/<span class="name">group</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/zoDqDKM.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Define-Fragments"><a href="#Define-Fragments" class="headerlink" title="Define Fragments"></a>Define Fragments</h3><p>接下来，你需要来定义你的Fragments，这些Fragments将会显示在你的Activity中。<br>These can be any support fragments you define within your application. Make sure that all the fragments extend from <strong>android.support.v4.app.Fragment</strong>.</p><h3 id="Setup-Toolbar"><a href="#Setup-Toolbar" class="headerlink" title="Setup Toolbar"></a>Setup Toolbar</h3><p>In order to slide our navigation drawer over the ActionBar, we need to use the new Toolbar widget as defined in the AppCompat v21 library.The <code>Toolbar</code> can be embedded into your view hierarchy which makes sure that the drawer slides over the <code>ActionBar</code>.</p><p>Create a new layout file <code>res/layout/toolbar.xml</code> with the following code:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">    <span class="attr">android:minHeight</span>=<span class="string">"?attr/actionBarSize"</span></div><div class="line">    <span class="attr">app:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimaryDark"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Note that when the <code>android:fitsSystemWindows</code> attribute is set to true for a view, the view would be laid out as if the <code>StatusBar</code> and the <code>ActionBar</code> were present i.e. the UI on top gets padding enough to not be obscured by the navigation bar. Without this attribute, there is not enough padding factored into consideration for the <code>ToolBar</code>:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/HaOAmoh.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>We want our main content view to have the navigation bar and hence <code>android:fitsSystemWindows</code> is set to true for the <code>Toolbar</code>.</p><p>To use the <code>Toolbar</code> as an <code>ActionBar</code>, you need to disable the default <code>ActionBar</code>. This can be done by setting the app theme in <code>styles.xml</code> file.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="xml"></span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#673AB7<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>#512DA8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>Also note that normally you should decide on your color scheme by going to <a href="http://www.materialpalette.com/" target="_blank" rel="external">Material Palette</a> and choosing a primary and dark primary color. For this example, we will pick purple-based colors as shown in the screenshot.</p><p><em>Note</em>: If you forget to disable the ActionBar in <code>styles.xml</code>, you are likely to see a <code>java.lang.IllegalStateException</code> with an error message that reads <code>This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead.</code>If you see this message, you need to make sure to follow the previous steps.</p><h3 id="Setup-Drawer-in-Activity"><a href="#Setup-Drawer-in-Activity" class="headerlink" title="Setup Drawer in Activity"></a>Setup Drawer in Activity</h3><p>Next, let’s setup a basic navigation drawer based on the following layout file which has the entire drawer setup in <code>res/layout/activity_main.xml</code>. Note that the <code>Toolbar</code> is added as the first child of the main content view by adding the include tag. <em>Note: if you are using a CoordinatorLayout, it must not lie outside of the DrawerLayout. See <a href="https://stackoverflow.com/questions/32523188/coordinatorlayout-appbarlayout-navigationdrawer" target="_blank" rel="external">https://stackoverflow.com/questions/32523188/coordinatorlayout-appbarlayout-navigationdrawer</a></em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- This DrawerLayout has two children at the root  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- This LinearLayout represents the contents of the screen  --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The ActionBar displayed at the top --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span></span></div><div class="line">            <span class="attr">layout</span>=<span class="string">"@layout/toolbar"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The main content view where fragments are loaded --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/flContent"</span></div><div class="line">            <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- The navigation drawer that comes from the left --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Note that `android:layout_gravity` needs to be set to 'start' --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/nvView"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span></div><div class="line">        <span class="attr">app:menu</span>=<span class="string">"@menu/drawer_view"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>Now, let’s setup the drawer in our activity. We can also setup the menu icon too.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> DrawerLayout mDrawer;</div><div class="line">  <span class="keyword">private</span> Toolbar toolbar;</div><div class="line"> <span class="keyword">private</span> NavigationView nvDrawer;</div><div class="line"></div><div class="line">  <span class="comment">// Make sure to be using android.support.v7.app.ActionBarDrawerToggle version.</span></div><div class="line"></div><div class="line"> <span class="comment">// The android.support.v4.app.ActionBarDrawerToggle has been deprecated.</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> ActionBarDrawerToggle drawerToggle;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="comment">// Set a Toolbar to replace the ActionBar.</span></div><div class="line"></div><div class="line">        toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">        setSupportActionBar(toolbar);</div><div class="line"></div><div class="line">        <span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">        mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">        <span class="comment">// The action bar home/up action should open or close the drawer.</span></div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (item.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> android.R.id.home:</div><div class="line">                mDrawer.openDrawer(GravityCompat.START);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Navigating-between-Menu-Items"><a href="#Navigating-between-Menu-Items" class="headerlink" title="Navigating between Menu Items"></a>Navigating between Menu Items</h3><p>Setup a handler to respond to click events on the navigation elements and swap out the fragment. This can be put into the activity directly:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...From section above...</span></div><div class="line"></div><div class="line">        <span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">        nvDrawer = (NavigationView) findViewById(R.id.nvView);</div><div class="line">        <span class="comment">// Setup drawer view</span></div><div class="line"></div><div class="line">        setupDrawerContent(nvDrawer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupDrawerContent</span><span class="params">(NavigationView navigationView)</span> </span>&#123;</div><div class="line">        navigationView.setNavigationItemSelectedListener(</div><div class="line">                <span class="keyword">new</span> NavigationView.OnNavigationItemSelectedListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</div><div class="line">                        selectDrawerItem(menuItem);</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectDrawerItem</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</div><div class="line">        <span class="comment">// Create a new fragment and specify the fragment to show based on nav item clicked</span></div><div class="line"></div><div class="line">        Fragment fragment = <span class="keyword">null</span>;</div><div class="line">        Class fragmentClass;</div><div class="line">        <span class="keyword">switch</span>(menuItem.getItemId()) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.nav_first_fragment:</div><div class="line">                fragmentClass = FirstFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.nav_second_fragment:</div><div class="line">                fragmentClass = SecondFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.nav_third_fragment:</div><div class="line">                fragmentClass = ThirdFragment.class;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                fragmentClass = FirstFragment.class;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fragment = (Fragment) fragmentClass.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Insert the fragment by replacing any existing fragment</span></div><div class="line"></div><div class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</div><div class="line">        fragmentManager.beginTransaction().replace(R.id.flContent, fragment).commit();</div><div class="line"></div><div class="line">        <span class="comment">// Highlight the selected item has been done by NavigationView</span></div><div class="line"></div><div class="line">        menuItem.setChecked(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// Set action bar title</span></div><div class="line"></div><div class="line">        setTitle(menuItem.getTitle());</div><div class="line">        <span class="comment">// Close the navigation drawer</span></div><div class="line"></div><div class="line">        mDrawer.closeDrawers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Add-Navigation-Header"><a href="#Add-Navigation-Header" class="headerlink" title="Add Navigation Header"></a>Add Navigation Header</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/Ri3c6Xz.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>The NavigationView also accepts a custom attribute that can reference a layout that provides a header of our layout. For instance, you can create a <code>layout/nav_header.xml</code> similar to the following:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"192dp"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimaryDark"</span></div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"16dp"</span></div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">    <span class="attr">android:gravity</span>=<span class="string">"bottom"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Header"</span></div><div class="line">        <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span></div><div class="line">        <span class="attr">android:textAppearance</span>=<span class="string">"@style/TextAppearance.AppCompat.Body1"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>You would then reference this in the layout <code>res/layout/activity_main.xml</code> in the <code>NavigationView</code> with the <code>app:headerLayout</code> custom attribute:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- res/layout/activity_main.xml --&gt;</span></div><div class="line"></div><div class="line"> <span class="comment">&lt;!-- The navigation drawer --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></div><div class="line">        <span class="attr">...</span></div><div class="line">        <span class="attr">app:headerLayout</span>=<span class="string">"@layout/nav_header"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.NavigationView</span>&gt;</span></div></pre></td></tr></table></figure><p>This <code>app:headerLayout</code> inflates the specified layout into the header automatically. This can alternatively be done at runtime with:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Lookup navigation view</span></div><div class="line"></div><div class="line">NavigationView navigationView = (NavigationView) findViewById(R.id.nav_draw);</div><div class="line"><span class="comment">// Inflate the header view at runtime</span></div><div class="line"></div><div class="line">View headerLayout = navigationView.inflateHeaderView(R.layout.nav_header);</div><div class="line"><span class="comment">// We can now look up items within the header if needed</span></div><div class="line"></div><div class="line">ImageView ivHeaderPhoto = headerLayout.findViewById(R.id.imageView);</div></pre></td></tr></table></figure><h3 id="Getting-references-to-the-header"><a href="#Getting-references-to-the-header" class="headerlink" title="Getting references to the header"></a>Getting references to the header</h3><p><strong>Note:</strong> Version <code>23.1.0</code> of the design support library switches <code>NavigationView</code> to using a <code>RecyclerView</code> and causes NPE (null exceptions) on header lookups unless the header is added at runtime. If you need to get a reference to the header, you need to use the new <code>getHeaderView()</code>method introduced in the latest <code>v23.1.1</code> update:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// There is usually only 1 header view.  </span></div><div class="line"></div><div class="line"><span class="comment">// Multiple header views can technically be added at runtime.</span></div><div class="line"></div><div class="line"><span class="comment">// We can use navigationView.getHeaderCount() to determine the total number.</span></div><div class="line"></div><div class="line">View headerLayout = navigationView.getHeaderView(<span class="number">0</span>);</div></pre></td></tr></table></figure><h2 id="动画汉堡图标"><a href="#动画汉堡图标" class="headerlink" title="动画汉堡图标"></a>动画汉堡图标</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/ekmWl7q.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了让汉堡包图标动画显示抽屉正在打开和关闭，我们需要使用<a href="https://developer.android.com/reference/android/support/v7/app/ActionBarDrawerToggle.html" target="_blank" rel="external">ActionBarDrawerToggle</a>类。</p><p>在你的<code>res/values/strings.xml</code>添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"drawer_open"</span>&gt;</span>Open navigation drawer<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"drawer_close"</span>&gt;</span>Close navigation drawer<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>我们需要将DrawerLayout和工具栏结合在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; </div><div class="line"><span class="comment">// Set a Toolbar to replace the ActionBar.</span></div><div class="line"></div><div class="line">toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">setSupportActionBar(toolbar);</div><div class="line"></div><div class="line"><span class="comment">// Find our drawer view</span></div><div class="line"></div><div class="line">mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);</div><div class="line">drawerToggle = setupDrawerToggle();</div><div class="line"></div><div class="line"><span class="comment">// Tie DrawerLayout events to the ActionBarToggle</span></div><div class="line"></div><div class="line">mDrawer.addDrawerListener(drawerToggle);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> ActionBarDrawerToggle <span class="title">setupDrawerToggle</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// <span class="doctag">NOTE:</span> Make sure you pass in a valid toolbar reference.  ActionBarDrawToggle() does not require it</span></div><div class="line"></div><div class="line">      <span class="comment">// and will not render the hamburger icon without it.  </span></div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, mDrawer, toolbar, R.string.drawer_open,  R.string.drawer_close);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>接下来，我们需要确保在恢复屏幕或配置发生变化（即屏幕旋转）时同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `onPostCreate` called when activity start-up is complete after `onStart()`</span></div><div class="line"></div><div class="line"><span class="comment">// NOTE 1: Make sure to override the method with only a single `Bundle` argument</span></div><div class="line"></div><div class="line"><span class="comment">// Note 2: Make sure you implement the correct `onPostCreate(Bundle savedInstanceState)` method. </span></div><div class="line"></div><div class="line"><span class="comment">// There are 2 signatures and only `onPostCreate(Bundle state)` shows the hamburger icon.</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onPostCreate(savedInstanceState);</div><div class="line">    <span class="comment">// Sync the toggle state after onRestoreInstanceState has occurred.</span></div><div class="line"></div><div class="line">    drawerToggle.syncState();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</div><div class="line">    <span class="comment">// Pass any configuration change to the drawer toggles</span></div><div class="line"></div><div class="line">    drawerToggle.onConfigurationChanged(newConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们还需要更改<code>onOptionsItemSelected()</code>方法并允许ActionBarToggle处理事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (drawerToggle.onOptionsItemSelected(item)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ActionBarToggle将执行与先前完成的功能相同的功能，但会添加更多检查，并允许鼠标​​单击图标以打开和关闭抽屉。有关更多上下文，请参阅<a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/src/android/support/v7/app/ActionBarDrawerToggle.java#L285-291" target="_blank" rel="external">源代码</a>。</p><p>有一点需要注意的是，ActionBarDrawerToggle会为您呈现汉堡图标的自定义<a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/src/android/support/v7/graphics/drawable/DrawerArrowDrawable.java" target="_blank" rel="external">DrawerArrowDrawable</a>。</p><p>另外，请确保使用的<code>android.support.v7.app.ActionBarDrawerToggle</code>版本。在<code>android.support.v4.app.ActionBarDrawerToggle</code>已被弃用。</p><h2 id="使状态栏半透明"><a href="#使状态栏半透明" class="headerlink" title="使状态栏半透明"></a>使状态栏半透明</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgur.com/o4WvT3k.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要使状态栏变成半透明状态并让我们的抽屉滑过它，我们需要将其设置<code>android:windowTranslucentStatus</code>为true。由于此样式不适用于之前的Kitkat设备，因此我们将为<code>res/values-v19/styles.xml</code>API版本19及之后的版本添加 文件。 <strong>注意</strong>：如果<code>res/values/styles.xml</code>直接用此<code>android:windowTranslucentStatus</code>行修改，则可能需要构建仅适用于19或更高版本的SDK，这显然会限制您支持许多较旧的设备。</p><p>在<code>res/values-v19/styles.xml</code>我们可以添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- Base application theme. --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="xml"></span></div><div class="line">    <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure><p>现在，如果你运行你的应用程序，你应该看到导航抽屉，并能够在你的片段之间进行选择。</p><h2 id="将自定义视图添加到导航抽屉"><a href="#将自定义视图添加到导航抽屉" class="headerlink" title="将自定义视图添加到导航抽屉"></a>将自定义视图添加到导航抽屉</h2><p>对设计支持库23.1.0所做的一项改进是增加了对导航抽屉项目的自定义视图的支持。例如，我们可以为其中一行创建自定义开关，如Google Play电影的导航抽屉：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/gCgB5PQ.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>该方法与将<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-actionview-items" target="_blank" rel="external">ActionView项目</a>添加到ActionBar相同。我们只需要定义一个单独的布局，如下面的代码片段。我们将调用这个文件<code>action_view_switch.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.SwitchCompat</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Switch"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>然后，我们使用该<code>app:actionLayout</code>属性引用此布局。标题必须提供，但也可以设置为空白：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_switch"</span></span></div><div class="line">        <span class="attr">app:actionLayout</span>=<span class="string">"@layout/action_view_switch"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"Downloaded only"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure><p>只要您的活动将实施该方法，您就可以直接使用XML附加事件。要通过Java以编程方式将事件处理添加到切换开关，您需要先获取菜单实例并访问相应的ActionView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Menu menu = navigationView.getMenu();</div><div class="line">MenuItem menuItem = menu.findItem(R.id.nav_switch);</div><div class="line">View actionView = MenuItemCompat.getActionView(menuItem);</div><div class="line">actionView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>自定义小部件的使用<code>app:actionViewClass</code>也可以用于菜单项目。有关Action Views的更多详细信息，请参阅将<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-searchview-to-actionbar" target="_blank" rel="external">SearchView</a>添加<a href="https://guides.codepath.com/android/Extended-ActionBar-Guide#adding-searchview-to-actionbar" target="_blank" rel="external">到ActionBar</a>指南。</p><h2 id="持久导航抽屉"><a href="#持久导航抽屉" class="headerlink" title="持久导航抽屉"></a>持久导航抽屉</h2><p>在某些情况下，特别是在平板电脑上，导航抽屉应该是充当侧栏的活动的永久固定装置(Like my Blog Design)：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/9f7nyrA.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要达到此效果，请查看以下描述一种方法的链接：</p><ul><li><a href="http://derekrwoods.com/2013/09/creating-a-static-navigation-drawer-in-android/" target="_blank" rel="external">静态导航抽屉</a></li><li><a href="http://stackoverflow.com/a/18095111" target="_blank" rel="external">相关的Stackoverflow问题</a></li><li><a href="https://github.com/samerzmd/Navigation-Drawer-set-as-always-opened-on-tablets" target="_blank" rel="external">示例代码</a></li></ul><p>第三方库也可能使这更容易实现。</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>有一些第三方库仍然可以作为<code>DrawerLayout</code>直接使用自动提供某些材料设计元素的替代方案：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/6WHIEX5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="external">MaterialDrawer</a></li><li><a href="https://github.com/rudsonlive/NavigationDrawer-MaterialDesign" target="_blank" rel="external">NavigationDrawerMaterial</a></li></ul><p>通常这些都是不必要的，但请检查它们以查看它们提供的功能。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>设计支持库的当前版本的确有其局限性。主要问题在于突出显示导航菜单中的当前项目的系统。NavigationView的itemBackground属性不能正确处理项目的选中状态：不管怎样，所有项目都突出显示或者没有任何项目。这使得这个属性基本上不适用于大多数应用程序。</p><h2 id="Fragment的替代品"><a href="#Fragment的替代品" class="headerlink" title="Fragment的替代品"></a>Fragment的替代品</h2><p>虽然许多导航抽屉示例显示了如何将Fragment用于导航抽屉，但如果您希望将抽屉用作当前显示的活动的叠加层，也可以使用<code>RelativeLayout</code>/ <code>LinearLayout</code>。</p><p>而不是<code>&lt;FrameLayout&gt;</code>你可以用一个<code>&lt;LinearLayout&gt;</code>替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">                <span class="attr">android:id</span>=<span class="string">"@+id/content_frame"</span></div><div class="line">                <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- The navigation drawer --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">android:id</span>=<span class="string">"@+id/left_drawer"</span></span></div><div class="line">                  <span class="attr">android:layout_width</span>=<span class="string">"240dp"</span></div><div class="line">                  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">                  <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></div><div class="line">                  <span class="attr">android:choiceMode</span>=<span class="string">"singleChoice"</span></div><div class="line">                  <span class="attr">android:divider</span>=<span class="string">"@android:color/transparent"</span></div><div class="line">                  <span class="attr">android:dividerHeight</span>=<span class="string">"0dp"</span></div><div class="line">                  <span class="attr">android:background</span>=<span class="string">"#111"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></div></pre></td></tr></table></figure><p>取而代之的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Insert the fragment by replacing any existing fragment</span></div><div class="line"></div><div class="line">getFragmentManager().beginTransaction()</div><div class="line">       .replace(R.id.content_frame, fragment)</div><div class="line">       .commit();</div></pre></td></tr></table></figure><p>您可以改为使用<code>LinearLayout</code>容器直接为活动充气：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LayoutInflater inflater = getLayoutInflater();</div><div class="line">LinearLayout container = (LinearLayout) findViewById(R.id.content_frame);</div><div class="line">inflater.inflate(R.layout.activity_main, container);</div></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html" target="_blank" rel="external">http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html</a></li><li><a href="http://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st" target="_blank" rel="external">http://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st</a></li><li><a href="http://antonioleiva.com/navigation-view/" target="_blank" rel="external">http://antonioleiva.com/navigation-view/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Material Design" scheme="https://edward7zhang.github.io/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>实验室招新题目①</title>
    <link href="https://edward7zhang.github.io/2018/04/27/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE/"/>
    <id>https://edward7zhang.github.io/2018/04/27/实验室招新题目/</id>
    <published>2018-04-27T10:00:07.000Z</published>
    <updated>2018-05-07T16:02:13.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摇篮排序"><a href="#摇篮排序" class="headerlink" title="摇篮排序"></a>摇篮排序</h1><h2 id="输入摇篮数组以摇篮中的序号为基准进行排序"><a href="#输入摇篮数组以摇篮中的序号为基准进行排序" class="headerlink" title="输入摇篮数组以摇篮中的序号为基准进行排序"></a>输入摇篮数组以摇篮中的序号为基准进行排序</h2><h2 id="请自定义Bucket的数据结构包括"><a href="#请自定义Bucket的数据结构包括" class="headerlink" title="请自定义Bucket的数据结构包括"></a>请自定义Bucket的数据结构包括</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;序号&#125;,&#123;学科&#125;&#125;</div></pre></td></tr></table></figure><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul><li><p>写出一个方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bucket[] sortBucket(Bucket[] J,boolean Flag)</div></pre></td></tr></table></figure></li><li><p>返回为排好序后的Bucket数组并在控制台中答应</p></li><li>Flag == true返回正序排序</li><li>Flag == false返回倒序排序</li></ul><h1 id="面向大一同学要求："><a href="#面向大一同学要求：" class="headerlink" title="面向大一同学要求："></a>面向大一同学要求：</h1><h2 id="在控制台中输入Bucket数组"><a href="#在控制台中输入Bucket数组" class="headerlink" title="在控制台中输入Bucket数组"></a>在控制台中输入Bucket数组</h2><h2 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h2><h2 id="input"><a href="#input" class="headerlink" title="input:"></a>input:</h2><ul><li>1 数学</li><li>3 语文</li><li>2 英语</li><li>true<h2 id="output"><a href="#output" class="headerlink" title="output:"></a>output:</h2></li><li>1 数学</li><li>2 英语</li><li>3 语文</li></ul><h1 id="面向大二同学要求："><a href="#面向大二同学要求：" class="headerlink" title="面向大二同学要求："></a>面向大二同学要求：</h1><h2 id="构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮"><a href="#构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮" class="headerlink" title="构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮"></a>构造自己熟悉的前端界面输入输出框以及正序倒序排序按钮</h2><h2 id="在其中输入Bucket数组"><a href="#在其中输入Bucket数组" class="headerlink" title="在其中输入Bucket数组"></a>在其中输入Bucket数组</h2><h2 id="example：-1"><a href="#example：-1" class="headerlink" title="example："></a>example：</h2><h2 id="input-1"><a href="#input-1" class="headerlink" title="input:"></a>input:</h2><ul><li>1 数学</li><li>3 语文</li><li>2 英语<h2 id="output-1"><a href="#output-1" class="headerlink" title="output:"></a>output:</h2></li><li>1 数学</li><li>2 英语</li><li>3 语文</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摇篮排序&quot;&gt;&lt;a href=&quot;#摇篮排序&quot; class=&quot;headerlink&quot; title=&quot;摇篮排序&quot;&gt;&lt;/a&gt;摇篮排序&lt;/h1&gt;&lt;h2 id=&quot;输入摇篮数组以摇篮中的序号为基准进行排序&quot;&gt;&lt;a href=&quot;#输入摇篮数组以摇篮中的序号为基准进行排序&quot; cla
      
    
    </summary>
    
    
      <category term="Lab_Interview" scheme="https://edward7zhang.github.io/tags/Lab-Interview/"/>
    
  </entry>
  
  <entry>
    <title>三年三月三天三小时</title>
    <link href="https://edward7zhang.github.io/2018/04/27/%E4%B8%89%E5%B9%B4%E4%B8%89%E6%9C%88%E4%B8%89%E5%A4%A9%E4%B8%89%E5%B0%8F%E6%97%B6/"/>
    <id>https://edward7zhang.github.io/2018/04/27/三年三月三天三小时/</id>
    <published>2018-04-26T17:42:07.000Z</published>
    <updated>2018-04-27T07:52:55.006Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" marginwidth="0" marginheight="0" width="300" height="50" src="https://music.163.com/outchain/player?type=2&id=1218773&auto=0&height=32"></iframe></p><h1 id="2018-04-26-14-27-👨‍💻"><a href="#2018-04-26-14-27-👨‍💻" class="headerlink" title="2018.04.26/14:27 👨‍💻"></a>2018.04.26/14:27 👨‍💻</h1><h3 id="我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。"><a href="#我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。" class="headerlink" title="我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。"></a>我收到了爱奇艺移动软件开发岗的Offer，诚惶诚恐。</h3><h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p>我的价值终于得到了认可…<strong>前20年的知识积奠..后3年的专业浅触..以及3个月来的准备..还有近3天以来的焦虑..最终是拿到Offer前3小时的不镇定</strong>…也许这种过程正是我踏入社会的开始以及最重要的是可以在我梦寐的大平台上开拓自己的视野强化自己的专业知识…这一切也来源于我3年以来的不懈…但更值得感谢的是我的伯乐–我的专业引路人刘老师和班导严老师在这三年来的照料与解惑…反观我三年前刚入校的木讷与轻浮..到现在可以负责实验室..以及得到社会的认可这一路来没有他们的指引我也许还在自己的混沌中不能自拔…<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c7ffc33f5.png" alt="My favorite mural Creazione di Adamo by Michelangelo" title="">                </div>                <div class="image-caption">My favorite mural Creazione di Adamo by Michelangelo</div>            </figure></p><ul><li><p>我也曾愣头青…在还未准备充分就冲去面试阿里…连续挂掉两次的腾讯面试…以及没有音讯的美团…到现在我心心念的还在等结果的大疆…以及我已拿到实习Offer的爱奇艺…</p></li><li><p>拿到Offer的我一点也没有激动…只是让我千疮百孔的心得到了一点满足…</p></li><li><p>在这一路的面试经历中我发现，我最终收益的还是我对专业的坚持…始终没有放弃我热爱的Android移动端开发..当出现新的技术..我总是首先想到应用于移动端…至少这种原力式的驱动来自于我的世界观..我认为在这个时代互联网的最大作用应该是带动人类发展进步..即使如今是个百家合唱的互联网环境..更多的企业选择了推动经济的捞钱式行为…大量的研发资源用于对娱乐或是低俗文化的传播…使得如今都是面向上市敲钟式创业…</p></li><li><p>异曲同工的是最近在年级群中看到有已面50家公司拿到3个Offer的人却大言不惭的写着面经..教唆想去参加工作的同学若是没有项目去某宝花钱购买…纯粹的面向面试的编程令人感到恶俗…地球科技的进步如果存在很多这样的人简直不堪想象吧…</p></li><li><p>如今这个时代有点伪文艺复兴的感觉…好像世间很纷乱…不是那么安定…但大家好像还过得自得其乐…这种自杀式的习惯在一点点的吞噬人类心灵最后的进取…</p></li></ul><h1 id="三年-👹"><a href="#三年-👹" class="headerlink" title="三年 👹"></a>三年 👹</h1><p>大学这三年来其实是憋了一口气的去追赶我高中三年所遗失的种种<br>三年后再看我倒是追回来了一些..这是值得肯定的<br>至少我没有被世俗赶上..至少我暂时赢得了自己的认可</p><h1 id="伯乐-🐎"><a href="#伯乐-🐎" class="headerlink" title="伯乐 🐎"></a>伯乐 🐎</h1><blockquote><p>世有伯乐，然后有千里马。千里马常有，而伯乐不常有。<br>我是一个傲慢的自谦的，不易被他人压制的，向往自由的人。</p></blockquote><p>这三年来我真心的感谢我的班导严灵毓老师、我的计算机语言入门人刘伟老师。<br>是他们的慧眼给了我进升的平台。<br>这两位老师的性格迥异对我来说是非常受益的…</p><ul><li>其一、那种对学生的关怀与学术上、人生上大义至简的指导与沟通是让我摆脱各种木讷与混沌的唯一绳索。</li><li>另一位、那种随性的不羁的帅气的男性风格成为了我对男性理解的标榜…作为我项目指导老师对我的信任，直接影响了我之后对软件产品的看法与理解…将项目大意解释与学生，其他的可以自我发挥的做法，至少目前我没有在其他老师身上发现过…这种对学生的信任同样也是让我辗转各种实验室后最终又回到Lab603的唯一理由…</li></ul><p>现在再回头看看这三年…充实又充满回忆…</p><h1 id="开发者同伴-😎"><a href="#开发者同伴-😎" class="headerlink" title="开发者同伴 😎"></a>开发者同伴 😎</h1><blockquote><p>如果拿伯牙与钟子期的故事来说我们可能过头..其实我们也没有到那种境界…只是想用这种感觉来表达我这三年来对他的感谢，他与我共同开发了我这三年来的大部分项目…</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c382bbaeb.jpg" alt="2016年10月12日 星期三 23:22 张睿在我的宿舍里一起重构项目看到结果后的喜悦" title="">                </div>                <div class="image-caption">2016年10月12日 星期三 23:22 张睿在我的宿舍里一起重构项目看到结果后的喜悦</div>            </figure><p>这三年来不下10个大大小小的项目其中2/3都是我和他共同开发的…无数个通宵..无数个需求的争执无数个问题的解决…在这一系列的过程中如果没有这样一个人的存在又会变得有多大的挑战呢？<br>我现在只能说张睿这三年来感谢你的互助，没有你我也走不到这一步…我会在这条路继续走下去的…只为了我们那无数个日夜的单纯的梦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2d43e09aaf.jpg" alt="2016年10月16日 星期日 3:11 我们合作的第一个项目OneKey2Alarm肝通宵" title="">                </div>                <div class="image-caption">2016年10月16日 星期日 3:11 我们合作的第一个项目OneKey2Alarm肝通宵</div>            </figure><h1 id="Project-⌨️"><a href="#Project-⌨️" class="headerlink" title="Project ⌨️"></a>Project ⌨️</h1><blockquote><p>项目之于开发者如同父与子的关系</p></blockquote><p>相信每一个开发者在完成他的Project后都会加倍心力的去维护他的Project…在这过程中也同时是开发者经验能力提升的关键…所以在面试过程中每个开发者在他过去完成的项目质量与数量就显得格外宝贵..通过项目的侧面观察可以看得出一个人的代码风格..他的个性..他的为人…所以如上文所述的那种面向面试的编程方式是我个人非常厌恶的…我认为只要是一个有追求的开发者..一个合格的程序员都十分摒弃这种做法…通过获取他人的劳动成果来打肿脸充胖子..总有一天会败露的。<br>真诚是一个人最美好也是最底线的品质…如果你想让这个世界达到公平那么久应该人人有责…通过不择手段的方式来通过面试这样对更多优秀的项目开发者无异于是一种侮辱…我周围的同学在最近找工作的过程中没有一个人是轻松的…一家家公司一次次的拒绝到让人怀疑自己…但说实话只有内心强大的人才能冲出这片混沌…因为从此之后你就会脱离象牙塔…不会再有人去庇护你…你要面对的是狰狞而残酷的社会..要为自己的言行负责了…人人不易…唯有坚持才能冲破重围…</p><blockquote><p>在这里同时想感谢我未来的部门领导..是他对我的认可..我才直接的得到了这一提升自己视野的机会…我会向自己证明他并没有看错</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c508827c3.jpg" alt="2018.04 武汉春季Hackthon" title="">                </div>                <div class="image-caption">2018.04 武汉春季Hackthon</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c50d2c899.jpg" alt="2018.04 凌晨4:00 武汉春季Hackthon" title="">                </div>                <div class="image-caption">2018.04 凌晨4:00 武汉春季Hackthon</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c50919947.jpg" alt="2018.04 武汉春季Hackthon 产品展示" title="">                </div>                <div class="image-caption">2018.04 武汉春季Hackthon 产品展示</div>            </figure><h1 id="家庭-👪"><a href="#家庭-👪" class="headerlink" title="家庭 👪"></a>家庭 👪</h1><ul><li>我拥有这样的家庭应该是我人生走过20年所幸至极之事</li><li>父母对我的关心与爱护适合且得当</li><li>父母对我的放养式管理我称为“不管之恩”这种做法间接的使我自由发展寻我所乐</li><li>父母对我的无条件支持我的选择使我受益</li><li>生于张先生与陈女士是我这一生无可比拟的幸运</li></ul><p>感谢我的父母让我度过了无忧的童年、少年..未来世界的狰狞我已经可以独自去面对了，也请你们放心<br>我永远爱你们❤️</p><h1 id="Last-but-not-least-💪"><a href="#Last-but-not-least-💪" class="headerlink" title="Last but not least 💪"></a>Last but not least 💪</h1><p>通过我一次次的失败..经验的积累..也拿到了如愿的Offer…<br>我明白这并不是标榜着什么..而是又一次新的开始..我这长久以来只是在为自己争取去更好的平台学习..发展…<br>在此想给未来的自己说：不要让你之前的努力白费..保持自己的梦想..不要被世俗侵染..保持学习..保持竞争力..切勿自满…</p><blockquote><p>记一个即将步入社会的男生回首过去20年的狰狞与对自己未来的勉励</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/04/27/5ae2c515a6cd2.jpg" alt="Lab603 我的工位 ;-)" title="">                </div>                <div class="image-caption">Lab603 我的工位 ;-)</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;300&quot; height=&quot;50&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=12
      
    
    </summary>
    
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Java与Kotlin下的6种单例模式</title>
    <link href="https://edward7zhang.github.io/2018/04/25/Java%E4%B8%8EKotlin%E4%B8%8B%E7%9A%846%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://edward7zhang.github.io/2018/04/25/Java与Kotlin下的6种单例模式/</id>
    <published>2018-04-25T05:44:14.000Z</published>
    <updated>2018-04-26T11:15:00.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b9b7aa8c2779e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在学习Kotlin，由于Google粑粑把这一语言提携为官方指定，并且对于移动端等开发得天独厚的优势，作为一名AndroidDeveloper学习Kotlin是必要的。<br>当初在学习Java时对单例模式的六种书写与应用记忆深刻<br>所以这次对不同单例模式的Java与Kotlin实现进行了分别探讨。</p></blockquote><p>六种模式如下：</p><ul><li>饿汉模式</li><li>懒汉模式</li><li>线程安全的懒汉模式</li><li>双重校验锁式</li><li>静态内部类式</li><li>枚举式</li></ul><hr><h1 id="饿汉模式：static-final-field"><a href="#饿汉模式：static-final-field" class="headerlink" title="饿汉模式：static final field"></a>饿汉模式：static final field</h1><p>饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。<br>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="comment">//类加载时就初始化</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Kotlin引入了 <code>object</code>类型，可以很容易声明单例模式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="keyword">object</span> Singleton</div></pre></td></tr></table></figure></p><p>这种方式和 Java 单例模式的饿汉式一样，不过比 Java 中的实现代码量少很多，其实是个语法糖（Kotlin漫山遍野都是语法糖）。反编译生成的 class 文件后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        INSTANCE = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从反编译的代码可以看出 object 对象实际上还是利用了 INSTANCE 静态变量，但是在Java和Kotlin混编时，Java代码中调用则需要注意，使用如下<code>Singleton.INSTANCE.test()</code>,Kolint中调用时只需要使用<code>Singleton.test()</code>。<br>这种实现方式在类加载时就创建了单例对象，所以肯定是线程安全的，但是还是有饿汉式实现方式的问题：</p><ul><li>如果构造方法中有耗时操作的话，会导致这个类的加载比较慢。</li><li>饿汉式一开始就创建实例，但是并没有调用，会造成资源浪费。</li><li>还有一个 Java 饿汉式单例模式没有的问题：无法自定义构造函数，object 中不允许 constructor 函数。</li></ul><h1 id="懒汉模式：线程不安全"><a href="#懒汉模式：线程不安全" class="headerlink" title="懒汉模式：线程不安全"></a>懒汉模式：线程不安全</h1><p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance : Singleton? = <span class="literal">null</span></div><div class="line">        <span class="keyword">get</span>()&#123;</div><div class="line">            <span class="keyword">if</span>(field == <span class="literal">null</span>)&#123;</div><div class="line">                field = Singleton()</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> field</div><div class="line">        &#125; </div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>:Singleton&#123;</div><div class="line">            <span class="keyword">return</span> instance!!</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上述代码中，我们可以发现在Kotlin实现中，我们让其<strong>主构造函数私有化</strong>并自定义了其<strong>属性访问器</strong>，其余内容大同小异。</p><ul><li>如果不清楚Kotlin构造函数的使用方式。请点击 - - - <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fclasses.html" target="_blank" rel="external">构造函数</a></li><li>不清楚Kotlin的属性与访问器，请点击 - - -<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fproperties.html" target="_blank" rel="external">属性和字段</a></li></ul><h1 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h1><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></div><div class="line">            <span class="keyword">get</span>() &#123;</div><div class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</div><div class="line">                    field = Singleton()</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> field</div><div class="line">            &#125;</div><div class="line">        <span class="meta">@Synchronized</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: Singleton&#123;</div><div class="line">            <span class="keyword">return</span> instance!!</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>大家都知道在使用懒汉式会出现线程安全的问题，需要使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加 <strong>@Synchronized</strong> 注解</p><h1 id="双重校验锁式"><a href="#双重校验锁式" class="headerlink" title="双重校验锁式"></a>双重校验锁式</h1><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * volatile保证了：</div><div class="line"> * 1.instance再多线程下的并发可见性</div><div class="line"> * 2.禁止instance在操作时的指令重排序</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getIntance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="comment">//第一次判空，保证不必要的同步</span></div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line"><span class="comment">//synchronized对Singleton加全局锁，保证每次只要一个线程创建实例</span></div><div class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line"><span class="comment">//第二次判空时为了在null的情况下创建实例</span></div><div class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">instance = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。<strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><ul><li>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</li></ul><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</div><div class="line">        <span class="keyword">val</span> instance: Singleton <span class="keyword">by</span> lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123;</div><div class="line">            SingletonDemo()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的<strong>延迟属性 Lazy</strong>。</p><p><strong>Lazy</strong>是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</p><p>这里还有有两个额外的知识点。</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Flambdas.html" target="_blank" rel="external">高阶函数</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fdelegated-properties.html" target="_blank" rel="external">委托属性</a></li></ul><p>如果你了解以上知识点，我们直接来看Lazy的内部实现。</p><ul><li>Lazy内部实现</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: ()</span></span> -&gt; T): Lazy&lt;T&gt; =</div><div class="line">        <span class="keyword">when</span> (mode) &#123;</div><div class="line">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</div><div class="line">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</div><div class="line">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>观察上述代码，因为我们传入的<strong>mode = LazyThreadSafetyMode.SYNCHRONIZED</strong>， 那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。</p><ul><li>Lazy接口</li></ul><p>SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lazy</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</div><div class="line">     <span class="comment">//当前实例化对象，一旦实例化后，该对象不会再改变</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</div><div class="line">    <span class="comment">//返回true表示，已经延迟实例化过了，false 表示，没有被实例化，</span></div><div class="line">    <span class="comment">//一旦方法返回true，该方法会一直返回true,且不会再继续实例化</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>继续查看SynchronizedLazyImpl，具体实现如下：</p><ul><li>SynchronizedLazyImpl内部实现</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;</span>(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</div><div class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</div><div class="line">    <span class="comment">// final field is required to enable safe publication of constructed instance</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</div><div class="line">        <span class="keyword">get</span>() &#123;</div><div class="line">            <span class="keyword">val</span> _v1 = _value</div><div class="line">            <span class="comment">//判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑</span></div><div class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></div><div class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</div><div class="line">                <span class="keyword">val</span> _v2 = _value</div><div class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                    <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span> (_v2 <span class="keyword">as</span> T)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">val</span> typedValue = initializer!!()<span class="comment">//调用高级函数获取其返回值</span></div><div class="line">                    _value = typedValue   <span class="comment">//将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值</span></div><div class="line">                    initializer = <span class="literal">null</span></div><div class="line">                    typedValue  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。</p><p>到里这里其实大家还是肯定有疑问，我这里<strong>只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢？</strong>。这里又涉及到了<strong>委托属性</strong>。</p><p>委托属性语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。</p><p>而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@kotlin.internal.InlineOnly</div><div class="line">//返回初始化的值。</div><div class="line">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value</div></pre></td></tr></table></figure><h1 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h1><p>这种方法也是《Effective Java》上所推荐的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种写法仍然使用JVM本身机制保证了线程安全的问题。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，<strong>第一次调用getInstance()时将内部类SingletonHodler</strong>，在该内部类中定义了一个static类型的变量INSTANCE，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于SingletonHodler是私有的，除了getInstance()之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="keyword">val</span> instance = SingletonHolder.holder</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">object</span> SingletonHolder &#123;</div><div class="line">        <span class="keyword">val</span> holder= Singleton()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="枚举式：Enum"><a href="#枚举式：Enum" class="headerlink" title="枚举式：Enum"></a>枚举式：Enum</h1><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java实现</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Kotlin实现</span></div><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">EasySingleton</span></span>&#123;</div><div class="line">INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b9b7aa8c2779e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="Java" scheme="https://edward7zhang.github.io/tags/Java/"/>
    
      <category term="Kotlin" scheme="https://edward7zhang.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>记一次呆若木鸡的面试</title>
    <link href="https://edward7zhang.github.io/2018/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%91%86%E8%8B%A5%E6%9C%A8%E9%B8%A1%E7%9A%84%E9%9D%A2%E8%AF%95/"/>
    <id>https://edward7zhang.github.io/2018/04/24/记一次呆若木鸡的面试/</id>
    <published>2018-04-24T14:24:14.000Z</published>
    <updated>2018-04-24T14:52:45.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一道很简单很简单的入门题…核心就是一个我高中就学过的数学知识…叉积…可惜年久不用…在面试的紧要关头就显得呆若木鸡…很遗憾没有表现出自己的真实水平…</p></blockquote><pre><code>/* ** 在一个平面中.任意一个直线线段可以由2个点表示,任意一个点可以由X,Y坐标值表示.*例如线段 J 由 点A(x1, y1), B(x2, y2)表示. 其中坐标值 x,y 都为int. *求写出一个方法, boolean checkIntersect(Line J, Line K); *检查在平面中给出的2个线段是否相交, return true 代表线段相交, false 为不想交. *请自行定义线段Line的数据结构, 并可以假设传入参数Line J 和 Line K 为有效输入. */</code></pre><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aiqyInterview;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckIntersect</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> EdwardZhang</div><div class="line"> * 判断线段相交：</div><div class="line"> * 两个线段的交点个数可能有0个 1个或者无数个</div><div class="line"> * 判断两个线段相交，可以按照如下步骤：</div><div class="line"> * 判断A点B点是否在线段CD的两侧，即计算叉积时异号</div><div class="line"> * 判断C点和D点是否在线段AB的两侧，即计算叉积时异号</div><div class="line"> * 然后在处理特殊情况，即ABCD四个点有至少三个点共线的情况，</div><div class="line"> * 即出现叉积为零的情况，如果A点与线段CD共线，</div><div class="line"> * 则要查看A点是否在线段CD上，其它情况依次类推。</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.x = x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</div><div class="line">Point A = <span class="keyword">new</span> Point();</div><div class="line">Point B = <span class="keyword">new</span> Point();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">getA</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> A;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">A.x = i;</div><div class="line">A.y = j;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">getB</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">B.x = i;</div><div class="line">B.y = j;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">direct</span><span class="params">(Point i, Point j, Point k)</span> </span>&#123; <span class="comment">// 计算叉积</span></div><div class="line"><span class="keyword">return</span> (k.x - i.x) * (j.y - i.y) - (j.x - i.x) * (k.y - i.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onSegment</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="comment">// 共线时，判断点是否落在线段</span></div><div class="line"><span class="keyword">float</span> minx = Math.min(a.x, b.x);</div><div class="line"><span class="keyword">float</span> maxx = Math.max(a.x, b.x);</div><div class="line"><span class="keyword">float</span> miny = Math.min(a.y, b.y);</div><div class="line"><span class="keyword">float</span> maxy = Math.max(a.y, b.y);</div><div class="line"><span class="keyword">if</span> (c.x &gt;= minx &amp;&amp; c.x &lt;= maxx &amp;&amp; c.y &gt;= miny &amp;&amp; c.y &lt;= maxy) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkIntersect</span><span class="params">(Line X, Line Y)</span> </span>&#123;</div><div class="line"><span class="keyword">float</span> d1 = direct(Y.A, Y.B, X.A);</div><div class="line"><span class="keyword">float</span> d2 = direct(Y.A, Y.B, X.B);</div><div class="line"><span class="keyword">float</span> d3 = direct(X.A, X.B, Y.A);</div><div class="line"><span class="keyword">float</span> d4 = direct(X.A, X.B, Y.B);</div><div class="line"><span class="keyword">if</span> (d1 * d2 &lt; <span class="number">0</span> &amp;&amp; d3 * d4 &lt; <span class="number">0</span>)</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d1 == <span class="number">0</span> &amp;&amp; onSegment(Y.A, Y.B, X.A))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; onSegment(Y.A, Y.B, X.B))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d3 == <span class="number">0</span> &amp;&amp; onSegment(X.A, X.B, Y.A))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d4 == <span class="number">0</span> &amp;&amp; onSegment(X.A, X.B, Y.B))</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">CheckIntersect checkIntersect = <span class="keyword">new</span> CheckIntersect();</div><div class="line">Line a = checkIntersect.new Line();</div><div class="line">Line b = checkIntersect.new Line();</div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//相交 true</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//相离 false</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">b.setB(<span class="number">4</span>, <span class="number">2</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//平行 false</span></div><div class="line">a.setA(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">a.setB(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">b.setA(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">b.setB(<span class="number">3</span>, <span class="number">3</span>);</div><div class="line">System.out.println(checkIntersect(a,b));<span class="comment">//在一条直线上 true</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一道很简单很简单的入门题…核心就是一个我高中就学过的数学知识…叉积…可惜年久不用…在面试的紧要关头就显得呆若木鸡…很遗憾没有表现出自己的真实水平…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;/* *

* 在一个平面中.任意一个
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>计算机系应届生求职指北</title>
    <link href="https://edward7zhang.github.io/2018/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%BA%94%E5%B1%8A%E7%94%9F%E6%B1%82%E8%81%8C%E6%8C%87%E5%8C%97/"/>
    <id>https://edward7zhang.github.io/2018/04/19/计算机系应届生求职指北/</id>
    <published>2018-04-19T01:07:14.000Z</published>
    <updated>2018-04-19T05:18:21.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天早晨看到了Easy大大的这篇文章，在文章中读到了自己的影子，并且也明白了这段时间自己在实习招聘中的不足，受益匪浅。希望我的好友可以看到从中受益<br>特此转载 From：<a href="https://github.com/easychen/career-guide-for-cs-graduate" target="_blank" rel="external">https://github.com/easychen/career-guide-for-cs-graduate</a></p></blockquote><h1 id="计算机系应届生求职指北"><a href="#计算机系应届生求职指北" class="headerlink" title="计算机系应届生求职指北"></a>计算机系应届生求职指北</h1><p>最近帮了一个朋友的朋友做了下职业规划，结合之前在微博上的一些问答，觉得不少应届生同学对求职有蛮多误解的，所以这里分享下我的一点经验吧。虽然本文题为指北，但只是一个面向对行业、对业界技术不熟悉的同学的操作手册。各位技术大牛可能觉得粗浅，请见谅。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh5iysqx1j20qy0f50xb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p>本文略长，会谈及以下问题。</p><ul><li>职业规划越早越好</li><li>一定要珍惜校招的机会窗口</li><li>应届生的求职策略</li><li>技术职位的选择</li><li>语言和技术栈的选择</li><li>技术栈的优化</li><li>简历的书写</li></ul><p>下边我们一点一点来讲。</p><blockquote><p>本文作者 @Easy （ <a href="http://weibo.com/easy" target="_blank" rel="external">weibo.com/easy</a> ），方糖全栈课（ <a href="http://quanzhanke.com" target="_blank" rel="external">quanzhanke.com</a> ）主讲人，有多年大规模网站、云平台开发经验、曾运营过用户数十万的程序员拍卖平台，为上千名程序员找过工作。转载请保留以上作者信息和链接，谢谢。</p></blockquote><p>内容更新通知</p><p>可微信扫码（未关注直接关注）订阅本指北更新。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh6g6fiauj20by0byq3p.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <h2 id="职业规划越早越好"><a href="#职业规划越早越好" class="headerlink" title="职业规划越早越好"></a>职业规划越早越好</h2><p>职业是一个非常特殊的东西，它有两点很特别，一个是「不可重来」，另一个是「验证耗时」。之前和一个老友聊天，他感叹说，回过头看看，自己的整个职业过得乱七八糟。等到现在明白这点的时候，已经来不及了。因为一般一段职业经历短则一到两年，长则三到五年。换两家公司，十年一晃就过去了。如果你在这十年中没有很好的成长，又不幸身在某些公司，那三十多岁可能就面临被清退的处境了。</p><p>我一般不屑于去和别人分享什么人生经验，毕竟有些坑不自己跳下去是不会牢记在心的。但职业的坑不一样，等你发现在坑里时，可能已经晚了。所以我花了蛮多时间来研究这个。有兴趣的同学可以去读读我的《程序员跳槽全攻略》，专门讲职业规划的。( 在我的个人网站上可以免费读 <a href="http://t.cn/RYh1xhS" target="_blank" rel="external">方糖气球🎈|程序员跳槽全攻略</a> ) </p><h2 id="一定要珍惜校招的机会窗口"><a href="#一定要珍惜校招的机会窗口" class="headerlink" title="一定要珍惜校招的机会窗口"></a>一定要珍惜校招的机会窗口</h2><p>我大学的语文老师曾告诫我们说，人生就像四季一样，春天该播种，你去播种，秋天该收获，你去收获，这样是最省力的。你非要倒过来呢，也不是不行，但就是会很累，会付出更多的精力和代价。</p><p>校招也类似，它是社会和企业为从未步入职场的同学特意准备的一个绿色通道。在这个通道里，我们将候选人当做一张白纸，可以没有经验、没有行业常识，只要对工作充满热情、有还算聪明的头脑，基本都算是合格的。企业会为这些同学准备培训，并留足适应期，有的甚至还会安排一对一的老员工来带。</p><p>但是，一旦你错过了它，那一切都不一样了，因为你进入了名为「社招」的红海。在这里，所有已经毕业的人变成了你的竞争对手，不但要面对和你一样工作年限的人竞争，还要面对其他工作时间更长、经验更丰富的同行跳槽带来的竞争。甚至经常发生因为招到了一个中级岗位的候选人，取消掉两个初级岗位的情况。</p><p>所以校招非常重要，一定不要错过。</p><h2 id="应届生的求职策略"><a href="#应届生的求职策略" class="headerlink" title="应届生的求职策略"></a>应届生的求职策略</h2><p>既然校招这么重要，那么我们怎么才能在其中占据优势呢？记住两个词「择优录取」和「跑赢同学」。</p><h3 id="择优录取"><a href="#择优录取" class="headerlink" title="择优录取"></a>择优录取</h3><p>在微博上经常可以看到这样的问题：「我这个也会、那个也合格，凭什么他们就不招我呢？」这是典型的没有明白招聘本质的表现。要明白，求职不是「会考」而是「高考」，不是什么产品的出厂合格校验，而是一场中国这个资源紧缺型国家里的又一场优质资源争夺战。</p><p>那些薪水高、发展空间好的知名企业（后文简称大厂），每年招聘的人数是一定的。极端点说，如果现在所有候选人的水平都下调20%，他们依然要招人的，不然没法发展（严格讲会有一些调整空间，但也扛不了多久）。</p><p>所以，尤其是在校招里边，「绝对值」并不重要，「相对值」才是最重要的。</p><h3 id="跑赢同学"><a href="#跑赢同学" class="headerlink" title="跑赢同学"></a>跑赢同学</h3><p>我来讲一个很老的童话，听过的同学请装作没听过。两个人在森林里边遇到了熊🐻，kuma 看见他们就嗷嗷的追了过来。一个同学转身就跑，另一个问他说，我们怎么跑也跑不过熊的，那跑有什么用呢？这个同学回答说，我只要跑赢你就好了呀。</p><p>那其实校招也是一样的。它不是说你的能力要有多少，其实再牛的应届生的水平放到行业里边，都是不入流的，因为很多水平是靠海量的用户压出来的，你没有遇到过这些场景，怎么可能知道怎么去应对。</p><p>所以应届生和那些社招的候选人比，通常都是没啥胜算的，但幸运的是，我们和他们是不同的赛道。要跑赢一个在大厂核心岗位工作了一两年的人不容易，但要跑赢那些和你一样在大学只学了一堆理论基础，甚至理论课都没好好学天天在寝室吃鸡的同学，就容易很多了。</p><p>要承认，即使这样，要跑赢某些天资聪颖、能力拔群的学霸还是有难度的。但这场比赛是不公平的，因为它没规定每个人必须同时开始跑。鲁迅说得好，笨鸟先飞。（鲁迅：我没有说过）如果我们能更早的认识到这点，花更多时间去准备，那么赢的概率就会成倍提升。</p><p>我本身就是一个非常好的例子。严格的讲，我的能力算是平庸偏上一点点的，虽然在当时无论如何我都不会承认。当我在大一下半期认识到这一点时，就开始自学 PHP，大二的时候写了一堆没人用的开源项目，大三上半期找了家公司做兼职，已经能把学费挣回来了。当大三下半期开始找实习时，我的简历已经可以秒杀同校同学，小小PK 一流高校的同学了。</p><p>所以你以为校招比的是能力，其实对于执行力中等、同样天赋的同学来讲，校招比的其实是认知。越早认识到本质的人，就越容易在这场游戏里边胜出。从这个角度讲，坚持读到这里的你，甚至可能已经赢了一半了。所以记得要把这篇文章分享给你的好朋友，然后千万别让你不喜欢的同学知道。</p><h2 id="技术岗位的选择"><a href="#技术岗位的选择" class="headerlink" title="技术岗位的选择"></a>技术岗位的选择</h2><p>技术岗位的大体分布如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nht0kdj20vn0hhmz8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在几乎所有的软件都已经互联网化了，就算没有互联网化的，它以后也会互联网化，所以我们就不单纯地去说软件开发这个行业了。</p><h4 id="开发岗"><a href="#开发岗" class="headerlink" title="开发岗"></a>开发岗</h4><p>首先就是开发岗，这个就包括了前端开发、后端开发和移动开发。</p><p>前端开发和后端开发，主要是 B/S 结构里的。B/S 结构就是 Browser-Server 结构。而前端指的就是浏览器这个端；后端指的就是服务器这个端。</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>前端主要做的事情，就是把从服务器端读取到的数据展现给用户，然后通过各种 UI 控件和用户互动，再将新的数据送回服务器端。具体的技术包括 HTML、CSS、JavaScript，还可能有一些嵌入浏览器运行的组件，比如 Flash 、 WebGL 。</p><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>后端则主要送数据给前端，一般有两种方式，以前用的比较多的是，将数据在服务器端先渲染完，然后将输出的结果发送给前端；现在用的比较多的方式是将纯数据通过 Json 或者 xml 等格式发送给前端，在浏览器中通过 JS 来进行渲染。</p><p>所以以前很多后端的工程师往往也懂一些前端的知识，比如我认识的很多 PHP 程序员，他们不但懂 MySQL 和 Apache，还懂 HTML 、 CSS 、 JS 和 PS。这种前后端都懂的工程师，也叫全栈工程师。</p><p>后端可以用各种语言开发，国内用的比较多的包括 Java、PHP ，还有相对小众一些的 Python 、 Ruby 、 Go。其实 C 也是可以写后端的，不过现在已经很少有公司直接用它写了。</p><p>后来有了 NodeJS ，JavaScript 也能跑到后端了，所以很多前端工程师也有了后端开发的能力，他们也占了全栈工程师的很大一部分。</p><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>相对于 B/S 结构，还有 C/S 结构，就是 Client-Server 。C/S 结构下不用浏览器来展现数据和交互，而是用客户端，一般是 Mac/Win/Linux 三大平台。</p><h5 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h5><p>手机大潮起来以后，不管是 B/S 结构还是 C/S 结构，全部移动化了。B/S 结构对应的就是适配手机浏览器的移动网页、以及嵌入在微信、微博里边的 H5 页面; C/S 结构就是 APP ，一般覆盖 iOS 和 Android 两个主流平台。</p><p>除了这些标准开发岗，而还有一些新兴或者相对小众的开发方向，比如人工智能/算法工程师、做智能硬件的硬件开发工程师、给企业做解决方案的企业软件工程师。</p><h4 id="其他岗位"><a href="#其他岗位" class="headerlink" title="其他岗位"></a>其他岗位</h4><p>软件并不是开发出来就完了的，在上线或者发布之前，我们还需要「测试工程师」来进行测试；而上线以后，还需要「运维工程师」来管理和优化服务器集群。现在服务器都虚拟化和容器化了，运维工程师中也出现了懂开发的分支，叫做 DevOps。</p><h4 id="中高级岗位"><a href="#中高级岗位" class="headerlink" title="中高级岗位"></a>中高级岗位</h4><p>不管是开发岗还是测试、运维岗，都有其对应的中高级岗位。开发一般是技术经理；运维一般是架构师；测试一般是测试总监。技术总监、CTO 就是更高一级的职位了。</p><p>以上的职位分类我们参考了招聘网站的分类，不一定准确，可能会有很多岗位没覆盖到，不少公司也会有自己独特的岗位设置。</p><h3 id="职位的选择"><a href="#职位的选择" class="headerlink" title="职位的选择"></a>职位的选择</h3><p>如果能选择的话，不建议一开始就选运维或者测试。原因有两个：第一，因为它们虽然很重要，但不是软件开发的核心岗位。第二，从开发岗往这两个职位转非常容易，反之却非常难。</p><p>之前在给掘金写《程序员职业小白书》的时候，我做过一个邮件访谈，以问题的形式采访了多位在不同阶段、不同岗位、不同城市的程序员的日常。大家可以读一读，了解下。<a href="https://juejin.im/book/59e17a7ff265da430629cc4e/section/59faea95f265da430d575a22" target="_blank" rel="external">程序员们的日常是怎样的</a> （虽然这个小册是收费的，但访谈这一章却是可以免费读的，不需要购买哈）</p><h2 id="语言和技术栈的选择"><a href="#语言和技术栈的选择" class="headerlink" title="语言和技术栈的选择"></a>语言和技术栈的选择</h2><h3 id="语言概况"><a href="#语言概况" class="headerlink" title="语言概况"></a>语言概况</h3><p>虽然出于某种政治正确，我们一般都会说，语言不重要。但语言真的不重要么？并不是这样的，每种语言都有自己的优缺点和适用范围。</p><p>像日语和英语一样，一个是看动画玩游戏用的，一个是看资料写代码用的。（误）<br>下边简单介绍下我眼中的各个语言。</p><h4 id="C-C-："><a href="#C-C-：" class="headerlink" title="C/C++ ："></a>C/C++ ：</h4><p>系统语言，用来写底层操作系统、高性能中间件和嵌入式开发。</p><h4 id="Python：人工智能的好选择"><a href="#Python：人工智能的好选择" class="headerlink" title="Python：人工智能的好选择"></a>Python：人工智能的好选择</h4><p>举例来说，如果你想做人工智能方向的话，Python语言就是非常不错的选择。因为它在各个大学和研究机构用的非常多，有成熟好用的数学库，适合于科学计算。在深度学习等热门方向上，有大量用 Python 开发的框架，新出的 Paper 也能很快在 GitHub 上找到 Python 的代码实现，可以说是不二选择了。</p><h4 id="JavaScript：前端和全端"><a href="#JavaScript：前端和全端" class="headerlink" title="JavaScript：前端和全端"></a>JavaScript：前端和全端</h4><p>如果你想做前端，那么目前来看，除了 JavaScript 还真没有别的选择，因为现在能在浏览器里边跑起来，也就是它了。过两年等 wasm 成熟可能会有其他选择，但现在，是真没有。</p><p>而相应的，如果你学会了 JavaScript ，想在这个基础上再把后端给做了，那么 Node.JS 就是非常好的选择。因为它使用的就是 JavaScript 的解释器，按 JavaScript 写就好了。从学习成本上来讲，它是非常低的，可以通过很低的投入，就进入了服务器端的领域。</p><h4 id="PHP：依然是网站首选"><a href="#PHP：依然是网站首选" class="headerlink" title="PHP：依然是网站首选"></a>PHP：依然是网站首选</h4><p>如果你要做网站，那么 PHP 就是首选了。一方面是有大量的可用代码，世界上超过80%的网站都用的 PHP，基本上你能想到的网站功能，都有能找到的实现，悬念只是有没有免费的；另一方面，PHP7 的性能提升了很多，用来写 API 也非常好。</p><p>另外一点，就是目前使用 PHP 的团队非常多，即使在二三线城市也比较容易找到工作，当然，组建团队也同样相对容易。</p><h4 id="Java：大数据分析"><a href="#Java：大数据分析" class="headerlink" title="Java：大数据分析"></a>Java：大数据分析</h4><p>如果你要做大数据分析，那么可能就离不开 Java 了。<br>从 Hadoop 开始一系列的 Google Big Table 的开源实现都是 Java 的，用于海量数据搜索的 Elastic Stack 也是 Java 的。</p><h4 id="Go：云计算和容器管理"><a href="#Go：云计算和容器管理" class="headerlink" title="Go：云计算和容器管理"></a>Go：云计算和容器管理</h4><p>如果你现在要想去做云计算，那 Go 就是一个非常好的选择。</p><p>因为它就是为了大规模计算设计的，并发管理和性能都非常不错。而且有很多云计算的软件，它就是 Go 写的，如果你要去修改它，调整里边的实现逻辑的话，不会 Go 可能很麻烦。当然，理论上讲，你也可以通过容器和微服务的方式来搞定，但肯定比直接改代码麻烦。</p><p>另外区块链的大热平台以太坊的官方（最具潜力）实现，也是Go做的。钱途大大的。</p><h3 id="语言的选择"><a href="#语言的选择" class="headerlink" title="语言的选择"></a>语言的选择</h3><h4 id="兴趣优先"><a href="#兴趣优先" class="headerlink" title="兴趣优先"></a>兴趣优先</h4><p>在语言的选择上，尤其是第一门语言的选择上，我一直推荐兴趣优先的原则。因为对初学者而言，当你遇到困难坚持不下去时，兴趣会帮你一把。中学时为了改仙剑，我连汇编都试着学了个入门 🤣</p><h4 id="市场其次"><a href="#市场其次" class="headerlink" title="市场其次"></a>市场其次</h4><p>但其实对绝大部分应届生而言，对各种语言并没有特别的偏好。而且「找到工作」这件事是非常重要的。所以与其盲目的选择语言学习不如来看看各个语言在招聘市场的表现。</p><p>我之前写过一个脚本，可以抓取几个互联网招聘大站的招聘启事，并按职位对薪资进行统计。下边是最近一周的统计结果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nzwnz0j20qo5ubkjn.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>先来说说这些数据怎么看。</p><p>职位热度类似于招聘职位数，和其他语言对比就能看出差距。平均薪资之所有有两个值，是因为我们一般招聘时会给出薪资的上限和下限。严格的讲，这并不是当前某个语言的程序员们的薪资，而是他们下一次跳槽时的可能薪资。另外，部分企业喜欢在上限值上边虚高，所以把上限乘80%可能更合理。而下限一般比较真实，更具备对比价值。</p><p>然后我们来看看能发现什么。</p><h5 id="Java-的数据非常牛"><a href="#Java-的数据非常牛" class="headerlink" title="Java 的数据非常牛"></a>Java 的数据非常牛</h5><p>首先我们会发现，Java 的职位热度非常高，几乎在所有城市里边都是排名第一的。这里有一个特殊原因，就是 Android 职位基本也是使用 Java 语言进行开发的，所以这两个职位有一些重叠。也就是说，学好 Java 其实可以同时应聘 Java工程师 和 Android 工程师（可能需要额外在学一点点应用开发的知识），这非常划算。而从薪资方面看，Java 也是数一数二的。</p><h5 id="前端紧跟其后"><a href="#前端紧跟其后" class="headerlink" title="前端紧跟其后"></a>前端紧跟其后</h5><p>紧随其后的是前端职位。前端是个非常有意思的特点，那就是——几乎所有的公司都会招前端。对比 Java 而言，可能有很多大厂的后端用的不是 Java ，那他们就不需要招聘 Java 工程师。如果你非常想去这家公司，但你会的语言是 Java ，那么就可能和机会擦肩而过。而前端岗位的话，机会就可能大得多。这有点像血型里边的O型血，怎么地方都能用。就算是自以为站在食物链顶端鄙视「古典互联网」的区块链公司也不得不招前端呢，也是一个非常好的选择。</p><p>除了看热度，我们也要考虑到竞争，比如 Java 是一个「传统」岗，很多软件行业的工程师也是会 Java 的。而「前端」是一个新兴的互联网岗，专业前端还不算太多（和 Java 比啦），所以入职难度说不定反而低一些。</p><h5 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h5><p>其他语言在各个城市的数据各不相同，大家可以挑自己感兴趣的看。比如 Go 语言在北京比其他城市热几倍；区块链虽然看起来很火，但其实职位数也就比 PHP 的一半多点；Ruby 虽然薪资不错，但岗位非常少…</p><p>总之语言的选择因人而异因时而异，请综合各种视角去选择一个适合自己的。</p><h3 id="学习路线图"><a href="#学习路线图" class="headerlink" title="学习路线图"></a>学习路线图</h3><p>在选择好职位和语言后，就要寻找对应的学习路线图进行学习了。这里推荐这个 Star 数量超过4万的路线图（的中文版）：<a href="https://github.com/goodjack/developer-roadmap-chinese" target="_blank" rel="external">GitHub - goodjack/developer-roadmap-chinese: 2018 年成為 Web 開發人員的路線圖</a></p><p>虽然不是很全，但细节不错。</p><ul><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nk3d0ej214d2xc4qp.jpg" target="_blank" rel="external">前端路线图</a> </li><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nlxc7hj210u2sc4qp.jpg" target="_blank" rel="external">后端路线图</a></li><li><a href="https://ws1.sinaimg.cn/large/40dfde6fgy1fqh4nj63kgj215i1bpduw.jpg" target="_blank" rel="external">DevOPs路线图</a></li></ul><h2 id="技术栈的优化"><a href="#技术栈的优化" class="headerlink" title="技术栈的优化"></a>技术栈的优化</h2><p>之前我们在分析 Java 数据的时候，发现一个有意思的问题，那就是 Java 的技术栈可以同时覆盖两个热门职位 —— Java 和 Android，这让我们的求职竞争力一下翻了一倍。那么在其他的语言和岗位上还存不存在类似的情况呢？</p><p>其实是有的，比如前端岗位就是一个非常有潜力的例子，它的后端解决方案 NodeJS 正在日益流行 。在我写这篇文章的时候，互联网招聘大站 拉勾网 上北京的 NodeJS 职位数是 181，上海是 114，深圳是 65 。所以学完前端知识再补一下 NodeJS 的收益是不错的。</p><p>但这个技术栈其实还可以进一步优化，因为一个偶然的原因，我统计了一下 PHP 岗位和前端岗位招聘启事里边出现的技术关键词，发现其重合度竟然高于60%。具体的技术关键词和热度见这里 <a href="https://quanzhanke.github.io/ref/MAP.html" target="_blank" rel="external">《PHP&amp;前端岗（1~3年）核心技术点分析报告》</a></p><p>回头一想其实也很好理解，毕竟招 PHP 是来做网站的，HTML CSS JS 总得会一些才行。这意味着PHP的同学只需要补上部分前端知识，比如主流框架 React / Vue / Angular 和 SPA 开发就可以同时应聘 PHP 和 前端 职位。</p><p>这会有多大的竞争力呢？前端招聘启事里边，有超过十分之一的企业提及了PHP。这还没完，React 有一个混合应用解决方案，叫做 React Native，可以直接用 React 栈来开发手机APP。这个技术的需求如何呢？现在拉勾网上北京的 React Native 相关职位数有 84 。</p><p>于是呢，我们可以选择 PHP + React + React Native 的技术栈，仅仅多学习一点知识，可以投递的岗位就从原来的 364 变成了 364 + 373 + 84 。 </p><p>这就是技术栈优化的策略。关于这个技术栈的优化结构，可以看这里 <a href="https://quanzhanke.github.io/0-0.html" target="_blank" rel="external">《方糖全栈学习路线图》</a>，这个栈还顺便把区块链应用开发也覆盖了。大家可以举一反三，去优化自己选中的技术栈。</p><h2 id="简历的写作"><a href="#简历的写作" class="headerlink" title="简历的写作"></a>简历的写作</h2><p>不要最后找工作的时候再来写简历。现在就开始写，即使你什么都不会。这样你才会真切的感受到，自己的缺点和劣势。然后通过不断的学习，往简历上追加新的内容，直到你自己看起来觉得有竞争力了，简历才算阶段性完成了。</p><p>关于简历的写作技巧和工具，我之前写过一篇文章详细说明，可以点这里阅读 <a href="https://juejin.im/book/59e17a7ff265da430629cc4e/section/59faec225188252abc5db42c" target="_blank" rel="external">《如何写出一份专业的技术简历》</a> （这篇文章本身依然是免费的，不用购买小册就能读）</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>( 由于V站上某些同学的疑惑，这里我也补充一下吧。学好基础知识是必须的，这是最基本的，如果这些地方你都丢分了，这些技巧就都白费了 )</p><p>( 刷题库是面试必须的，但只刷题库就舍本逐末了，实践驱动的学习会让你对基础的理解更深入，虽然辛苦点。顺便po一个题库网站 [nowcoder]<a href="https://www.nowcoder.com/" target="_blank" rel="external">https://www.nowcoder.com/</a>  )</p><p>不知不觉已经写了这么多了，其实还有一些内容想说，但暂时就不写到这里了。</p><p>等以后有空我再整理一个小册子吧。我把文章也同时发布到了 GitHub，以后的更新会通过 GitHub 进行，欢迎 watch 和 star 。<a href="https://github.com/easychen/career-guide-for-cs-graduate" target="_blank" rel="external">https://github.com/easychen/career-guide-for-cs-graduate</a></p><p>PS：如果你还不知道怎么用 GitHub，那么赶紧学学吧，这可是程序员的必备（<del>交友</del>）工具哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天早晨看到了Easy大大的这篇文章，在文章中读到了自己的影子，并且也明白了这段时间自己在实习招聘中的不足，受益匪浅。希望我的好友可以看到从中受益&lt;br&gt;特此转载 From：&lt;a href=&quot;https://github.com/easychen/
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Inspire" scheme="https://edward7zhang.github.io/tags/Inspire/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/17/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/17/Android网络编程面试题集/</id>
    <published>2018-04-17T01:07:14.000Z</published>
    <updated>2018-04-17T01:39:28.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP与UDP有什么区别？"><a href="#TCP与UDP有什么区别？" class="headerlink" title="TCP与UDP有什么区别？"></a>TCP与UDP有什么区别？</h3><ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol><h3 id="简单介绍一下TCP三次握手与四次分手过程？"><a href="#简单介绍一下TCP三次握手与四次分手过程？" class="headerlink" title="简单介绍一下TCP三次握手与四次分手过程？"></a>简单介绍一下TCP三次握手与四次分手过程？</h3><p>TCP用<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#建立通路" target="_blank" rel="external">三次握手</a>（three-way handshake）过程创建一个连接，使用四次分手<br>关闭一个连接。</p><p>三次握手与四次分手的流程如下所示：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/practice/network/three_way_handshake.jpeg" width="500"></p><p>三次握手</p><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li></ul><p>四次分手</p><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><p>三次握手与四次分手也是个老生常谈的概念，举个简单的例子说明一下。</p><p>三次握手</p><blockquote><p>例如你小时候出去玩，经常玩忘了回家吃饭。你妈妈也经常过来喊你。如果你没有走远，在门口的小土堆上玩泥巴，你妈妈会喊：”小新，回家吃饭了”。你听到后会回应：”知道了，一会就回去”。妈妈听<br>到你的回应后又说：”快点回来，饭要凉了”。这样你妈妈和你就完成了三次握手的过程。😁说到这里你也可以理解三次握手的必要性，少了其中一个环节，另一方就会陷入等待之中。</p></blockquote><p>三次握手的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误.</p><p>四次分手</p><blockquote><p>例如偶像言情剧干净利落的分手，女主对男主说：我们分手吧🙄，男主说：分就分吧😰。女主说：你果然是不爱我了，你只知道让我多喝热水🙄。男主说：事到如今也没什么好说的了，祝你幸福🙃。四次分手完成。说到这里你可以理解<br>了四次分手的必要性，第一次是女方（客户端）提出分手，第二次是男主（服务端）同意女主分手，第三次是女主确定男主不再爱她，也同意男主分手。第四次两人彻底拜拜（断开连接）。</p></blockquote><p>因为TCP是全双工模式，所以四次分手的目的就是为了可靠地关闭连接。</p><h3 id="TCP如何保证数据传输的可靠性？"><a href="#TCP如何保证数据传输的可靠性？" class="headerlink" title="TCP如何保证数据传输的可靠性？"></a>TCP如何保证数据传输的可靠性？</h3><ol><li>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。</li><li>数据校验。</li><li>数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。</li><li>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。</li><li>拥塞控制：当网络发生拥塞时，减少数据的发送。</li></ol><h3 id="HTTP与HTTPS有什么区别？"><a href="#HTTP与HTTPS有什么区别？" class="headerlink" title="HTTP与HTTPS有什么区别？"></a>HTTP与HTTPS有什么区别？</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">HTTPS</a>是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份<br>认证，保护交换数据的隐私与完整性。</p></blockquote><p>如下图所示，可以很明显的看出两个的区别：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/practice/network/http_https.png" width="500"></p><p>注：TLS是SSL的升级替代版，具体发展历史可以参考<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="external">传输层安全性协议</a>。</p><p>HTTP与HTTPS在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来：</p><ul><li>如果URL的协议是HTTP，则客户端会打开一条到服务端端口80（默认）的连接，并向其发送老的HTTP请求。</li><li>如果URL的协议是HTTPS，则客户端会打开一条到服务端端口443（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的<br>HTTP请求。</li></ul><p>所以你可以看到，HTTPS比HTTP多了一层与SSL的连接，这也就是客户端与服务端SSL握手的过程，整个过程主要完成以下工作：</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证</li><li>生成临时的会话密钥，以便加密信道。</li></ul><p>SSL握手是一个相对比较复杂的过程，更多关于SSL握手的过程细节可以参考<a href="https://www.wosign.com/faq/faq2016-0309-04.htm" target="_blank" rel="external">TLS/SSL握手过程</a></p><p>SSL/TSL的常见开源实现是OpenSSL，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。<br>更多源于OpenSSL的技术细节可以参考<a href="https://www.openssl.org/" target="_blank" rel="external">OpenSSL</a>。</p><h3 id="谈一谈对HTTP缓存的理解？"><a href="#谈一谈对HTTP缓存的理解？" class="headerlink" title="谈一谈对HTTP缓存的理解？"></a>谈一谈对HTTP缓存的理解？</h3><p>HTTP的缓存机制也是依赖于请求和响应header里的参数类实现的，最终响应式从缓存中去，还是从服务端重新拉取，HTTP的缓存机制的流程如下所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/android-open-framwork-analysis/raw/master/art/okhttp/http_cache_structure.png" width="600"></p><p>HTTP的缓存可以分为两种：</p><ul><li>强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。</li><li>对比缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存<br>标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。</li></ul><p>强制缓存优先于对比缓存。</p><p>上面提到强制缓存使用的的两个标识：</p><ul><li>Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。</li><li>Cache-Control：Expires有个时间校验的问题，所有HTTP1.1采用Cache-Control替代Expires。</li></ul><p>Cache-Control的取值有以下几种：</p><ul><li>private:             客户端可以缓存。</li><li>public:              客户端和代理服务器都可缓存。</li><li>max-age=xxx:   缓存的内容将在 xxx 秒后失效</li><li>no-cache:          需要使用对比缓存来验证缓存数据。</li><li>no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发。</li></ul><p>我们再来看看对比缓存的两个标识：</p><p><strong>Last-Modified/If-Modified-Since</strong></p><p>Last-Modified 表示资源上次修改的时间。</p><p>当客户端发送第一次请求时，服务端返回资源上次修改的时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Last-Modified: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div></pre></td></tr></table></figure><p>客户端再次发送，会在header里携带If-Modified-Since。将上次服务端返回的资源时间上传给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-Modified-Since: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div></pre></td></tr></table></figure><p>服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改，<br>则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存。</p><p>上面是一种时间戳标记资源是否修改的方法，还有一种资源标识码ETag的方式来标记是否修改，如果标识码发生改变，则说明资源已经被修改，ETag优先级高于Last-Modified。</p><p><strong>Etag/If-None-Match</strong></p><p>ETag是资源文件的一种标识码，当客户端发送第一次请求时，服务端会返回当前资源的标识码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ETag: <span class="string">"5694c7ef-24dc"</span></div></pre></td></tr></table></figure><p>客户端再次发送，会在header里携带上次服务端返回的资源标识码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-None-Match:<span class="string">"5694c7ef-24dc"</span></div></pre></td></tr></table></figure><p>服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较，如果不同，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回<br>304，客户端可以继续使用缓存。</p><h3 id="HTTPS是如何保证安全的，证书如何校验？"><a href="#HTTPS是如何保证安全的，证书如何校验？" class="headerlink" title="HTTPS是如何保证安全的，证书如何校验？"></a>HTTPS是如何保证安全的，证书如何校验？</h3><h3 id="HTTP如何实现长连接？"><a href="#HTTP如何实现长连接？" class="headerlink" title="HTTP如何实现长连接？"></a>HTTP如何实现长连接？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议复习</title>
    <link href="https://edward7zhang.github.io/2018/04/16/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://edward7zhang.github.io/2018/04/16/HTTP协议/</id>
    <published>2018-04-16T02:43:13.000Z</published>
    <updated>2018-04-16T13:58:56.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>奇迹般的腾讯笔试通过了，昨天下午经过了一面…发现之前着眼于Android与Java的知识而没有对计算机网络系统的复习…导致了这次面试的滑铁卢…所以想进这样的一线大厂做一名合格的程序员还是要全面发展…不能顾此失彼</p></blockquote><h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h1><hr><ul><li>默认端口：80</li></ul><h2 id="Http协议的主要特点"><a href="#Http协议的主要特点" class="headerlink" title="Http协议的主要特点"></a>Http协议的主要特点</h2><hr><ol><li>支持客户／服务器模式</li><li>简单快速：客户向服务端请求服务时，只需传送请求方式和路径。</li><li>灵活：允许传输任意类型的数据对象。由Content-Type加以标记。</li><li>无连接：每次响应一个请求，响应完成以后就断开连接。</li><li>无状态：服务器不保存浏览器的任何信息。每次提交的请求之间没有关联。</li></ol><h3 id="非持续性和持续性"><a href="#非持续性和持续性" class="headerlink" title="非持续性和持续性"></a>非持续性和持续性</h3><hr><ul><li>HTTP1.0默认非持续性；HTTP1.1默认持续性</li></ul><h4 id="持续性"><a href="#持续性" class="headerlink" title="持续性"></a>持续性</h4><p>浏览器和服务器建立TCP连接后，可以请求多个对象</p><h4 id="非持续性"><a href="#非持续性" class="headerlink" title="非持续性"></a>非持续性</h4><p>浏览器和服务器建立TCP连接后，只能请求一个对象</p><h3 id="非流水线和流水线"><a href="#非流水线和流水线" class="headerlink" title="非流水线和流水线"></a>非流水线和流水线</h3><hr><p>类似于组成里面的流水操作</p><ul><li>流水线：不必等到收到服务器的回应就发送下一个报文。</li><li>非流水线：发出一个报文，等到响应，再发下一个报文。类似TCP。</li></ul><h4 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h4><table><thead><tr><th>Post一般用于更新或者添加资源信息</th><th style="text-align:center">Get一般用于查询操作，而且应该是安全和幂等的</th></tr></thead><tbody><tr><td>Post更加安全</td><td style="text-align:center">Get会把请求的信息放到URL的后面</td></tr><tr><td>Post传输量一般无大小限制</td><td style="text-align:center">Get不能大于2KB</td></tr><tr><td>Post执行效率低</td><td style="text-align:center">Get执行效率略高</td></tr></tbody></table><h4 id="为什么POST效率低，Get效率高"><a href="#为什么POST效率低，Get效率高" class="headerlink" title="为什么POST效率低，Get效率高"></a>为什么POST效率低，Get效率高</h4><hr><ul><li>Get将参数拼成URL,放到header消息头里传递</li><li>Post直接以键值对的形式放到消息体中传递。</li><li>但两者的效率差距很小很小</li></ul><h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><hr><ul><li>端口号是443</li><li>是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议。</li></ul><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><hr><h3 id="使用TCP"><a href="#使用TCP" class="headerlink" title="使用TCP"></a>使用TCP</h3><hr><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Socket socket = new Socket(&quot;ip&quot;, 端口);</div><div class="line"></div><div class="line">InputStream is = socket.getInputStream();</div><div class="line">DataInputStream dis = new DataInputStream(is);</div><div class="line"></div><div class="line">OutputStream os = socket.getOutputStream();</div><div class="line">DataInputStream dos = new DataOutputStream(os);</div></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServerSocket serverSocket = new ServerSocket(端口);</div><div class="line">Socket socket = serverSocket.accept();</div><div class="line">//获取流的方式与客户端一样</div></pre></td></tr></table></figure><p>读取输入流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">byte[] buffer = new byte[1024]; </div><div class="line">do&#123; </div><div class="line">int count = is.read(buffer); </div><div class="line">if(count &lt;= 0)&#123; break; &#125;</div><div class="line">else&#123; </div><div class="line">// 对buffer保存或者做些其他操作 </div><div class="line">&#125; </div><div class="line">&#125;</div><div class="line">while(true);</div></pre></td></tr></table></figure><h2 id="使用UDP"><a href="#使用UDP" class="headerlink" title="使用UDP"></a>使用UDP</h2><p>客户端和服务器端一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket = new DatagramSocket(端口);</div><div class="line">InetAddress serverAddress = InetAddress.getbyName(&quot;ip&quot;);</div><div class="line">//发送</div><div class="line">DatagramPackage packet = new DatagramPacket(buffer, length, host, port);</div><div class="line">socket.send(packet);</div><div class="line">//接收</div><div class="line">byte[] buf = new byte[1024];</div><div class="line">DatagramPacket packet = new DatagramPacket(buf, 1024);</div><div class="line">Socket.receive(packet);</div></pre></td></tr></table></figure><h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><hr><p><strong>面向报文的传输方式</strong>是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。<br><strong>面向字节流</strong>的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><hr><hr><ul><li>Transmission Control Protocol，传输控制协议</li><li>面向连接的协议</li><li>需要三次握手建立连接</li><li>需要四次挥手断开连接</li><li>TCP报头最小长度：20字节<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_131271823564Rx.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h3 id="三次握手的过程："><a href="#三次握手的过程：" class="headerlink" title="三次握手的过程："></a>三次握手的过程：</h3><hr><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20170104214009596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2h1c2xlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>客户端发送：SYN = 1, SEQ = X, 端口号</li><li>服务器回复：SYN = 1, ack = X + 1, SEQ = Y，ACK = 1</li><li>客户端发送：ack = Y + 1, SEQ = X + 1,ACK = 1</li></ol><ul><li>SYN – 建立连接位</li><li>ACK – 响应位</li><li>SEQ – 顺序号码</li><li><p>ack – 确认号</p><blockquote><p>确认应答信号ACK = 收到的SEQ + 1。<br>连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。</p></blockquote></li><li><p>第一次握手：主机A发送位码为SYN = 1，随机产生SEQ = 1234567的数据包到服务器，主机B由SYN = 1知道，A要建立联机</p></li><li>第二次握手：主机B收到请求后要确认联机信息，向A发送ACK = （主机A的SEQ+1），SYN = 1，ack = 1，随机产生SEQ = 3452671的包；</li><li>第三次握手：主机A收到后检查ack是否正确，即第一次发送的（SEQ+1），以及位码ACK是否为1，若正确，主机A会再发送ack = （主机B的SEQ+1），ACK = 1，主机B收到后确认SEQ值与ACK = 1则连接建立成功。</li></ul><h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><hr><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>A向B提出停止连接请求，FIN = 1</li><li>B收到，ACK = 1</li><li>B向A提出停止连接请求，FIN = 1</li><li>A收到，ACK = 1</li></ol><ul><li>FIN – 关闭连接</li><li>SYN – 建立连接位</li><li>ACK – 响应位</li><li>SEQ – 顺序号码</li><li>ack – 确认号<br><strong>优点：</strong> </li></ul><hr><ul><li>可靠，稳定<pre><code>1、传递数据前，会有三次握手建立连接2、传递数据时，有确认、窗口、重传、拥塞控制3、传递数据后，会断开连接节省系统资源</code></pre></li></ul><p><strong>缺点：</strong></p><hr><ul><li><p>传输慢，效率低，占用系统资源高<br>1、传递数据前，建立连接需要耗时<br>2、传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源</p></li><li><p>易被攻击<br>1、因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击</p></li></ul><p><strong>如何保证接收的顺序性：</strong></p><hr><p>TCP协议使用SEQ和ACK机制保证了顺序性<br>TCP的每个报文都是有序号的。确认应答信号ACK=收到的SEQ+1</p><p><strong>【注意】中断连接端可以是Client端，也可以是Server端。</strong></p><p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p>整个过程Client端所经历的状态如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_1312719804oSkK.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p>而Server端所经历的过程如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201108/7/0_1312719833030b.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p><strong>【注意】</strong> 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><hr><hr><ul><li>User Data Protocol，用户数据包协议</li><li>面向无连接的协议</li><li>UDP报头只有8字节</li></ul><p><strong>简介：</strong></p><hr><ul><li>传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上</li><li>在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制</li><li>在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段</li><li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息</li><li>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小</li><li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制</li><li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。</li><li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</li></ul><blockquote><p>使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p></blockquote><p><strong>优点：</strong></p><hr><ul><li><p>传输速率快<br>1、传输数据前，不需要像TCP一样建立连接<br>2、传输数据时，没有确认、窗口、重传、拥塞控制等机制</p></li><li><p>较安全<br>1、由于没有了TCP的一些机制，被攻击者利用的漏洞就少了</p></li></ul><p><strong>缺点：</strong></p><hr><ul><li>不可靠，不稳定<br>1、由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包</li></ul><p><strong>用UDP协议通讯时怎样得知目标机是否获得了数据包</strong></p><hr><p>仿造TCP的做法，每发一个UDP包，都在里面加一个SEQ序号，接收方收到包后，将SEQ序号回复给发送方。如果发送方在指定时间以内没有收到回应，说明丢包了。</p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><hr><table class="table table-bordered table-striped table-condensed"><br>    <tr><br>        <td>TCP面向<strong>有链接</strong>的通信服务</td><br>        <td>UDP面向<strong>无连接</strong>的通信服务</td><br>    </tr><br>    <tr><br>        <td>TCP提供可靠的通信传输</td><br>        <td>UDP不可靠,会丢包</td><br>    </tr><br>    <tr><br>        <td>TCP保证数据顺序</td><br>        <td>UDP不保证</td><br>    </tr><br>    <tr><br>        <td>TCP数据无边界</td><br>        <td>UDP有边界</td><br>    </tr><br>    <tr><br>        <td>TCP速度快</td><br>        <td>UDP速度慢</td><br>    </tr><br>    <tr><br>        <td>TCP面向字节流</td><br>        <td>UDP面向报文</td><br>    </tr><br>    <tr><br>        <td>TCP一对一</td><br>        <td>UDP可以一对一，一对多</td><br>    </tr><br>    <tr><br>        <td>TCP报头至少20字节</td><br>        <td>UDP报头8字节</td><br>    </tr><br>    <tr><br>        <td>TCP有流量控制，拥塞控制</td><br>        <td>UDP没有</td><br>    </tr><br></table><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>为什么UDP比TCP快</strong></p><hr><ol><li>TCP需要三次握手</li><li>TCP有拥塞控制，控制流量等机制</li></ol><p><strong>为什么TCP比UDP可靠</strong></p><hr><ol><li>TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。</li><li>TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有。因此可能丢包。</li></ol><p><strong>什么时候使用TCP</strong></p><hr><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>在日常生活中，常见使用TCP协议的应用如下：<br>浏览器，用的HTTP<br>FlashFXP，用的FTP<br>Outlook，用的POP、SMTP<br>Putty，用的Telnet、SSH<br>QQ文件传输</p><p><strong>什么时候应该使用UDP：</strong></p><hr><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。<br>比如，日常生活中，常见使用UDP协议的应用如下：<br>QQ语音<br>QQ视频<br>TFTP</p><p><strong>TCP无边界，UDP有边界</strong></p><hr><p><strong>TCP无边界</strong></p><p>客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的；</p><p><strong>UDP有边界</strong></p><p>客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。</p><p><strong>为什么连接的时候是三次握手，关闭的时候是四次握手？</strong></p><hr><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手</p><p><strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p><hr><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态是用来重发可能丢失的ACK报文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;奇迹般的腾讯笔试通过了，昨天下午经过了一面…发现之前着眼于Android与Java的知识而没有对计算机网络系统的复习…导致了这次面试的滑铁卢…所以想进这样的一线大厂做一名合格的程序员还是要全面发展…不能顾此失彼&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="Network" scheme="https://edward7zhang.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Android开源库面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/15/Android%E5%BC%80%E6%BA%90%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/15/Android开源库面试题集/</id>
    <published>2018-04-15T01:07:14.000Z</published>
    <updated>2018-04-17T01:45:26.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><h3 id="谈谈对Okhttp的理解？"><a href="#谈谈对Okhttp的理解？" class="headerlink" title="谈谈对Okhttp的理解？"></a>谈谈对Okhttp的理解？</h3><p>Volley与OkHttp的对比：</p><ul><li>Volley：支持HTTPS。缓存、异步请求，不支持同步请求。协议类型是Http/1.0, Http/1.1，网络传输使用的是    HttpUrlConnection/HttpClient，数据读写使用的IO。</li><li>OkHttp：支持HTTPS。缓存、异步请求、同步请求。协议类型是Http/1.0, Http/1.1, SPDY, Http/2.0, WebSocket，网络传输使用的是封装的Socket，数据读写使用的NIO（Okio）。</li></ul><blockquote><p>SPDY协议类似于HTTP，但旨在缩短网页的加载时间和提高安全性。SPDY协议通过压缩、多路复用和优先级来缩短加载时间。</p></blockquote><p>Okhttp的子系统层级结构图如下所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/android-open-framwork-analysis/raw/master/art/okhttp/okhttp_structure.png" width="600"></p><ul><li>网络配置层：利用Builder模式配置各种参数，例如：超时时间、拦截器等，这些参数都会由Okhttp分发给各个需要的子系统。</li><li>重定向层：负责重定向。</li><li>Header拼接层：负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应。</li><li>HTTP缓存层：负责读取缓存以及更新缓存。</li><li>连接层：连接层是一个比较复杂的层级，它实现了网络协议、内部的拦截器、安全性认证，连接与连接池等功能，但这一层还没有发起真正的连接，它只是做了连接器一些参数的处理。</li><li>数据响应层：负责从服务器读取响应的数据。</li></ul><p>在整个Okhttp的系统中，我们还要理解以下几个关键角色：</p><ul><li>OkHttpClient：通信的客户端，用来统一管理发起请求与解析响应。</li><li>Call：Call是一个接口，它是HTTP请求的抽象描述，具体实现类是RealCall，它由CallFactory创建。</li><li>Request：请求，封装请求的具体信息，例如：url、header等。</li><li>RequestBody：请求体，用来提交流、表单等请求信息。</li><li>Response：HTTP请求的响应，获取响应信息，例如：响应header等。</li><li>ResponseBody：HTTP请求的响应体，被读取一次以后就会关闭，所以我们重复调用responseBody.string()获取请求结果是会报错的。</li><li>Interceptor：Interceptor是请求拦截器，负责拦截并处理请求，它将网络请求、缓存、透明压缩等功能都统一起来，每个功能都是一个Interceptor，所有的Interceptor最<br>终连接成一个Interceptor.Chain。典型的责任链模式实现。</li><li>StreamAllocation：用来控制Connections与Streas的资源分配与释放。</li><li>RouteSelector：选择路线与自动重连。</li><li>RouteDatabase：记录连接失败的Route黑名单。</li></ul><h3 id="谈谈对Fresco理解？"><a href="#谈谈对Fresco理解？" class="headerlink" title="谈谈对Fresco理解？"></a>谈谈对Fresco理解？</h3><p>Fresco与Glide的对比：</p><ul><li>Glide：相对轻量级，用法简单优雅，支持Gif动态图，适合用在那些对图片依赖不大的App中。</li><li>Fresco：采用匿名共享内存来保存图片，也就是Native堆，有效的的避免了OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大的App中。</li></ul><p>Fresco的整体架构如下图所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/android-open-framwork-analysis/raw/master/art/fresco/fresco_structure.png" width="600"></p><ul><li>DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由负责。</li><li>DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。</li><li>DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。</li><li>DraweeHolder：统筹管理Hierarchy与DraweeHolder。</li><li>ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。</li><li>Producer/Consumer：Producer也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。</li><li>IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。</li></ul><p>纵观整个Fresco的架构，DraweeView是门面，和用户进行交互，DraweeHierarchy是视图层级，管理图层，DraweeController是控制器，管理数据。它们构成了整个Fresco框架的三驾马车。当然还有我们<br>幕后英雄Producer，所有的脏活累活都是它干的，最佳劳模👍</p><p>理解了Fresco整体的架构，我们还有了解在这套矿建里发挥重要作用的几个关键角色，如下所示：</p><ul><li>Supplier：提供一种特定类型的对象，Fresco里有很多以Supplier结尾的类都实现了这个接口。</li><li>SimpleDraweeView：这个我们就很熟悉了，它接收一个URL，然后调用Controller去加载图片。该类继承于GenericDraweeView，GenericDraweeView又继承于DraweeView，DraweeView是Fresco的顶层View类。</li><li>PipelineDraweeController：负责图片数据的获取与加载，它继承于AbstractDraweeController，由PipelineDraweeControllerBuilder构建而来。AbstractDraweeController实现了DraweeController接口，DraweeController<br>是Fresco的数据大管家，所以的图片数据的处理都是由它来完成的。</li><li>GenericDraweeHierarchy：负责SimpleDraweeView上的图层管理，由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角），该类由GenericDraweeHierarchyBuilder进行构建，该构建器<br>将placeholderImage、retryImage、failureImage、progressBarImage、background、overlays与pressedStateOverlay等<br>xml文件或者Java代码里设置的属性信息都传入GenericDraweeHierarchy中，由GenericDraweeHierarchy进行处理。</li><li>DraweeHolder：该类是一个Holder类，和SimpleDraweeView关联在一起，DraweeView是通过DraweeHolder来统一管理的。而DraweeHolder又是用来统一管理相关的Hierarchy与Controller</li><li>DataSource：类似于Java里的Futures，代表数据的来源，和Futures不同，它可以有多个result。</li><li>DataSubscriber：接收DataSource返回的结果。</li><li>ImagePipeline：用来调取获取图片的接口。</li><li>Producer：加载与处理图片，它有多种实现，例如：NetworkFetcherProducer，LocalAssetFetcherProducer，LocalFileFetchProducer。从这些类的名字我们就可以知道它们是干什么的。<br>Producer由ProducerFactory这个工厂类构建的，而且所有的Producer都是像Java的IO流那样，可以一层嵌套一层，最终只得到一个结果，这是一个很精巧的设计👍</li><li>Consumer：用来接收Producer产生的结果，它与Producer组成了生产者与消费者模式。</li></ul><p>注：Fresco源码里的类的名字都比较长，但是都是按照一定的命令规律来的，例如：以Supplier结尾的类都实现了Supplier接口，它可以提供某一个类型的对象（factory, generator, builder, closure等）。<br>以Builder结尾的当然就是以构造者模式创建对象的类。</p><h3 id="EventBus是如何做到发送粘性消息的？"><a href="#EventBus是如何做到发送粘性消息的？" class="headerlink" title="EventBus是如何做到发送粘性消息的？"></a>EventBus是如何做到发送粘性消息的？</h3><p>EventBus里有一个HashMap用来存储粘性事件队列，当注册事件时，如果该事件是粘性事件，则从该队列中取出最后一个该类型的事件并发送给订阅者。</p><h3 id="天猫七巧板布局、vLayout的实现原理？"><a href="#天猫七巧板布局、vLayout的实现原理？" class="headerlink" title="天猫七巧板布局、vLayout的实现原理？"></a>天猫七巧板布局、vLayout的实现原理？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Android" scheme="https://edward7zhang.github.io/tags/Android/"/>
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法面试题集</title>
    <link href="https://edward7zhang.github.io/2018/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://edward7zhang.github.io/2018/04/13/数据结构与算法面试题集/</id>
    <published>2018-04-13T01:07:14.000Z</published>
    <updated>2018-04-17T01:43:55.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a></p></blockquote><p>数据结构与算法通常也与Java的集合牵扯在一起考察，这里我们将两者放在一起来讲。</p><p>什么是算法？</p><blockquote><p>算法是指令的集合，是为了解决特定问题而规定的一些列操作。</p></blockquote><p>时间复杂度</p><blockquote><p>算法的执行时间随着问题规模的增长而变化的规律。</p></blockquote><p>算法的执行时间受到以下四个因素的影响：</p><ul><li>硬件层面：计算机执行每条指令的速度</li><li>软件层面：编译产生的代码质量</li><li>算法策略：算法的好坏</li><li>问题规模</li></ul><p>空间复杂度</p><blockquote><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。</p></blockquote><p>例如：插入排序的算法复杂度是O(1)。而一般递归算法的时间复杂度就是O(n)，因为每次递归都要存储结果。</p><p>常熟阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)，平方阶O(n^2)、立方阶O(n^3)、k次方阶O(n^k)、指数阶O(2^n);</p><h3 id="描述一下Java的集合体系，List、Set与Map有什么区别？"><a href="#描述一下Java的集合体系，List、Set与Map有什么区别？" class="headerlink" title="描述一下Java的集合体系，List、Set与Map有什么区别？"></a>描述一下Java的集合体系，List、Set与Map有什么区别？</h3><p>Java集合里使用接口来定义功能，是一套完善的继承体系。Iterator是所有集合的总接口，其他所有接口都继承于它，该接口定义了集合的<br>遍历操作，Collection接口继承于Iterator，是集合的次级接口（Map独立存在，除外），定义了集合的一些通用操作。</p><p>Java集合的类结构图如下所示：</p><p>👉 点击图片查看大图</p><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/java_collection_structure.png"></p><ul><li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li><li>Set：无序，不可重复；</li><li>Map：键值对，键唯一，值多个；</li></ul><h3 id="并发集合了解哪些？"><a href="#并发集合了解哪些？" class="headerlink" title="并发集合了解哪些？"></a>并发集合了解哪些？</h3><blockquote><p>ConcurrentHashMap：线程不安全的HashMap、效率低下的HashTable、线程安全且高效的ConcurrentHashMap。</p></blockquote><p>ConcurrentHashMap存储元素的结构如下所示：</p><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashMap_structure.png" width="500"></p><p>ConcurrentHashMap与HashMap一样适用数组加链表存储元素，适用链表定址法来解决哈希冲突，不同之处在于当链表长度大于8的时候会将链表转换为一棵红黑树，查找时间复杂度由O(N)变成O(lgN)。</p><p>ConcurrentHashMap并发控制的关键在于一个变量，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div></pre></td></tr></table></figure><p>sizeCtl被volatile关键字修饰是一个多线程共享的变量，当它的值为负数的时候说明某个线程正在操作这个Map，想要去操作这个Map的线程就要一直去竞争这个sizeCtl，没有得到这个变量的值就要一直自旋等待这个变量，当占用<br>这个变量的线程操作完成后，要将这个变量的值设置回来，以便让其他线程走出自旋，竞争到该变量。</p><p>这种同步进制事实上是一种CAS的做法。</p><blockquote><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p></blockquote><h3 id="Vector，ArrayList与LinkedList有什么区别，应用场景是什么？"><a href="#Vector，ArrayList与LinkedList有什么区别，应用场景是什么？" class="headerlink" title="Vector，ArrayList与LinkedList有什么区别，应用场景是什么？"></a>Vector，ArrayList与LinkedList有什么区别，应用场景是什么？</h3><ul><li>Vector实现了基于动态Object数组的数据结构，线程安全，可以设置增长因子，效率比较低，不建议使用。</li><li>ArrayList实现了基于动态Object数组的数据结构，非线程安全，地址连续，查询效率比较高，插入和删除效率比较低。适合查询操作频繁的场景。</li><li>LinkedList实现了基于链表的数据结构，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。</li></ul><h3 id="HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？"><a href="#HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？" class="headerlink" title="HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？"></a>HashMap、LinkedHashMap、ConcurrentHashMap、TreeMap与ArrayMap有什么区别，应用场景是什么？</h3><ul><li>HashMap：基于HashMap.Node数组加单向链表实现，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。</li><li>LinkedHashMap：基于</li><li>ConcurrentHashMap：基于hash表实现，线程安全且高效，分段锁的实现相对于HashTable的实现提高了很大的效率。</li><li>TreeMap：基于红黑树实现，非线程安全，可以按照自然顺序或者自定义顺序自动排序，不允许插入null值，查找效率比较高，适合需要排序的场景。</li></ul><p>ConcurrentHashMap存储元素的结构如下所示：</p><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashMap_structure.png" width="500"></p><p>ConcurrentHashMap与HashMap一样适用数组加链表存储元素，适用链表定址法来解决哈希冲突，不同之处在于当链表长度大于8的时候会将链表转换为一棵红黑树，查找时间复杂度由O(N)变成O(lgN)。</p><p>ConcurrentHashMap并发控制的关键在于一个变量，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div></pre></td></tr></table></figure><p>sizeCtl被volatile关键字修饰是一个多线程共享的变量，当它的值为负数的时候说明某个线程正在操作这个Map，想要去操作这个Map的线程就要一直去竞争这个sizeCtl，没有得到这个变量的值就要一直自旋等待这个变量，当占用<br>这个变量的线程操作完成后，要将这个变量的值设置回来，以便让其他线程走出自旋，竞争到该变量。</p><p>这种同步进制事实上是一种CAS的做法。</p><blockquote><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较</p></blockquote><h3 id="HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？"><a href="#HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？" class="headerlink" title="HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？"></a>HashSet、LinkedHashSet与TreeSet有什么区别，应用场景是什么？</h3><ul><li>HashSet：基于HashMap实现，非线程安全，地址不连续，查询效率比较低，插入和删除效率比较高。适合插入和删除操作频繁的场景。</li><li>LinkedHashSet：</li></ul><ul><li>TreeSet基于红黑树实现，非线程安全，可以按照自然顺序或者自定义顺序自动排序，不允许插入null值。适合需要排序的场景。</li><li>HashSet基于hash表实现，非线程安全，允许插入null，查找效率高。适合查找操作频繁的场景。</li></ul><h3 id="HashMap是如何解决hash碰撞的？"><a href="#HashMap是如何解决hash碰撞的？" class="headerlink" title="HashMap是如何解决hash碰撞的？"></a>HashMap是如何解决hash碰撞的？</h3><ul><li>开发定址法</li><li>链表法</li></ul><blockquote><p>HashMap基于数组实现，数组里的元素是一个单向链表。</p></blockquote><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashMap_class.png" width="500"></p><p>HashMap具有以下特点：</p><ul><li>基于数组实现，数组里的元素是一个单向链表。</li><li>键不可以重复，值可以重复，键、值都可以为null</li><li>非线程安全</li></ul><p>HashMap实现了以下接口：</p><ul><li>Map：以键值对的形式存取元素</li><li>Cloneable：可以被克隆</li><li>Serializable：可以序列化</li></ul><p>查找流程</p><ol><li>计算哈希值，根据哈希值与数组容量计算它所在的索引，根据索引查找它所在的链表。</li><li>在单向链表中查找该元素</li></ol><p>删除流程</p><ol><li>计算哈希值，根据哈希值与数组容量计算它所在的索引，根据索引查找它所在的链表。</li><li>从起始节点开始遍历，查找要删除的元素，删除该节点，将节点的后继添加为它前驱的后继</li></ol><p>插入流程</p><ol><li>根据key计算hash值，并根据hash值和数组容量，找到索引值，该位置即为存储该元素的链表所在处。</li><li>遍历table[i]位置的链表，查找相同的key，若找到则则用新的value替换掉oldValue.</li><li>若没有查找到相同的key，则添加key到table[i]位置，新添加的元素总是添加在单向链表的表头位置，后面的元素称为它的后继。</li></ol><blockquote><p>HashSet基于HashMap实现，也就是说它本质上也是一个数组，它以HashMap的key来存储元素，因为HashMap里的key是不会重复的，所以HashSet的元素时不重复且无序的。</p></blockquote><p><img src="https://github.com/guoxiaoxing/data-structure-and-algorithm/raw/master/art/hash/HashSet_class.png" width="500"></p><h3 id="SpareArray做了哪些优化？"><a href="#SpareArray做了哪些优化？" class="headerlink" title="SpareArray做了哪些优化？"></a>SpareArray做了哪些优化？</h3><p>优点</p><ul><li>key保存在int mKeys[]数组中，相对于HashMap不再对key进行自动装箱，避免资源消耗。但是vaule是保存在Object[] mValues数组中还是需要自动装箱的。</li><li>相对于HashMap，不再使用额外的Entry对象来存储数据，减少了内存开销。</li><li>数据量小的情况下，随机访问效率更高。</li></ul><p>缺点</p><ul><li>插入操作需要复制数组，增删效率低。</li><li>数据量巨大时，复制数组成本巨大，gc()成本也巨大。</li><li>数据量巨大时，查询效率也会明显下降。</li></ul><h3 id="简单说一说SpareArray的插入流程？"><a href="#简单说一说SpareArray的插入流程？" class="headerlink" title="简单说一说SpareArray的插入流程？"></a>简单说一说SpareArray的插入流程？</h3><p>SpareArray的key是一个int有序数组，查找过程使用的二分查找。</p><ol><li>用二分查找法查找元素的key。</li><li>如果插入的数据冲突了，则直接覆盖原则。</li><li>如果当前插入的key上的数据为DELETE，则直接覆盖。</li><li>如果前面几步都失败了，则检查是否需要gc()并且在索引上插入数据。</li></ol><h3 id="N个无序树中查找最大的10个数？"><a href="#N个无序树中查找最大的10个数？" class="headerlink" title="N个无序树中查找最大的10个数？"></a>N个无序树中查找最大的10个数？</h3><h3 id="手写代码遍历文件目录？"><a href="#手写代码遍历文件目录？" class="headerlink" title="手写代码遍历文件目录？"></a>手写代码遍历文件目录？</h3><h3 id="电梯运行的算法分析？"><a href="#电梯运行的算法分析？" class="headerlink" title="电梯运行的算法分析？"></a>电梯运行的算法分析？</h3><h3 id="手写一下单链表的查询操作？"><a href="#手写一下单链表的查询操作？" class="headerlink" title="手写一下单链表的查询操作？"></a>手写一下单链表的查询操作？</h3><h3 id="手写二分查找？"><a href="#手写二分查找？" class="headerlink" title="手写二分查找？"></a>手写二分查找？</h3><h3 id="手写一个字符串翻转？"><a href="#手写一个字符串翻转？" class="headerlink" title="手写一个字符串翻转？"></a>手写一个字符串翻转？</h3><h3 id="从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？"><a href="#从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？" class="headerlink" title="从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？"></a>从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">string:  Hello</div><div class="line">  length:  5</div><div class="line">  </div><div class="line">          0 1 2 3 4 </div><div class="line">  before: H e l l o</div><div class="line">  after:  o l l e H</div><div class="line">  </div><div class="line">  index             sum</div><div class="line">  0: H---&gt;o  0--&gt;4  4</div><div class="line">  1: e---&gt;l  1--&gt;3  4</div><div class="line">  2: l---&gt;l  2--&gt;2  4</div></pre></td></tr></table></figure><p>解法一：使用数组</p><ol><li>将字符串转换为char数组</li><li>遍历循环给char数组赋值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray2</span><span class="params">(String string)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</div><div class="line">    <span class="keyword">int</span> length = string.length();</div><div class="line">    <span class="keyword">char</span> [] array = string.toCharArray();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</div><div class="line">        array[i] = string.charAt(length-<span class="number">1</span>-i);</div><div class="line">        array[length-<span class="number">1</span>-i] = string.charAt(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解法二：使用栈</p><ol><li>将字符串转换为char数组</li><li>将char数组中的字符依次压入栈中</li><li>将栈中的字符依次弹出赋值给char数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithStack</span><span class="params">(String string)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</div><div class="line">    Stack&lt;Character&gt; stringStack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">char</span> [] array = string.toCharArray();</div><div class="line">    <span class="keyword">for</span>(Character c:array)&#123;</div><div class="line">        stringStack.push(c);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> length = string.length();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">        array[i] = stringStack.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解法三：逆序遍历</p><ol><li>逆序遍历字符串中的字符，并将它依次添加到StringBuilder中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithReverseLoop</span><span class="params">(String string)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = string.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">            sb.append(string.charAt(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="单链表反转，合并多个单链表"><a href="#单链表反转，合并多个单链表" class="headerlink" title="单链表反转，合并多个单链表"></a>单链表反转，合并多个单链表</h3><p>单链表的结构就像一个火车的结构，火车头拉着许多车厢，实现链表翻转，可以利用递归翻转法，在反转当前节点之前先反转后续节点。这样从头结点开始，层层深入直到尾结点才开始反转指针域的指向。简单的<br>说就是从尾结点开始，逆向反转各个结点的指针域指向，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListReverse</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);  </div><div class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);  </div><div class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);  </div><div class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);  </div><div class="line">        head.setNext(node1);  </div><div class="line">        node1.setNext(node2);  </div><div class="line">        node2.setNext(node3);  </div><div class="line">  </div><div class="line">        <span class="comment">// 打印反转前的链表  </span></div><div class="line">        Node h = head;  </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != h) &#123;  </div><div class="line">            System.out.print(h.getData() + <span class="string">" "</span>);  </div><div class="line">            h = h.getNext();  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 调用反转方法  </span></div><div class="line">        head = Reverse1(head);  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"\n**************************"</span>);  </div><div class="line">        <span class="comment">// 打印反转后的结果  </span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head) &#123;  </div><div class="line">            System.out.print(head.getData() + <span class="string">" "</span>);  </div><div class="line">            head = head.getNext();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 递归，在反转当前节点之前先反转后续节点 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">Reverse1</span><span class="params">(Node head)</span> </span>&#123;  </div><div class="line">        <span class="comment">// head看作是前一结点，head.getNext()是当前结点，reHead是反转后新链表的头结点  </span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> head;<span class="comment">// 若为空链或者当前结点在尾结点，则直接还回  </span></div><div class="line">        &#125;  </div><div class="line">        Node reHead = Reverse1(head.getNext());<span class="comment">// 先反转后续节点head.getNext()  </span></div><div class="line">        head.getNext().setNext(head);<span class="comment">// 将当前结点的指针域指向前一结点  </span></div><div class="line">        head.setNext(<span class="keyword">null</span>);<span class="comment">// 前一结点的指针域令为null;  </span></div><div class="line">        <span class="keyword">return</span> reHead;<span class="comment">// 反转后新链表的头结点  </span></div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> Data;<span class="comment">// 数据域  </span></div><div class="line">        <span class="keyword">private</span> Node Next;<span class="comment">// 指针域  </span></div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> Data)</span> </span>&#123;  </div><div class="line">            <span class="comment">// super();  </span></div><div class="line">            <span class="keyword">this</span>.Data = Data;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> Data;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> Data)</span> </span>&#123;  </div><div class="line">            <span class="keyword">this</span>.Data = Data;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> Next;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node Next)</span> </span>&#123;  </div><div class="line">            <span class="keyword">this</span>.Next = Next;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>以下排序算法内容来自：<a href="https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">面试中的 10 大排序算法总结.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础&lt;br&gt;本片文章Fork from &lt;a href=&quot;https://github.com/guoxiaoxing/android-interview&quot; target=
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://edward7zhang.github.io/tags/Interview/"/>
    
      <category term="Algorithm" scheme="https://edward7zhang.github.io/tags/Algorithm/"/>
    
      <category term="DataStructure" scheme="https://edward7zhang.github.io/tags/DataStructure/"/>
    
  </entry>
  
</feed>
