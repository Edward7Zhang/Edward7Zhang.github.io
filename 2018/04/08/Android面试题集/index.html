<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    
    
    
    <title>Android面试题集 | EdwardZhang&#39;s Blog | Life starts at the end of your comfort zone. ⚽ 🏂 🏃 🚴 ⌨️</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Android,Interview">
    <meta name="description" content="一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章Fork from android-interview并且在此基础上对一些问题进行了补充、深入剖析  手画一下Android系统架构图，描述一下各个层次的作用？Android系统架构图  从上到下依次分为六层：  应用框架层 进程通信层 系统服务层 Android运行时层 硬件抽象层 Linux内核层  Ac">
<meta name="keywords" content="Android,Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="Android面试题集">
<meta property="og:url" content="https://edward7zhang.github.io/2018/04/08/Android面试题集/index.html">
<meta property="og:site_name" content="EdwardZhang&#39;s Blog">
<meta property="og:description" content="一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章Fork from android-interview并且在此基础上对一些问题进行了补充、深入剖析  手画一下Android系统架构图，描述一下各个层次的作用？Android系统架构图  从上到下依次分为六层：  应用框架层 进程通信层 系统服务层 Android运行时层 硬件抽象层 Linux内核层  Ac">
<meta property="og:image" content="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/android_system_structure.png">
<meta property="og:image" content="https://img-blog.csdn.net/20150902003400081">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/944365-0ae738c6d50c0adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://github.com/BeesAndroid/BeesAndroid/blob/master/art/practice/project/module/mvp_structure.png">
<meta property="og:updated_time" content="2018-04-21T04:35:53.113Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android面试题集">
<meta name="twitter:description" content="一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础本片文章Fork from android-interview并且在此基础上对一些问题进行了补充、深入剖析  手画一下Android系统架构图，描述一下各个层次的作用？Android系统架构图  从上到下依次分为六层：  应用框架层 进程通信层 系统服务层 Android运行时层 硬件抽象层 Linux内核层  Ac">
<meta name="twitter:image" content="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/android_system_structure.png">
    
        <link rel="alternate" type="application/atom+xml" title="EdwardZhang&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">EdwardZhang</h5>
          <a href="mailto:Super_Mr.Z@hotmail.com" title="Super_Mr.Z@hotmail.com" class="mail">Super_Mr.Z@hotmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Homepage
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/photo"  >
                <i class="icon icon-lg icon-photo"></i>
                Album
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Edward7Zhang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/3100298257/home?wvr=5" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.instagram.com/major7edward/" target="_blank" >
                <i class="icon icon-lg icon-instagram"></i>
                Instagram
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/link"  >
                <i class="icon icon-lg icon-link"></i>
                Friends&#39; Link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android面试题集</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Android面试题集</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-04-08T01:07:14.000Z" itemprop="datePublished" class="page-time">
  2018-04-08
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#手画一下Android系统架构图，描述一下各个层次的作用？"><span class="post-toc-number">1.</span> <span class="post-toc-text">手画一下Android系统架构图，描述一下各个层次的作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Activity如与Service通信？"><span class="post-toc-number">2.</span> <span class="post-toc-text">Activity如与Service通信？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Service的生命周期与启动方法有什么区别？"><span class="post-toc-number">3.</span> <span class="post-toc-text">Service的生命周期与启动方法有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？"><span class="post-toc-number">4.</span> <span class="post-toc-text">Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#补充事项"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">补充事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bindService和startService混合使用时"><span class="post-toc-number">5.</span> <span class="post-toc-text">bindService和startService混合使用时</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#广播分为哪几种，应用场景是什么？"><span class="post-toc-number">6.</span> <span class="post-toc-text">广播分为哪几种，应用场景是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#广播的两种注册方式有什么区别？"><span class="post-toc-number">7.</span> <span class="post-toc-text">广播的两种注册方式有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#广播发送和接收的原理了解吗？"><span class="post-toc-number">8.</span> <span class="post-toc-text">广播发送和接收的原理了解吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#广播传输的数据是否有限制，是多少，为什么要限制？"><span class="post-toc-number">9.</span> <span class="post-toc-text">广播传输的数据是否有限制，是多少，为什么要限制？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"><span class="post-toc-number">10.</span> <span class="post-toc-text">ContentProvider、ContentResolver与ContentObserver之间的关系是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#遇到过哪些关于Fragment的问题，如何处理的？"><span class="post-toc-number">11.</span> <span class="post-toc-text">遇到过哪些关于Fragment的问题，如何处理的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Android里的Intent传递的数据有大小限制吗，如何解决？"><span class="post-toc-number">12.</span> <span class="post-toc-text">Android里的Intent传递的数据有大小限制吗，如何解决？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#描述一下Android的事件分发机制？"><span class="post-toc-number">13.</span> <span class="post-toc-text">描述一下Android的事件分发机制？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#描述一下View的绘制原理？"><span class="post-toc-number">14.</span> <span class="post-toc-text">描述一下View的绘制原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#requestLayout-、invalidate-与postInvalidate-有什么区别？"><span class="post-toc-number">15.</span> <span class="post-toc-text">requestLayout()、invalidate()与postInvalidate()有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Scroller用过吗，了解它的原理吗？"><span class="post-toc-number">16.</span> <span class="post-toc-text">Scroller用过吗，了解它的原理吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#PathClassLoader与DexClassLoader有什么区别？"><span class="post-toc-number">17.</span> <span class="post-toc-text">PathClassLoader与DexClassLoader有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#WebView优化了解吗，如何提高WebView的加载速度？"><span class="post-toc-number">18.</span> <span class="post-toc-text">WebView优化了解吗，如何提高WebView的加载速度？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java和JS的相互调用怎么实现，有做过什么优化吗？"><span class="post-toc-number">19.</span> <span class="post-toc-text">Java和JS的相互调用怎么实现，有做过什么优化吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JNI了解吗，Java与C-如何相互调用？"><span class="post-toc-number">20.</span> <span class="post-toc-text">JNI了解吗，Java与C++如何相互调用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"><span class="post-toc-number">21.</span> <span class="post-toc-text">了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何做性能优化？"><span class="post-toc-number">22.</span> <span class="post-toc-text">如何做性能优化？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如果防止过度绘制，如何做布局优化？"><span class="post-toc-number">23.</span> <span class="post-toc-text">如果防止过度绘制，如何做布局优化？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何提交代码质量？"><span class="post-toc-number">24.</span> <span class="post-toc-text">如何提交代码质量？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#有没有遇到64k问题，为什么，如何解决？"><span class="post-toc-number">25.</span> <span class="post-toc-text">有没有遇到64k问题，为什么，如何解决？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MVC、MVP与MVVM之间的对比分析？"><span class="post-toc-number">26.</span> <span class="post-toc-text">MVC、MVP与MVVM之间的对比分析？</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Android面试题集"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Android面试题集</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-04-08 09:07:14" datetime="2018-04-08T01:07:14.000Z"  itemprop="datePublished">2018-04-08</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>一次次的挂于一面让我筋疲力竭…意识到自己存在眼高手低的状态…准备重新上路夯实基础<br>本片文章Fork from <a href="https://github.com/guoxiaoxing/android-interview" target="_blank" rel="external">android-interview</a><br>并且在此基础上对一些问题进行了补充、深入剖析</p>
</blockquote>
<h3 id="手画一下Android系统架构图，描述一下各个层次的作用？"><a href="#手画一下Android系统架构图，描述一下各个层次的作用？" class="headerlink" title="手画一下Android系统架构图，描述一下各个层次的作用？"></a>手画一下Android系统架构图，描述一下各个层次的作用？</h3><p>Android系统架构图</p>
<p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/android_system_structure.png" width="600"></p>
<p>从上到下依次分为六层：</p>
<ul>
<li>应用框架层</li>
<li>进程通信层</li>
<li>系统服务层</li>
<li>Android运行时层</li>
<li>硬件抽象层</li>
<li>Linux内核层</li>
</ul>
<h3 id="Activity如与Service通信？"><a href="#Activity如与Service通信？" class="headerlink" title="Activity如与Service通信？"></a>Activity如与Service通信？</h3><p>可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法<br>里执行相关操作。<br><em>注：只有activities,services,和contentproviders可以绑定到一个service—你不能从一个broadcastreceiver绑定到service．</em></p>
<h3 id="Service的生命周期与启动方法有什么区别？"><a href="#Service的生命周期与启动方法有什么区别？" class="headerlink" title="Service的生命周期与启动方法有什么区别？"></a>Service的生命周期与启动方法有什么区别？</h3><ul>
<li>startService()：开启Service，调用者退出后Service仍然存在。</li>
<li>bindService()：开启Service，调用者退出后Service也随即退出。</li>
</ul>
<p>Service生命周期：</p>
<ul>
<li>只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory</li>
<li>只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory</li>
<li>同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory</li>
</ul>
<h3 id="Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？"><a href="#Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？" class="headerlink" title="Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？"></a>Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20150902003400081" alt="bindService生命周期" title="">
                </div>
                <div class="image-caption">bindService生命周期</div>
            </figure>
<p>通过IBinder<br>从你的客户端绑定到一个service，你必须：</p>
<ul>
<li><p>１实现ServiceConnection.</p>
<p>你的实现必须重写两个回调方法：</p>
<ul>
<li><p>onServiceConnected()</p>
<p>系统调用这个来传送在service的onBind()中返回的IBinder．</p>
</li>
<li><p>OnServiceDisconnected()</p>
<p>Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用．</p>
</li>
</ul>
</li>
<li><p>２调用bindService()，传给它ServiceConnection的实现．</p>
</li>
<li><p>３当系统调用你的onServiceConnected()方法时，你就可以使用接口定义的方法们开始调用service了．</p>
</li>
<li><p>４要与service断开连接，调用unbindService()．</p>
<p>　　当你的客户端被销毁，它将从service解除绑定，但是你必须总是在你完成与service的交互时或当你的activity暂停于是service在不被使用时可以关闭此两种情况下解</p>
<p>除绑定．(下面会讨论更多在适当的时候绑定和解除绑定的问题．</p>
<p>使用这个ServiceConnection，客户端可以绑定到一个service，通过把它传给bindService()．例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intentintent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService.class);</div><div class="line">bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</div></pre></td></tr></table></figure>
</li>
<li><p>第一个bindService()的参数是一个明确指定了要绑定的service的Intent．</p>
</li>
<li><p>第二个参数是ServiceConnection对象．</p>
</li>
<li><p>第三个参数是一个标志，它表明绑定中的操作．它一般应是BIND_AUTO_CREATE，这样就会在service不存在时创建一个．其它可选的值是BIND_DEBUG_UNBIND和BIND_NOT_FOREGROUND,不想指定时设为0即可。</p>
</li>
</ul>
<h4 id="补充事项"><a href="#补充事项" class="headerlink" title="补充事项"></a>补充事项</h4><p>下面是一些关于绑定到service的重要事项：</p>
<ul>
<li><p>你总是需要捕获DeadObjectException异常．它会在连接被打断时抛出．这是被远程方法抛出的唯一异常．</p>
</li>
<li><p>对象引用计数是跨进程的作用的．</p>
</li>
<li><p>你应该在客户端的生命期内使绑定和解除绑定配对进行，例如：</p>
<ul>
<li><p>如果你需要在你的activity可见时与service交互，你应该在onStart()绑定并在onStop()中解除绑定．</p>
</li>
<li><p>如果你想让你的activity即使在它停止时也能接收回应，那么你可以在onCreate()中绑定并在onDestroy()中解除绑定．注意这意味着你的activity需要使用在自己整</p>
<p>个运行期间使用service(即使位于后台)，所以如果service在另一个进程中，那么你增加了这个进程的负担而使它变得更容易被系统杀掉．</p>
<p>注：你一般不应该在你的activity的onResume()和onPause()中绑定和解除绑定到service，因为这些回调方法,出现在每个生命期变化中，并且你需要使发生在这</p>
<p>些变化中的处理最小化．还有，如果你应用中的多个activity绑定到同一个service，并且有一个变化发生在其中两个activity之间，service可能在当前activity解除绑</p>
<p>定(pause中)和下一个绑定前(rusume中)被销毁又重建．</p>
</li>
</ul>
</li>
</ul>
<h3 id="bindService和startService混合使用时"><a href="#bindService和startService混合使用时" class="headerlink" title="bindService和startService混合使用时"></a>bindService和startService混合使用时</h3><ol>
<li><p>如果先bindService,再startService:<br>在bind的Activity退出的时候,Service会执行unBind方法而不执行onDestory方法,因为有startService方法调用过,所以Activity与Service解除绑定后会有一个与调用者没有关连的Service存在</p>
</li>
<li><p>如果先bindService,再startService,再调用Context.stopService<br>Service的onDestory方法不会立刻执行,因为有一个与Service绑定的Activity,但是在Activity退出的时候,会执行onDestory,如果要立刻执行stopService,就得先解除绑定</p>
<hr>
</li>
</ol>
<p>把上面的”如果先bindService,再startService”换成”如果先startService,再bindService”,结果是一样的 </p>
<ul>
<li>问题:<br>如果在一个Activity的onCreate方法中,<br>先bindService(serviceIntent,conn,Context.BIND_AUTO_CREATE);<br>再startService(serviceIntent);<br>退出这个Activity时,会执行onUnBind<br>但是再次进入这个Activity的时候,为什么不执行onBind方法了?<br>只有在这个Service销毁后(执行onDestory),再进这个Activity才会执行onBind，还有就是当有两个客户端时，在第一个客户端startServie启动服务再bindService绑定服务,这时跳到第二个客户端里（启动时会调用onBind())，再客户端startServie启动服务再bindService绑定服务，启动时不会调用用onBind()了(因为之前客户端已经启动后没有onDestory()销毁Service，所以再客户端第二次绑定服务时，只会返回IBinder对象给onServiceConnected())，而且要注意的是当，当第一个服务启动并绑定一个服务时，再跳去第二个服务端启动并绑定这个服务时，第二个服务端再解绑时，不会调用onUnbind()，只有回到第一个客户端时，解绑这是才会调用onUnbind(),顺序反过来结果是一样的。得出一个结论是：当一个服务没被onDestory()销毁之前，只有第一个启动它的客户端能调用它的onBind()和onUnbind()。</li>
</ul>
<h3 id="广播分为哪几种，应用场景是什么？"><a href="#广播分为哪几种，应用场景是什么？" class="headerlink" title="广播分为哪几种，应用场景是什么？"></a>广播分为哪几种，应用场景是什么？</h3><ul>
<li>普通广播：调用sendBroadcast()发送，最常用的广播。</li>
<li>有序广播：调用sendOrderedBroadcast()，发出去的广播会被广播接受者按照顺序接收，广播接收者按照Priority属性值从大-小排序，Priority属性相同者，动态注册的广播优先，广播接收者还可以选择对广播进行截断和修改。</li>
</ul>
<h3 id="广播的两种注册方式有什么区别？"><a href="#广播的两种注册方式有什么区别？" class="headerlink" title="广播的两种注册方式有什么区别？"></a>广播的两种注册方式有什么区别？</h3><ul>
<li>静态注册：常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。</li>
<li>动态注册：非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造成内存泄漏。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/944365-0ae738c6d50c0adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
</ul>
<h3 id="广播发送和接收的原理了解吗？"><a href="#广播发送和接收的原理了解吗？" class="headerlink" title="广播发送和接收的原理了解吗？"></a>广播发送和接收的原理了解吗？</h3><ol>
<li>继承BroadcastReceiver，重写onReceive()方法。</li>
<li>通过Binder机制向ActivityManagerService注册广播。</li>
<li>通过Binder机制向ActivityMangerService发送广播。</li>
<li>ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。</li>
<li>BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。</li>
</ol>
<h3 id="广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="广播传输的数据是否有限制，是多少，为什么要限制？"></a>广播传输的数据是否有限制，是多少，为什么要限制？</h3><h3 id="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"><a href="#ContentProvider、ContentResolver与ContentObserver之间的关系是什么？" class="headerlink" title="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"></a>ContentProvider、ContentResolver与ContentObserver之间的关系是什么？</h3><ul>
<li>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。</li>
<li>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</li>
<li>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</li>
</ul>
<h3 id="遇到过哪些关于Fragment的问题，如何处理的？"><a href="#遇到过哪些关于Fragment的问题，如何处理的？" class="headerlink" title="遇到过哪些关于Fragment的问题，如何处理的？"></a>遇到过哪些关于Fragment的问题，如何处理的？</h3><ul>
<li><p>getActivity()空指针：这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()，此时就会有空指针，解决方案是在Fragment里使用<br>一个全局变量mActivity，在onAttach()方法里赋值，这样可能会引起内存泄漏，但是异步任务没有停止的情况下本身就已经可能内存泄漏，相比直接crash，这种方式<br>显得更妥当一些。</p>
</li>
<li><p>Fragment视图重叠：在类onCreate()的方法加载Fragment，并且没有判断saveInstanceState==null或if(findFragmentByTag(mFragmentTag) == null)，导致重复加载了同一个Fragment导致重叠。（PS：replace情况下，如果没有加入回退栈，则不判断也不会造成重叠，但建议还是统一判断下）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line"><span class="comment">// 在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠 ;</span></div><div class="line">    <span class="keyword">if</span>(saveInstanceState == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">// 或者 if(findFragmentByTag(mFragmentTag) == null)</span></div><div class="line">       <span class="comment">// 正常情况下去 加载根Fragment </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Android里的Intent传递的数据有大小限制吗，如何解决？"><a href="#Android里的Intent传递的数据有大小限制吗，如何解决？" class="headerlink" title="Android里的Intent传递的数据有大小限制吗，如何解决？"></a>Android里的Intent传递的数据有大小限制吗，如何解决？</h3><p>Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。处理方式如下：</p>
<ul>
<li>进程内：EventBus，文件缓存、磁盘缓存。</li>
<li>进程间：通过ContentProvider进行款进程数据共享和传递。</li>
</ul>
<h3 id="描述一下Android的事件分发机制？"><a href="#描述一下Android的事件分发机制？" class="headerlink" title="描述一下Android的事件分发机制？"></a>描述一下Android的事件分发机制？</h3><p>Android事件分发机制的本质：事件从哪个对象发出，经过哪些对象，最终由哪个对象处理了该事件。此处对象指的是Activity、Window与View。</p>
<p>Android事件的分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View</p>
<p>Android事件的分发主要由三个方法来完成，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父View调用dispatchTouchEvent()开始分发事件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 父View决定是否拦截事件</span></div><div class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(event))&#123;</div><div class="line">        <span class="comment">// 父View调用onTouchEvent(event)消费事件，如果该方法返回true，表示</span></div><div class="line">        <span class="comment">// 该View消费了该事件，后续该事件序列的事件（Down、Move、Up）将不会在传递</span></div><div class="line">        <span class="comment">// 该其他View。</span></div><div class="line">        consume = onTouchEvent(event);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 调用子View的dispatchTouchEvent(event)方法继续分发事件</span></div><div class="line">        consume = child.dispatchTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="描述一下View的绘制原理？"><a href="#描述一下View的绘制原理？" class="headerlink" title="描述一下View的绘制原理？"></a>描述一下View的绘制原理？</h3><p>View的绘制流程主要分为三步：</p>
<ol>
<li>onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成绘制工作。</li>
<li>onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。</li>
<li>onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。<br>④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。</li>
</ol>
<h3 id="requestLayout-、invalidate-与postInvalidate-有什么区别？"><a href="#requestLayout-、invalidate-与postInvalidate-有什么区别？" class="headerlink" title="requestLayout()、invalidate()与postInvalidate()有什么区别？"></a>requestLayout()、invalidate()与postInvalidate()有什么区别？</h3><ul>
<li>requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定<br>会触发onDraw()方法。</li>
<li>invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。</li>
<li>postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。</li>
</ul>
<p>一般说来需要重新布局就调用requestLayout()方法，需要重新绘制就调用invalidate()方法。</p>
<h3 id="Scroller用过吗，了解它的原理吗？"><a href="#Scroller用过吗，了解它的原理吗？" class="headerlink" title="Scroller用过吗，了解它的原理吗？"></a>Scroller用过吗，了解它的原理吗？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div></pre></td><td class="code"><pre><div class="line">//实例化Scroller对象，在自定义View中，mContext可以在自定义View的构造方法中获取</div><div class="line">Scroller mScroller = new Scroller(mContext);</div><div class="line"></div><div class="line">//在一个自定义View中实现该方法，方法名可以自定义</div><div class="line">public void smoothScrollTo(int destX,int destY)&#123;</div><div class="line">    int scrollX = getScrollX();</div><div class="line">    int scrollY  = getScrollY();</div><div class="line">    int dx = destX - scrollX;</div><div class="line">    int dy = destY - scrollY;</div><div class="line">    //前两个参数表示起始位置，第三第四个参数表示位移量，最后一个参数表示时间</div><div class="line">    mScroller.startScroll(scrollX,scrollY,dx,dy,1000);</div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//自定义View中重写该方法</div><div class="line">@Override</div><div class="line">public void computeScroll()&#123;</div><div class="line">    if(mScroller.computeScrollOffset())&#123;</div><div class="line">       scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</div><div class="line">       postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">Scroller滑动的整个过程(图片From：https://img-blog.csdn.net/20160919174056964)</div><div class="line">&lt;img src="https://img-blog.csdn.net/20160919174056964"/&gt;</div><div class="line"></div><div class="line">### 了解APK的打包流程吗，描述一下？</div><div class="line"></div><div class="line">Android的包文件APK分为两个部分：代码和资源，所以打包方面也分为资源打包和代码打包两个方面，这篇文章就来分析资源和代码的编译打包原理。</div><div class="line"></div><div class="line">APK整体的的打包流程如下图所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/vm/apk_package_flow.png"/&gt;</div><div class="line"></div><div class="line">具体说来：</div><div class="line"></div><div class="line">1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。</div><div class="line">2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。</div><div class="line">3. 通过Javac工具编译项目源码，生成Class文件。</div><div class="line">4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。</div><div class="line">5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。</div><div class="line">6. 利用KeyStore对生成的APK文件进行签名。</div><div class="line">7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件</div><div class="line">的速度会更快。</div><div class="line"></div><div class="line">### 了解APK的安装流程吗，描述一下？</div><div class="line"></div><div class="line">APK的安装流程如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/package/apk_install_structure.png" width="600"/&gt;</div><div class="line"></div><div class="line">1. 复制APK到/data/app目录下，解压并扫描安装包。</div><div class="line">2. 资源管理器解析APK里的资源文件。</div><div class="line">3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。</div><div class="line">4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。</div><div class="line">5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。</div><div class="line">5. 安装完成后，发送广播。</div><div class="line"></div><div class="line">### 当点击一个应用图标以后，都发生了什么，描述一下这个过程？</div><div class="line"></div><div class="line">点击应用图标后会去启动应用的LauncherActivity，如果LancerActivity所在的进程没有创建，还会创建新进程，整体的流程就是一个Activity的启动流程。</div><div class="line"></div><div class="line">Activity的启动流程图（放大可查看）如下所示：</div><div class="line"></div><div class="line">![Activity的启动流程图](https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_start_flow.png)</div><div class="line"></div><div class="line">整个流程涉及的主要角色有：</div><div class="line"></div><div class="line">- Instrumentation: 监控应用与系统相关的交互行为。</div><div class="line">- AMS：组件管理调度中心，什么都不干，但是什么都管。</div><div class="line">- ActivityStarter：Activity启动的控制器，处理Intent与Flag对Activity启动的影响，具体说来有：1 寻找符合启动条件的Activity，如果有多个，让用户选择；2 校验启动参数的合法性；3 返回int参数，代表Activity是否启动成功。</div><div class="line">- ActivityStackSupervisior：这个类的作用你从它的名字就可以看出来，它用来管理任务栈。</div><div class="line">- ActivityStack：用来管理任务栈里的Activity。</div><div class="line">- ActivityThread：最终干活的人，是ActivityThread的内部类，Activity、Service、BroadcastReceiver的启动、切换、调度等各种操作都在这个类里完成。</div><div class="line"></div><div class="line">注：这里单独提一下ActivityStackSupervisior，这是高版本才有的类，它用来管理多个ActivityStack，早期的版本只有一个ActivityStack对应着手机屏幕，后来高版本支持多屏以后，就</div><div class="line">有了多个ActivityStack，于是就引入了ActivityStackSupervisior用来管理多个ActivityStack。</div><div class="line"></div><div class="line">整个流程主要涉及四个进程：</div><div class="line"></div><div class="line">- 调用者进程，如果是在桌面启动应用就是Launcher应用进程。</div><div class="line">- ActivityManagerService等所在的System Server进程，该进程主要运行着系统服务组件。</div><div class="line">- Zygote进程，该进程主要用来fork新进程。</div><div class="line">- 新启动的应用进程，该进程就是用来承载应用运行的进程了，它也是应用的主线程（新创建的进程就是主线程），处理组件生命周期、界面绘制等相关事情。</div><div class="line">![img](http://upload-images.jianshu.io/upload_images/3985563-b7edc7b70c9c332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">有了以上的理解，整个流程可以概括如下：</div><div class="line"></div><div class="line">1. 点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。</div><div class="line">2. AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack</div><div class="line">处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。</div><div class="line">3. Zygote接收到新进程创建请求后fork出新进程。</div><div class="line">4. 在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。</div><div class="line">5. ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。</div><div class="line"></div><div class="line">### BroadcastReceiver与LocalBroadcastReceiver有什么区别？</div><div class="line"></div><div class="line">- BroadcastReceiver 是跨应用广播，利用Binder机制实现。</div><div class="line">- LocalBroadcastReceiver 是应用内广播，利用Handler实现，利用了IntentFilter的match功能，提供消息的发布与接收功能，实现应用内通信，效率比较高。</div><div class="line"></div><div class="line">### Android Handler机制是做什么的，原理了解吗？</div><div class="line"></div><div class="line">Android消息循环流程图如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_structure.png"/&gt;</div><div class="line"></div><div class="line">主要涉及的角色如下所示：</div><div class="line"></div><div class="line">- Message：消息，分为硬件产生的消息（例如：按钮、触摸）和软件产生的消息。</div><div class="line">- MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。</div><div class="line">- Looper：消息循环器，主要用来把消息分发给相应的处理者。</div><div class="line">- Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。</div><div class="line"></div><div class="line">整个消息的循环流程还是比较清晰的，具体说来：</div><div class="line"></div><div class="line">1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。</div><div class="line">2. Looper通过loop()不断提取触发条件的Message，并将Message交给对应的target handler来处理。</div><div class="line">3. target handler调用自身的handleMessage()方法来处理Message。</div><div class="line"></div><div class="line">事实上，在整个消息循环的流程中，并不只有Java层参与，很多重要的工作都是在C++层来完成的。我们来看下这些类的调用关系。</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_class.png"/&gt;</div><div class="line"></div><div class="line">注：虚线表示关联关系，实线表示调用关系。</div><div class="line"></div><div class="line">在这些类中MessageQueue是Java层与C++层维系的桥梁，MessageQueue与Looper相关功能都通过MessageQueue的Native方法来完成，而其他虚线连接的类只有关联关系，并没有</div><div class="line">直接调用的关系，它们发生关联的桥梁是MessageQueue。</div><div class="line"></div><div class="line">### Android Binder机制是做什么的，为什么选用Binder，原理了解吗？</div><div class="line"></div><div class="line">Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。</div><div class="line"></div><div class="line">为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种：</div><div class="line"></div><div class="line">1. 管道：在创建时分配一个page大小的内存，缓存区大小比较有限；</div><div class="line">2. 消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</div><div class="line">3. 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</div><div class="line">4. 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</div><div class="line">5. 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</div><div class="line">6. 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</div><div class="line"></div><div class="line">既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量：</div><div class="line"></div><div class="line">- 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。</div><div class="line">- 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。</div><div class="line">- 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传送IPC只能由用户在数据包里填入UID/PID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。</div><div class="line"></div><div class="line">### 描述一下Activity的生命周期，这些生命周期是如何管理的？</div><div class="line"></div><div class="line">Activity与Fragment生命周期如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/complete_android_fragment_lifecycle.png"/&gt;</div><div class="line"></div><div class="line">读者可以从上图看出，Activity有很多种状态，状态之间的变化也比较复杂，在众多状态中，只有三种是常驻状态：</div><div class="line"></div><div class="line">- Resumed（运行状态）：Activity处于前台，用户可以与其交互。</div><div class="line">- Paused（暂停状态）：Activity被其他Activity部分遮挡，无法接受用户的输入。</div><div class="line">- Stopped（停止状态）：Activity被完全隐藏，对用户不可见，进入后台。</div><div class="line"></div><div class="line">其他的状态都是中间状态。</div><div class="line"></div><div class="line">我们再来看看生命周期变化时的整个调度流程，生命周期调度流程图如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_lifecycle_structure.png" /&gt;</div><div class="line"></div><div class="line">所以你可以看到，整个流程是这样的：</div><div class="line"></div><div class="line">1. 比方说我们点击跳转一个新Activity，这个时候Activity会入栈，同时它的生命周期也会从onCreate()到onResume()开始变换，这个过程是在ActivityStack里完成的，ActivityStack</div><div class="line">是运行在Server进程里的，这个时候Server进程就通过ApplicationThread的代理对象ApplicationThreadProxy向运行在app进程ApplicationThread发起操作请求。</div><div class="line">2. ApplicationThread接收到操作请求后，因为它是运行在app进程里的其他线程里，所以ApplicationThread需要通过Handler向主线程ActivityThread发送操作消息。</div><div class="line">3. 主线程接收到ApplicationThread发出的消息后，调用主线程ActivityThread执行响应的操作，并回调Activity相应的周期方法。</div><div class="line"></div><div class="line">注：这里提到了主线程ActivityThread，更准确来说ActivityThread不是线程，因为它没有继承Thread类或者实现Runnable接口，它是运行在应用主线程里的对象，那么应用的主线程</div><div class="line">到底是什么呢？从本质上来讲启动启动时创建的进程就是主线程，线程和进程处理是否共享资源外，没有其他的区别，对于Linux来说，它们都只是一个struct结构体。</div><div class="line"></div><div class="line">### Activity的通信方式有哪些？</div><div class="line"></div><div class="line">- startActivityForResult</div><div class="line">- EventBus</div><div class="line">- LocalBroadcastReceiver</div><div class="line"></div><div class="line">### Android应用里有几种Context对象，</div><div class="line"></div><div class="line">Context类图如下所示：</div><div class="line"></div><div class="line">&lt;img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/context_uml.png" width="600" /&gt;</div><div class="line"></div><div class="line">可以发现Context是个抽象类，它的具体实现类是ContextImpl，ContextWrapper是个包装类，内部的成员变量mBase指向的也是个ContextImpl对象，ContextImpl完成了</div><div class="line">实际的功能，Activity、Service与Application都直接或者间接的继承ContextWrapper。</div><div class="line"></div><div class="line">### 描述一下进程和Application的生命周期？</div><div class="line"></div><div class="line">一个安装的应用对应一个LoadedApk对象，对应一个Application对象，对于四大组件，Application的创建和获取方式也是不尽相同的，具体说来：</div><div class="line"></div><div class="line">- Activity：通过LoadedApk的makeApplication()方法创建。</div><div class="line">- Service：通过LoadedApk的makeApplication()方法创建。</div><div class="line">- 静态广播：通过其回调方法onReceive()方法的第一个参数指向Application。</div><div class="line">- ContentProvider：无法获取Application，因此此时Application不一定已经初始化。</div><div class="line"></div><div class="line">### Android哪些情况会导致内存泄漏，如何分析内存泄漏？</div><div class="line"></div><div class="line">常见的产生内存泄漏的情况如下所示：</div><div class="line"></div><div class="line">- 持有静态的Context（Activity）引用。</div><div class="line">- 持有静态的View引用，</div><div class="line">- 内部类&amp;匿名内部类实例无法释放（有延迟时间等等），而内部类又持有外部类的强引用，导致外部类无法释放，这种匿名内部类常见于监听器、Handler、Thread、TimerTask</div><div class="line">- 资源使用完成后没有关闭，例如：BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap。</div><div class="line">- 不正确的单例模式，比如单例持有Activity。</div><div class="line">- 集合类内存泄漏，如果一个集合类是静态的（缓存HashMap），只有添加方法，没有对应的删除方法，会导致引用无法被释放，引发内存泄漏。</div><div class="line">- 错误的覆写了finalize()方法，finalize()方法执行执行不确定，可能会导致引用无法被释放。</div><div class="line"></div><div class="line">查找内存泄漏可以使用Android Profiler工具或者利用LeakCanary工具。</div><div class="line"></div><div class="line">### Android有哪几种进程，是如何管理的？</div><div class="line"></div><div class="line">Android的进程主要分为以下几种：</div><div class="line"></div><div class="line">**前台进程**</div><div class="line"></div><div class="line">用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</div><div class="line"></div><div class="line">- 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</div><div class="line">- 托管某个 Service，后者绑定到用户正在交互的 Activity</div><div class="line">- 托管正在“前台”运行的 Service（服务已调用 startForeground()）</div><div class="line">- 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</div><div class="line">- 托管正执行其 onReceive() 方法的 BroadcastReceiver</div><div class="line"></div><div class="line">通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</div><div class="line"></div><div class="line">**可见进程**</div><div class="line"></div><div class="line">没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</div><div class="line"></div><div class="line">- 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</div><div class="line">- 托管绑定到可见（或前台）Activity 的 Service。</div><div class="line"></div><div class="line">可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</div><div class="line"></div><div class="line">**服务进程**</div><div class="line"></div><div class="line">正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关</div><div class="line">心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</div><div class="line"></div><div class="line">**后台进程**</div><div class="line"></div><div class="line">包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</div><div class="line"></div><div class="line">**空进程**</div><div class="line"></div><div class="line">不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</div><div class="line"></div><div class="line">ActivityManagerService负责根据各种策略算法计算进程的adj值，然后交由系统内核进行进程的管理。</div><div class="line"></div><div class="line">### SharePreference性能优化，可以做进程同步吗？</div><div class="line"></div><div class="line">在Android中, SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件</div><div class="line">存放在/data/data/ &lt; package name &gt; /shared_prefs目录下.</div><div class="line"></div><div class="line">之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会把整个文件全部加载进内存，如果SharedPreference文件比较大，会带来以下问题：</div><div class="line"></div><div class="line">1. 第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。</div><div class="line">2. 解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。</div><div class="line">3. 这些key和value会永远存在于内存之中，占用大量内存。</div><div class="line"></div><div class="line">优化建议</div><div class="line"></div><div class="line">1. 不要存放大的key和value，会引起界面卡、频繁GC、占用内存等等。</div><div class="line">2. 毫不相关的配置项就不要放在在一起，文件越大读取越慢。</div><div class="line">3. 读取频繁的key和不易变动的key尽量不要放在一起，影响速度，如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失。</div><div class="line">4. 不要乱edit和apply，尽量批量修改一次提交，多次apply会阻塞主线程。</div><div class="line">5. 尽量不要存放JSON和HTML，这种场景请直接使用JSON。</div><div class="line">6. SharedPreference无法进行跨进程通信，MODE_MULTI_PROCESS只是保证了在API 11以前的系统上，如果sp已经被读取进内存，再次获取这个SharedPreference的时候，如果有这个flag，会重新读一遍文件，仅此而已。</div><div class="line"></div><div class="line">### 如何做SQLite升级？</div><div class="line"></div><div class="line">数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：</div><div class="line"></div><div class="line">1. 将现有表命名为临时表。</div><div class="line">2. 创建新表。</div><div class="line">3. 将临时表的数据导入新表。</div><div class="line">4. 删除临时表。</div><div class="line"></div><div class="line">重写</div><div class="line"></div><div class="line">如果是跨版本数据库升级，可以由两种方式，如下所示：</div><div class="line"></div><div class="line">1. 逐级升级，确定相邻版本与现在版本的差别，V1升级到V2,V2升级到V3，依次类推。</div><div class="line">2. 跨级升级，确定每个版本与现在数据库的差别，为每个case编写专门升级大代码。</div><div class="line"></div><div class="line">### 进程保护如何做，如何唤醒其他进程？</div><div class="line"></div><div class="line">进程保活主要有两个思路：</div><div class="line"></div><div class="line">1. 提升进程的优先级，降低进程被杀死的概率。</div><div class="line">2. 拉活已经被杀死的进程。</div><div class="line"></div><div class="line">如何提升优先级，如下所示：</div><div class="line"></div><div class="line">监控手机锁屏事件，在屏幕锁屏时启动一个像素的Activity，在用户解锁时将Activity销毁掉，前台Activity可以将进程变成前台进程，优先级升级到最高。</div><div class="line"></div><div class="line">如果拉活</div><div class="line"></div><div class="line">利用广播拉活Activity。</div><div class="line"></div><div class="line">### 理解序列化吗，Android为什么引入Parcelable？</div><div class="line"></div><div class="line">所谓序列化就是将对象变成二进制流，便于存储和传输。</div><div class="line"></div><div class="line">- Serializable是java实现的一套序列化方式，可能会触发频繁的IO操作，效率比较低，适合将对象存储到磁盘上的情况。</div><div class="line">- Parcelable是Android提供一套序列化机制，它将序列化后的字节流写入到一个共性内存中，其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息。</div><div class="line"></div><div class="line">### 如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？</div><div class="line"></div><div class="line">Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</div><div class="line"></div><div class="line">注：这里inDensity表示目标图片的dpi（放在哪个资源文件夹下），inTargetDensity表示目标屏幕的dpi，所以你可以发现inDensity和inTargetDensity会对Bitmap的宽高</div><div class="line">进行拉伸，进而改变Bitmap占用内存的大小。</div><div class="line"></div><div class="line">在Bitmap里有两个获取内存占用大小的方法。</div><div class="line"></div><div class="line">- getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。</div><div class="line">- getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 getByteCount() 方法。</div><div class="line"></div><div class="line">在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大</div><div class="line">小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。</div><div class="line"></div><div class="line">为了保证在加载Bitmap的时候不产生内存溢出，可以受用BitmapFactory进行图片压缩，主要有以下几个参数：</div><div class="line"></div><div class="line">- BitmapFactory.Options.inPreferredConfig：将ARGB_8888改为RGB_565，改变编码方式，节约内存。</div><div class="line">- BitmapFactory.Options.inSampleSize：缩放比例，可以参考Luban那个库，根据图片宽高计算出合适的缩放比例。</div><div class="line">- BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。</div><div class="line"></div><div class="line">### Android如何在不压缩的情况下加载高清大图？</div><div class="line"></div><div class="line">使用BitmapRegionDecoder进行布局加载。</div><div class="line"></div><div class="line">### Android里的内存缓存和磁盘缓存是怎么实现的。</div><div class="line"></div><div class="line">内存缓存基于LruCache实现，磁盘缓存基于DiskLruCache实现。这两个类都基于Lru算法和LinkedHashMap来实现。</div><div class="line"></div><div class="line">LRU算法可以用一句话来描述，如下所示：</div><div class="line"></div><div class="line">&gt;LRU是Least Recently Used的缩写，最近最久未使用算法，从它的名字就可以看出，它的核心原则是如果一个数据在最近一段时间没有使用到，那么它在将来被</div><div class="line">访问到的可能性也很小，则这类数据项会被优先淘汰掉。</div><div class="line"></div><div class="line">LruCache的原理是利用LinkedHashMap持有对象的强引用，按照Lru算法进行对象淘汰。具体说来假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。</div><div class="line">                                                      </div><div class="line">为什么会选择LinkedHashMap呢？</div><div class="line"></div><div class="line">这跟LinkedHashMap的特性有关，LinkedHashMap的构造函数里有个布尔参数accessOrder，当它为true时，LinkedHashMap会以访问顺序为序排列元素，否则以插入顺序为序排序元素。</div><div class="line"></div><div class="line">DiskLruCache与LruCache原理相似，只是多了一个journal文件来做磁盘文件的管理和迎神，如下所示：</div></pre></td></tr></table></figure>
<p>libcore.io.DiskLruCache<br>1<br>1<br>1</p>
<p>DIRTY 1517126350519<br>CLEAN 1517126350519 5325928<br>REMOVE 1517126350519<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注：这里的缓存目录是应用的缓存目录/data/data/pckagename/cache，未root的手机可以通过以下命令进入到该目录中或者将该目录整体拷贝出来：</div><div class="line"></div><div class="line">```java</div><div class="line"></div><div class="line">//进入/data/data/pckagename/cache目录</div><div class="line">adb shell</div><div class="line">run-as com.your.packagename </div><div class="line">cp /data/data/com.your.packagename/</div><div class="line"></div><div class="line">//将/data/data/pckagename目录拷贝出来</div><div class="line">adb backup -noapk com.your.packagename</div></pre></td></tr></table></figure></p>
<p>我们来分析下这个文件的内容：</p>
<ul>
<li>第一行：libcore.io.DiskLruCache，固定字符串。</li>
<li>第二行：1，DiskLruCache源码版本号。</li>
<li>第三行：1，App的版本号，通过open()方法传入进去的。</li>
<li>第四行：1，每个key对应几个文件，一般为1.</li>
<li>第五行：空行</li>
<li>第六行及后续行：缓存操作记录。</li>
</ul>
<p>第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以下三点：</p>
<ol>
<li>DIRTY 表示一个entry正在被写入。写入分两种情况，如果成功会紧接着写入一行CLEAN的记录；如果失败，会增加一行REMOVE记录。注意单独只有DIRTY状态的记录是非法的。</li>
<li>当手动调用remove(key)方法的时候也会写入一条REMOVE记录。</li>
<li>READ就是说明有一次读取的记录。</li>
<li>CLEAN的后面还记录了文件的长度，注意可能会一个key对应多个文件，那么就会有多个数字。</li>
</ol>
<h3 id="PathClassLoader与DexClassLoader有什么区别？"><a href="#PathClassLoader与DexClassLoader有什么区别？" class="headerlink" title="PathClassLoader与DexClassLoader有什么区别？"></a>PathClassLoader与DexClassLoader有什么区别？</h3><ul>
<li>PathClassLoader：只能加载已经安装到Android系统的APK文件，即/data/app目录，Android默认的类加载器。</li>
<li>DexClassLoader：可以加载任意目录下的dex、jar、apk、zip文件。</li>
</ul>
<h3 id="WebView优化了解吗，如何提高WebView的加载速度？"><a href="#WebView优化了解吗，如何提高WebView的加载速度？" class="headerlink" title="WebView优化了解吗，如何提高WebView的加载速度？"></a>WebView优化了解吗，如何提高WebView的加载速度？</h3><p>为什么WebView加载会慢呢？</p>
<blockquote>
<p>这是因为在客户端中，加载H5页面之前，需要先初始化WebView，在WebView完全初始化完成之前，后续的界面加载过程都是被阻塞的。</p>
</blockquote>
<p>优化手段围绕着以下两个点进行：</p>
<ol>
<li>预加载WebView。</li>
<li>加载WebView的同时，请求H5页面数据。</li>
</ol>
<p>因此常见的方法是：</p>
<ol>
<li>全局WebView。</li>
<li>客户端代理页面请求。WebView初始化完成后向客户端请求数据。</li>
<li>asset存放离线包。</li>
</ol>
<p>除此之外还有一些其他的优化手段：</p>
<ul>
<li>脚本执行慢，可以让脚本最后运行，不阻塞页面解析。</li>
<li>DNS与链接慢，可以让客户端复用使用的域名与链接。</li>
<li>React框架代码执行慢，可以将这部分代码拆分出来，提前进行解析。</li>
</ul>
<h3 id="Java和JS的相互调用怎么实现，有做过什么优化吗？"><a href="#Java和JS的相互调用怎么实现，有做过什么优化吗？" class="headerlink" title="Java和JS的相互调用怎么实现，有做过什么优化吗？"></a>Java和JS的相互调用怎么实现，有做过什么优化吗？</h3><p>jockeyjs：<a href="https://github.com/tcoulter/jockeyjs" target="_blank" rel="external">https://github.com/tcoulter/jockeyjs</a></p>
<p>对协议进行统一的封装和处理。</p>
<h3 id="JNI了解吗，Java与C-如何相互调用？"><a href="#JNI了解吗，Java与C-如何相互调用？" class="headerlink" title="JNI了解吗，Java与C++如何相互调用？"></a>JNI了解吗，Java与C++如何相互调用？</h3><p>Java调用C++</p>
<ol>
<li>在Java中声明Native方法（即需要调用的本地方法）</li>
<li>编译上述 Java源文件javac（得到 .class文件）</li>
<li>通过 javah 命令导出JNI的头文件（.h文件）</li>
<li>使用 Java需要交互的本地代码 实现在 Java中声明的Native方法 </li>
<li>编译.so库文件</li>
<li>通过Java命令执行 Java程序，最终实现Java调用本地代码</li>
</ol>
<p>C++调用Java</p>
<ol>
<li>从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。</li>
<li>获取类的默认构造方法ID。</li>
<li>查找实例方法的ID。</li>
<li>创建该类的实例。</li>
<li>调用对象的实例方法。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod</span>  </span></div><div class="line"><span class="params">(JNIEnv *env, jclass cls)</span>  </div><div class="line">&#123;  </div><div class="line">    jclass clazz = <span class="literal">NULL</span>;  </div><div class="line">    jobject jobj = <span class="literal">NULL</span>;  </div><div class="line">    jmethodID mid_construct = <span class="literal">NULL</span>;  </div><div class="line">    jmethodID mid_instance = <span class="literal">NULL</span>;  </div><div class="line">    jstring str_arg = <span class="literal">NULL</span>;  </div><div class="line">    <span class="comment">// 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  </span></div><div class="line">    clazz = (*env)-&gt;FindClass(env, <span class="string">"com/study/jnilearn/ClassMethod"</span>);  </div><div class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"找不到'com.study.jnilearn.ClassMethod'这个类"</span>);  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 2、获取类的默认构造方法ID  </span></div><div class="line">    mid_construct = (*env)-&gt;GetMethodID(env,clazz, <span class="string">"&lt;init&gt;"</span>,<span class="string">"()V"</span>);  </div><div class="line">    <span class="keyword">if</span> (mid_construct == <span class="literal">NULL</span>) &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"找不到默认的构造方法"</span>);  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 3、查找实例方法的ID  </span></div><div class="line">    mid_instance = (*env)-&gt;GetMethodID(env, clazz, <span class="string">"callInstanceMethod"</span>, <span class="string">"(Ljava/lang/String;I)V"</span>);  </div><div class="line">    <span class="keyword">if</span> (mid_instance == <span class="literal">NULL</span>) &#123;  </div><div class="line"></div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 4、创建该类的实例  </span></div><div class="line">    jobj = (*env)-&gt;NewObject(env,clazz,mid_construct);  </div><div class="line">    <span class="keyword">if</span> (jobj == <span class="literal">NULL</span>) &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法"</span>);  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">// 5、调用对象的实例方法  </span></div><div class="line">    str_arg = (*env)-&gt;NewStringUTF(env,<span class="string">"我是实例方法"</span>);  </div><div class="line">    (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,<span class="number">200</span>);  </div><div class="line"></div><div class="line">    <span class="comment">// 删除局部引用  </span></div><div class="line">    (*env)-&gt;DeleteLocalRef(env,clazz);  </div><div class="line">    (*env)-&gt;DeleteLocalRef(env,jobj);  </div><div class="line">    (*env)-&gt;DeleteLocalRef(env,str_arg);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"><a href="#了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？" class="headerlink" title="了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"></a>了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？</h3><ul>
<li>插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。</li>
<li>热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。</li>
</ul>
<p>利用PathClassLoader和DexClassLoader去加载与bug类同名的类，替换掉bug类，进而达到修复bug的目的，原理是在app打包的时候阻止类打上CLASS_ISPREVERIFIED标志，然后在<br>热修复的时候动态改变BaseDexClassLoader对象间接引用的dexElements，替换掉旧的类。</p>
<p>目前热修复框架主要分为两大类：</p>
<ul>
<li>Sophix：修改方法指针。</li>
<li>Tinker：修改dex数组元素。</li>
</ul>
<h3 id="如何做性能优化？"><a href="#如何做性能优化？" class="headerlink" title="如何做性能优化？"></a>如何做性能优化？</h3><ol>
<li>节制的使用Service，当启动一个Service时，系统总是倾向于保留这个Service依赖的进程，这样会造成系统资源的浪费，可以使用IntentService，执行完成任务后会自动停止。</li>
<li>当界面不可见时释放内存，可以重写Activity的onTrimMemory()方法，然后监听TRIM_MEMORY_UI_HIDDEN这个级别，这个级别说明用户离开了页面，可以考虑释放内存和资源。</li>
<li>避免在Bitmap浪费过多的内存，使用压缩过的图片，也可以使用Fresco等库来优化对Bitmap显示的管理。</li>
<li>使用优化过的数据集合SparseArray代替HashMap，HashMap为每个键值都提供一个对象入口，使用SparseArray可以免去基本对象类型转换为引用数据类想的时间。</li>
</ol>
<h3 id="如果防止过度绘制，如何做布局优化？"><a href="#如果防止过度绘制，如何做布局优化？" class="headerlink" title="如果防止过度绘制，如何做布局优化？"></a>如果防止过度绘制，如何做布局优化？</h3><ol>
<li>使用include复用布局文件。</li>
<li>使用merge标签避免嵌套布局。</li>
<li>使用stub标签仅在需要的时候在展示出来。</li>
</ol>
<h3 id="如何提交代码质量？"><a href="#如何提交代码质量？" class="headerlink" title="如何提交代码质量？"></a>如何提交代码质量？</h3><ol>
<li>避免创建不必要的对象，尽可能避免频繁的创建临时对象，例如在for循环内，减少GC的次数。</li>
<li>尽量使用基本数据类型代替引用数据类型。</li>
<li>静态方法调用效率高于动态方法，也可以避免创建额外对象。</li>
<li>对于基本数据类型和String类型的常量要使用static final修饰，这样常量会在dex文件的初始化器中进行初始化，使用的时候可以直接使用。</li>
<li>多使用系统API，例如数组拷贝System.arrayCopy()方法，要比我们用for循环效率快9倍以上，因为系统API很多都是通过底层的汇编模式执行的，效率比较高。</li>
</ol>
<h3 id="有没有遇到64k问题，为什么，如何解决？"><a href="#有没有遇到64k问题，为什么，如何解决？" class="headerlink" title="有没有遇到64k问题，为什么，如何解决？"></a>有没有遇到64k问题，为什么，如何解决？</h3><ul>
<li>在DEX文件中，method、field、class等的个数使用short类型来做索引，即两个字节（65535），method、field、class等均有此限制。</li>
<li>APK在安装过程中会调用dexopt将DEX文件优化成ODEX文件，dexopt使用LinearAlloc来存储应用信息，关于LinearAlloc缓冲区大小，不同的版本经历了4M/8M/16M的限制，超出<br>缓冲区时就会抛出INSTALL_FAILED_DEXOPT错误。</li>
</ul>
<p>解决方案是Google的MultiDex方案，具体参见：<a href="https://developer.android.com/studio/build/multidex.html?hl=zh-cn" target="_blank" rel="external">配置方法数超过 64K 的应用</a>。</p>
<h3 id="MVC、MVP与MVVM之间的对比分析？"><a href="#MVC、MVP与MVVM之间的对比分析？" class="headerlink" title="MVC、MVP与MVVM之间的对比分析？"></a>MVC、MVP与MVVM之间的对比分析？</h3><p><img src="https://github.com/BeesAndroid/BeesAndroid/blob/master/art/practice/project/module/mvp_structure.png"></p>
<ul>
<li>MVC：PC时代就有的架构方案，在Android上也是最早的方案，Activity/Fragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到<br>耦合过重，Activity/Fragment类过大等问题。</li>
<li>MVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。</li>
<li>MVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是<br>一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享View<br>Model数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-04-21T04:35:53.113Z" itemprop="dateUpdated">2018-04-21 12:35:53</time>
</span><br>


        
        Original Link：<a href="/2018/04/08/Android面试题集/" target="_blank" rel="external">https://edward7zhang.github.io/2018/04/08/Android面试题集/</a>
        
    </div>
    
    <footer>
        <a href="https://edward7zhang.github.io">
            <img src="/img/avatar.jpg" alt="EdwardZhang">
            EdwardZhang
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/">Interview</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2018/04/08/Android面试题集/&title=《Android面试题集》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2018/04/08/Android面试题集/&title=《Android面试题集》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2018/04/08/Android面试题集/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android面试题集》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2018/04/08/Android面试题集/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2018/04/08/Android面试题集/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/04/10/Java面试题集/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java面试题集</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/03/30/计算机网络基础汇总/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">计算机网络基础汇总</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'EdwardZhang777';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>EdwardZhang &copy; 2016 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://edward7zhang.github.io/2018/04/08/Android面试题集/&title=《Android面试题集》 — EdwardZhang's Blog&pic=https://edward7zhang.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://edward7zhang.github.io/2018/04/08/Android面试题集/&title=《Android面试题集》 — EdwardZhang's Blog&source=Life starts at the end of your comfort zone." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://edward7zhang.github.io/2018/04/08/Android面试题集/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android面试题集》 — EdwardZhang's Blog&url=https://edward7zhang.github.io/2018/04/08/Android面试题集/&via=https://edward7zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://edward7zhang.github.io/2018/04/08/Android面试题集/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLElEQVR42u3aQQ7CMAwFUe5/6XKAqmX83SLFmawQCm0eC8ux/fngdZzW1ffnPeTJ56d93lgyZMhYlkGOkh2RH/S8p/w3yZAhYwMGef3V/ns8R5J3XX4vQ4YMGTj4ktB8D5YhQ4aMPuO9SykP2TJkyNiTQS6xJJnLEr6/3sVlyJCxICMLo//5/Ep/Q4YMGUsxjuKqpnTV8H1ES4YMGbMZ1fL9fXGtP5bB0z4ZMmTsxuDHymCoWIZHMcrJogwZMhZnkEYjGbDImgQkASVJpAwZMmYz+iGVD4RVg2z5VzJkyBjK4GW1rFjW30O6ADJkyNiBkRXr+w0A3rxExTUZMmRswMjSwSqGX3F5gihDhozZDFJ2f6pJ0L+sonKbDBkyRjNIEb8flMnzwzRRhgwZGzCq6Vrn6pvdPdGciAwZMoYyqvUr0sLkv+oMXvzgyZAhYxCDhFSkx03K/rt+pIYyZMgYxKiWw/ojFFla+fDMiAwZMpZidJoBfD9JAfmfyEO/DBkyJjH4MESWSr7RSCgMW8iQIWMQo/MIPhLB08dqy1OGDBn7MLKHPhVAeTEurPPJkCFjQcZRXNUSf3as8ntlyJAxmpEFO5Lwkctw1jDohGwZMmSsy8iCLCqBNQYpyv+3DBkyNmBkjYGs2dlJ+37kuTJkyJDx1CtBYK0GdBkyZMjgB+JH7FxrLy+xMmTIGM3ICmpkP78Mt9qoMmTIGM2oJnm82fnUKEY/SZUhQ8ayjC/5hPoI1Oj+pAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '42';
            clearTimeout(titleTime);
        } else {
            document.title = 'Don‘t Panic！';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
